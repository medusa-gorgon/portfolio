"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(e){var n={};function s(i){if(n[i])return n[i].exports;var t=n[i]={i:i,l:!1,exports:{}};return e[i].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.m=e,s.c=n,s.d=function(e,n,i){s.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,n){if(1&n&&(e=s(e)),8&n)return e;if(4&n&&"object"===_typeof(e)&&e&&e.__esModule)return e;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var t in e)s.d(i,t,function(n){return e[n]}.bind(null,t));return i},s.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(n,"a",n),n},s.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},s.p="",s(s.s=0)}({"./dev/js/Common/mobile-menu.js":function devJsCommonMobileMenuJs(module,exports){eval("const pageMap = {\n  '#home': '.hero',\n  '#about': '.about',\n  '#portfolio': '.portfolio',\n  '#blog': '.blog',\n  '#contact': '.contact',\n};\n\nconst handlePage = () => {\n  const pageName = pageMap[window.location.hash];\n  if (pageName) {\n    const page = document.querySelector(pageName);\n    page.scrollIntoView({ behavior: 'smooth' });\n  }\n};\n\nhandlePage();\nwindow.addEventListener('hashchange', handlePage);\n\n\n//# sourceURL=webpack:///./dev/js/Common/mobile-menu.js?")},"./dev/js/Common/swiper.js":function devJsCommonSwiperJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ \"./node_modules/swiper/js/swiper.esm.bundle.js\");\n\n\nconst commonSwiper = new swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.swiper .swiper-container', {\n  loop: true,\n  grabCursor: true,\n  navigation: {\n    nextEl: '.swiper__button_next',\n    prevEl: '.swiper__button_prev',\n  },\n});\n\n\n//# sourceURL=webpack:///./dev/js/Common/swiper.js?")},"./dev/js/app.js":function devJsAppJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Common_swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Common/swiper */ "./dev/js/Common/swiper.js");\n/* harmony import */ var _Common_mobile_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Common/mobile-menu */ "./dev/js/Common/mobile-menu.js");\n/* harmony import */ var _Common_mobile_menu__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Common_mobile_menu__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n//# sourceURL=webpack:///./dev/js/app.js?')},"./node_modules/dom7/dist/dom7.modular.js":function node_modulesDom7DistDom7ModularJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$", function() { return $; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeClass", function() { return removeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasClass", function() { return hasClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleClass", function() { return toggleClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attr", function() { return attr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAttr", function() { return removeAttr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prop", function() { return prop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "data", function() { return data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeData", function() { return removeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataset", function() { return dataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "val", function() { return val; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return transition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "once", function() { return once; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transitionEnd", function() { return transitionEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationEnd", function() { return animationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "width", function() { return width; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerWidth", function() { return outerWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "height", function() { return height; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerHeight", function() { return outerHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return hide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "show", function() { return show; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styles", function() { return styles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "css", function() { return css; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "each", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return html; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is", function() { return is; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return indexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "index", function() { return index; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eq", function() { return eq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendTo", function() { return appendTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepend", function() { return prepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prependTo", function() { return prependTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertBefore", function() { return insertBefore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertAfter", function() { return insertAfter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "next", function() { return next; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextAll", function() { return nextAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prev", function() { return prev; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prevAll", function() { return prevAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siblings", function() { return siblings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parent", function() { return parent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parents", function() { return parents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closest", function() { return closest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "children", function() { return children; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach", function() { return detach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollTo", function() { return scrollTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollTop", function() { return scrollTop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollLeft", function() { return scrollLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animate", function() { return animate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stop", function() { return stop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blur", function() { return blur; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focusin", function() { return focusin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focusout", function() { return focusout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyup", function() { return keyup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keydown", function() { return keydown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keypress", function() { return keypress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "submit", function() { return submit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "change", function() { return change; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mousedown", function() { return mousedown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mousemove", function() { return mousemove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseup", function() { return mouseup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseenter", function() { return mouseenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseleave", function() { return mouseleave; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseout", function() { return mouseout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseover", function() { return mouseover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchstart", function() { return touchstart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchend", function() { return touchend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchmove", function() { return touchmove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return resize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scroll", function() { return scroll; });\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssr-window */ "./node_modules/ssr-window/dist/ssr-window.esm.js");\n/**\n * Dom7 2.1.5\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * http://framework7.io/docs/dom.html\n *\n * Copyright 2020, Vladimir Kharlampidi\n * The iDangero.us\n * http://www.idangero.us/\n *\n * Licensed under MIT\n *\n * Released on: May 15, 2020\n */\n\n\nclass Dom7 {\n  constructor(arr) {\n    const self = this;\n    // Create array-like object\n    for (let i = 0; i < arr.length; i += 1) {\n      self[i] = arr[i];\n    }\n    self.length = arr.length;\n    // Return collection with methods\n    return this;\n  }\n}\n\nfunction $(selector, context) {\n  const arr = [];\n  let i = 0;\n  if (selector && !context) {\n    if (selector instanceof Dom7) {\n      return selector;\n    }\n  }\n  if (selector) {\n      // String\n    if (typeof selector === \'string\') {\n      let els;\n      let tempParent;\n      const html = selector.trim();\n      if (html.indexOf(\'<\') >= 0 && html.indexOf(\'>\') >= 0) {\n        let toCreate = \'div\';\n        if (html.indexOf(\'<li\') === 0) toCreate = \'ul\';\n        if (html.indexOf(\'<tr\') === 0) toCreate = \'tbody\';\n        if (html.indexOf(\'<td\') === 0 || html.indexOf(\'<th\') === 0) toCreate = \'tr\';\n        if (html.indexOf(\'<tbody\') === 0) toCreate = \'table\';\n        if (html.indexOf(\'<option\') === 0) toCreate = \'select\';\n        tempParent = ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].createElement(toCreate);\n        tempParent.innerHTML = html;\n        for (i = 0; i < tempParent.childNodes.length; i += 1) {\n          arr.push(tempParent.childNodes[i]);\n        }\n      } else {\n        if (!context && selector[0] === \'#\' && !selector.match(/[ .<>:~]/)) {\n          // Pure ID selector\n          els = [ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].getElementById(selector.trim().split(\'#\')[1])];\n        } else {\n          // Other selectors\n          els = (context || ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"]).querySelectorAll(selector.trim());\n        }\n        for (i = 0; i < els.length; i += 1) {\n          if (els[i]) arr.push(els[i]);\n        }\n      }\n    } else if (selector.nodeType || selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"] || selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"]) {\n      // Node/element\n      arr.push(selector);\n    } else if (selector.length > 0 && selector[0].nodeType) {\n      // Array of elements or instance of Dom\n      for (i = 0; i < selector.length; i += 1) {\n        arr.push(selector[i]);\n      }\n    }\n  }\n  return new Dom7(arr);\n}\n\n$.fn = Dom7.prototype;\n$.Class = Dom7;\n$.Dom7 = Dom7;\n\nfunction unique(arr) {\n  const uniqueArray = [];\n  for (let i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n  }\n  return uniqueArray;\n}\nfunction toCamelCase(string) {\n  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());\n}\n\nfunction requestAnimationFrame(callback) {\n  if (ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].requestAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].requestAnimationFrame(callback);\n  else if (ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].webkitRequestAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].webkitRequestAnimationFrame(callback);\n  return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].setTimeout(callback, 1000 / 60);\n}\nfunction cancelAnimationFrame(id) {\n  if (ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].cancelAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].cancelAnimationFrame(id);\n  else if (ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].webkitCancelAnimationFrame) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].webkitCancelAnimationFrame(id);\n  return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].clearTimeout(id);\n}\n\n// Classes and attributes\nfunction addClass(className) {\n  if (typeof className === \'undefined\') {\n    return this;\n  }\n  const classes = className.split(\' \');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== \'undefined\' && typeof this[j].classList !== \'undefined\') this[j].classList.add(classes[i]);\n    }\n  }\n  return this;\n}\nfunction removeClass(className) {\n  const classes = className.split(\' \');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== \'undefined\' && typeof this[j].classList !== \'undefined\') this[j].classList.remove(classes[i]);\n    }\n  }\n  return this;\n}\nfunction hasClass(className) {\n  if (!this[0]) return false;\n  return this[0].classList.contains(className);\n}\nfunction toggleClass(className) {\n  const classes = className.split(\' \');\n  for (let i = 0; i < classes.length; i += 1) {\n    for (let j = 0; j < this.length; j += 1) {\n      if (typeof this[j] !== \'undefined\' && typeof this[j].classList !== \'undefined\') this[j].classList.toggle(classes[i]);\n    }\n  }\n  return this;\n}\nfunction attr(attrs, value) {\n  if (arguments.length === 1 && typeof attrs === \'string\') {\n    // Get attr\n    if (this[0]) return this[0].getAttribute(attrs);\n    return undefined;\n  }\n\n  // Set attrs\n  for (let i = 0; i < this.length; i += 1) {\n    if (arguments.length === 2) {\n      // String\n      this[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      // eslint-disable-next-line\n      for (const attrName in attrs) {\n        this[i][attrName] = attrs[attrName];\n        this[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction removeAttr(attr) {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].removeAttribute(attr);\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prop(props, value) {\n  if (arguments.length === 1 && typeof props === \'string\') {\n    // Get prop\n    if (this[0]) return this[0][props];\n  } else {\n    // Set props\n    for (let i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i][props] = value;\n      } else {\n        // Object\n        // eslint-disable-next-line\n        for (const propName in props) {\n          this[i][propName] = props[propName];\n        }\n      }\n    }\n    return this;\n  }\n}\nfunction data(key, value) {\n  let el;\n  if (typeof value === \'undefined\') {\n    el = this[0];\n    // Get value\n    if (el) {\n      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {\n        return el.dom7ElementDataStorage[key];\n      }\n\n      const dataKey = el.getAttribute(`data-${key}`);\n      if (dataKey) {\n        return dataKey;\n      }\n      return undefined;\n    }\n    return undefined;\n  }\n\n  // Set value\n  for (let i = 0; i < this.length; i += 1) {\n    el = this[i];\n    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};\n    el.dom7ElementDataStorage[key] = value;\n  }\n  return this;\n}\nfunction removeData(key) {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {\n      el.dom7ElementDataStorage[key] = null;\n      delete el.dom7ElementDataStorage[key];\n    }\n  }\n}\nfunction dataset() {\n  const el = this[0];\n  if (!el) return undefined;\n  const dataset = {}; // eslint-disable-line\n  if (el.dataset) {\n    // eslint-disable-next-line\n    for (const dataKey in el.dataset) {\n      dataset[dataKey] = el.dataset[dataKey];\n    }\n  } else {\n    for (let i = 0; i < el.attributes.length; i += 1) {\n      // eslint-disable-next-line\n      const attr = el.attributes[i];\n      if (attr.name.indexOf(\'data-\') >= 0) {\n        dataset[toCamelCase(attr.name.split(\'data-\')[1])] = attr.value;\n      }\n    }\n  }\n  // eslint-disable-next-line\n  for (const key in dataset) {\n    if (dataset[key] === \'false\') dataset[key] = false;\n    else if (dataset[key] === \'true\') dataset[key] = true;\n    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;\n  }\n  return dataset;\n}\nfunction val(value) {\n  const dom = this;\n  if (typeof value === \'undefined\') {\n    if (dom[0]) {\n      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === \'select\') {\n        const values = [];\n        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {\n          values.push(dom[0].selectedOptions[i].value);\n        }\n        return values;\n      }\n      return dom[0].value;\n    }\n    return undefined;\n  }\n\n  for (let i = 0; i < dom.length; i += 1) {\n    const el = dom[i];\n    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === \'select\') {\n      for (let j = 0; j < el.options.length; j += 1) {\n        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;\n      }\n    } else {\n      el.value = value;\n    }\n  }\n  return dom;\n}\n// Transforms\n// eslint-disable-next-line\nfunction transform(transform) {\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransform = transform;\n    elStyle.transform = transform;\n  }\n  return this;\n}\nfunction transition(duration) {\n  if (typeof duration !== \'string\') {\n    duration = `${duration}ms`; // eslint-disable-line\n  }\n  for (let i = 0; i < this.length; i += 1) {\n    const elStyle = this[i].style;\n    elStyle.webkitTransitionDuration = duration;\n    elStyle.transitionDuration = duration;\n  }\n  return this;\n}\n// Events\nfunction on(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === \'function\') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  function handleLiveEvent(e) {\n    const target = e.target;\n    if (!target) return;\n    const eventData = e.target.dom7EventData || [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    if ($(target).is(targetSelector)) listener.apply(target, eventData);\n    else {\n      const parents = $(target).parents(); // eslint-disable-line\n      for (let k = 0; k < parents.length; k += 1) {\n        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n      }\n    }\n  }\n  function handleEvent(e) {\n    const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n    if (eventData.indexOf(e) < 0) {\n      eventData.unshift(e);\n    }\n    listener.apply(this, eventData);\n  }\n  const events = eventType.split(\' \');\n  let j;\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7Listeners) el.dom7Listeners = {};\n        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n        el.dom7Listeners[event].push({\n          listener,\n          proxyListener: handleEvent,\n        });\n        el.addEventListener(event, handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        const event = events[j];\n        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n        el.dom7LiveListeners[event].push({\n          listener,\n          proxyListener: handleLiveEvent,\n        });\n        el.addEventListener(event, handleLiveEvent, capture);\n      }\n    }\n  }\n  return this;\n}\nfunction off(...args) {\n  let [eventType, targetSelector, listener, capture] = args;\n  if (typeof args[1] === \'function\') {\n    [eventType, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  if (!capture) capture = false;\n\n  const events = eventType.split(\' \');\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let handlers;\n      if (!targetSelector && el.dom7Listeners) {\n        handlers = el.dom7Listeners[event];\n      } else if (targetSelector && el.dom7LiveListeners) {\n        handlers = el.dom7LiveListeners[event];\n      }\n      if (handlers && handlers.length) {\n        for (let k = handlers.length - 1; k >= 0; k -= 1) {\n          const handler = handlers[k];\n          if (listener && handler.listener === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          } else if (!listener) {\n            el.removeEventListener(event, handler.proxyListener, capture);\n            handlers.splice(k, 1);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction once(...args) {\n  const dom = this;\n  let [eventName, targetSelector, listener, capture] = args;\n  if (typeof args[1] === \'function\') {\n    [eventName, listener, capture] = args;\n    targetSelector = undefined;\n  }\n  function onceHandler(...eventArgs) {\n    listener.apply(this, eventArgs);\n    dom.off(eventName, targetSelector, onceHandler, capture);\n    if (onceHandler.dom7proxy) {\n      delete onceHandler.dom7proxy;\n    }\n  }\n  onceHandler.dom7proxy = listener;\n  return dom.on(eventName, targetSelector, onceHandler, capture);\n}\nfunction trigger(...args) {\n  const events = args[0].split(\' \');\n  const eventData = args[1];\n  for (let i = 0; i < events.length; i += 1) {\n    const event = events[i];\n    for (let j = 0; j < this.length; j += 1) {\n      const el = this[j];\n      let evt;\n      try {\n        evt = new ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].CustomEvent(event, {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true,\n        });\n      } catch (e) {\n        evt = ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].createEvent(\'Event\');\n        evt.initEvent(event, true, true);\n        evt.detail = eventData;\n      }\n      // eslint-disable-next-line\n      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n      el.dispatchEvent(evt);\n      el.dom7EventData = [];\n      delete el.dom7EventData;\n    }\n  }\n  return this;\n}\nfunction transitionEnd(callback) {\n  const events = [\'webkitTransitionEnd\', \'transitionend\'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    /* jshint validthis:true */\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\nfunction animationEnd(callback) {\n  const events = [\'webkitAnimationEnd\', \'animationend\'];\n  const dom = this;\n  let i;\n  function fireCallBack(e) {\n    if (e.target !== this) return;\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\n// Sizing/Styles\nfunction width() {\n  if (this[0] === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"]) {\n    return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].innerWidth;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css(\'width\'));\n  }\n\n  return null;\n}\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetWidth + parseFloat(styles.getPropertyValue(\'margin-right\')) + parseFloat(styles.getPropertyValue(\'margin-left\'));\n    }\n    return this[0].offsetWidth;\n  }\n  return null;\n}\nfunction height() {\n  if (this[0] === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"]) {\n    return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].innerHeight;\n  }\n\n  if (this.length > 0) {\n    return parseFloat(this.css(\'height\'));\n  }\n\n  return null;\n}\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      const styles = this.styles();\n      return this[0].offsetHeight + parseFloat(styles.getPropertyValue(\'margin-top\')) + parseFloat(styles.getPropertyValue(\'margin-bottom\'));\n    }\n    return this[0].offsetHeight;\n  }\n  return null;\n}\nfunction offset() {\n  if (this.length > 0) {\n    const el = this[0];\n    const box = el.getBoundingClientRect();\n    const body = ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"] ? ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].scrollY : el.scrollTop;\n    const scrollLeft = el === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"] ? ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].scrollX : el.scrollLeft;\n    return {\n      top: (box.top + scrollTop) - clientTop,\n      left: (box.left + scrollLeft) - clientLeft,\n    };\n  }\n\n  return null;\n}\nfunction hide() {\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].style.display = \'none\';\n  }\n  return this;\n}\nfunction show() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.style.display === \'none\') {\n      el.style.display = \'\';\n    }\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].getComputedStyle(el, null).getPropertyValue(\'display\') === \'none\') {\n      // Still not visible\n      el.style.display = \'block\';\n    }\n  }\n  return this;\n}\nfunction styles() {\n  if (this[0]) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].getComputedStyle(this[0], null);\n  return {};\n}\nfunction css(props, value) {\n  let i;\n  if (arguments.length === 1) {\n    if (typeof props === \'string\') {\n      if (this[0]) return ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].getComputedStyle(this[0], null).getPropertyValue(props);\n    } else {\n      for (i = 0; i < this.length; i += 1) {\n        // eslint-disable-next-line\n        for (let prop in props) {\n          this[i].style[prop] = props[prop];\n        }\n      }\n      return this;\n    }\n  }\n  if (arguments.length === 2 && typeof props === \'string\') {\n    for (i = 0; i < this.length; i += 1) {\n      this[i].style[props] = value;\n    }\n    return this;\n  }\n  return this;\n}\n\n// Dom manipulation\nfunction toArray() {\n  const arr = [];\n  for (let i = 0; i < this.length; i += 1) {\n    arr.push(this[i]);\n  }\n  return arr;\n}\n// Iterate over the collection passing elements to `callback`\nfunction each(callback) {\n  // Don\'t bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], i, this[i]) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction forEach(callback) {\n  // Don\'t bother continuing without a callback\n  if (!callback) return this;\n  // Iterate over the current collection\n  for (let i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this[i], this[i], i) === false) {\n      // End the loop early\n      return this;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\nfunction filter(callback) {\n  const matchedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);\n  }\n  return new Dom7(matchedItems);\n}\nfunction map(callback) {\n  const modifiedItems = [];\n  const dom = this;\n  for (let i = 0; i < dom.length; i += 1) {\n    modifiedItems.push(callback.call(dom[i], i, dom[i]));\n  }\n  return new Dom7(modifiedItems);\n}\n// eslint-disable-next-line\nfunction html(html) {\n  if (typeof html === \'undefined\') {\n    return this[0] ? this[0].innerHTML : undefined;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].innerHTML = html;\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction text(text) {\n  if (typeof text === \'undefined\') {\n    if (this[0]) {\n      return this[0].textContent.trim();\n    }\n    return null;\n  }\n\n  for (let i = 0; i < this.length; i += 1) {\n    this[i].textContent = text;\n  }\n  return this;\n}\nfunction is(selector) {\n  const el = this[0];\n  let compareWith;\n  let i;\n  if (!el || typeof selector === \'undefined\') return false;\n  if (typeof selector === \'string\') {\n    if (el.matches) return el.matches(selector);\n    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n\n    compareWith = $(selector);\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  } else if (selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"]) return el === ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"];\n  else if (selector === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"]) return el === ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"];\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) return true;\n    }\n    return false;\n  }\n  return false;\n}\nfunction indexOf(el) {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i] === el) return i;\n  }\n  return -1;\n}\nfunction index() {\n  let child = this[0];\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\n// eslint-disable-next-line\nfunction eq(index) {\n  if (typeof index === \'undefined\') return this;\n  const length = this.length;\n  let returnIndex;\n  if (index > length - 1) {\n    return new Dom7([]);\n  }\n  if (index < 0) {\n    returnIndex = length + index;\n    if (returnIndex < 0) return new Dom7([]);\n    return new Dom7([this[returnIndex]]);\n  }\n  return new Dom7([this[index]]);\n}\nfunction append(...args) {\n  let newChild;\n\n  for (let k = 0; k < args.length; k += 1) {\n    newChild = args[k];\n    for (let i = 0; i < this.length; i += 1) {\n      if (typeof newChild === \'string\') {\n        const tempDiv = ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].createElement(\'div\');\n        tempDiv.innerHTML = newChild;\n        while (tempDiv.firstChild) {\n          this[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (let j = 0; j < newChild.length; j += 1) {\n          this[i].appendChild(newChild[j]);\n        }\n      } else {\n        this[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n// eslint-disable-next-line\nfunction appendTo(parent) {\n  $(parent).append(this);\n  return this;\n}\nfunction prepend(newChild) {\n  let i;\n  let j;\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === \'string\') {\n      const tempDiv = ssr_window__WEBPACK_IMPORTED_MODULE_0__["document"].createElement(\'div\');\n      tempDiv.innerHTML = newChild;\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n      }\n    } else {\n      this[i].insertBefore(newChild, this[i].childNodes[0]);\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction prependTo(parent) {\n  $(parent).prepend(this);\n  return this;\n}\nfunction insertBefore(selector) {\n  const before = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (before.length === 1) {\n      before[0].parentNode.insertBefore(this[i], before[0]);\n    } else if (before.length > 1) {\n      for (let j = 0; j < before.length; j += 1) {\n        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n      }\n    }\n  }\n}\nfunction insertAfter(selector) {\n  const after = $(selector);\n  for (let i = 0; i < this.length; i += 1) {\n    if (after.length === 1) {\n      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n    } else if (after.length > 1) {\n      for (let j = 0; j < after.length; j += 1) {\n        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n      }\n    }\n  }\n}\nfunction next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n        return new Dom7([this[0].nextElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction nextAll(selector) {\n  const nextEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(next).is(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return new Dom7(nextEls);\n}\nfunction prev(selector) {\n  if (this.length > 0) {\n    const el = this[0];\n    if (selector) {\n      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n        return new Dom7([el.previousElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction prevAll(selector) {\n  const prevEls = [];\n  let el = this[0];\n  if (!el) return new Dom7([]);\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($(prev).is(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return new Dom7(prevEls);\n}\nfunction siblings(selector) {\n  return this.nextAll(selector).add(this.prevAll(selector));\n}\nfunction parent(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode !== null) {\n      if (selector) {\n        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n      } else {\n        parents.push(this[i].parentNode);\n      }\n    }\n  }\n  return $(unique(parents));\n}\nfunction parents(selector) {\n  const parents = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    let parent = this[i].parentNode; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if ($(parent).is(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n  }\n  return $(unique(parents));\n}\nfunction closest(selector) {\n  let closest = this; // eslint-disable-line\n  if (typeof selector === \'undefined\') {\n    return new Dom7([]);\n  }\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n  return closest;\n}\nfunction find(selector) {\n  const foundElements = [];\n  for (let i = 0; i < this.length; i += 1) {\n    const found = this[i].querySelectorAll(selector);\n    for (let j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n  return new Dom7(foundElements);\n}\nfunction children(selector) {\n  const children = []; // eslint-disable-line\n  for (let i = 0; i < this.length; i += 1) {\n    const childNodes = this[i].childNodes;\n\n    for (let j = 0; j < childNodes.length; j += 1) {\n      if (!selector) {\n        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);\n      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n  return new Dom7(unique(children));\n}\nfunction remove() {\n  for (let i = 0; i < this.length; i += 1) {\n    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n  }\n  return this;\n}\nfunction detach() {\n  return this.remove();\n}\nfunction add(...args) {\n  const dom = this;\n  let i;\n  let j;\n  for (i = 0; i < args.length; i += 1) {\n    const toAdd = $(args[i]);\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom[dom.length] = toAdd[j];\n      dom.length += 1;\n    }\n  }\n  return dom;\n}\nfunction empty() {\n  for (let i = 0; i < this.length; i += 1) {\n    const el = this[i];\n    if (el.nodeType === 1) {\n      for (let j = 0; j < el.childNodes.length; j += 1) {\n        if (el.childNodes[j].parentNode) {\n          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);\n        }\n      }\n      el.textContent = \'\';\n    }\n  }\n  return this;\n}\n\nfunction scrollTo(...args) {\n  let [left, top, duration, easing, callback] = args;\n  if (args.length === 4 && typeof easing === \'function\') {\n    callback = easing;\n    [left, top, duration, callback, easing] = args;\n  }\n  if (typeof easing === \'undefined\') easing = \'swing\';\n\n  return this.each(function animate() {\n    const el = this;\n    let currentTop;\n    let currentLeft;\n    let maxTop;\n    let maxLeft;\n    let newTop;\n    let newLeft;\n    let scrollTop; // eslint-disable-line\n    let scrollLeft; // eslint-disable-line\n    let animateTop = top > 0 || top === 0;\n    let animateLeft = left > 0 || left === 0;\n    if (typeof easing === \'undefined\') {\n      easing = \'swing\';\n    }\n    if (animateTop) {\n      currentTop = el.scrollTop;\n      if (!duration) {\n        el.scrollTop = top;\n      }\n    }\n    if (animateLeft) {\n      currentLeft = el.scrollLeft;\n      if (!duration) {\n        el.scrollLeft = left;\n      }\n    }\n    if (!duration) return;\n    if (animateTop) {\n      maxTop = el.scrollHeight - el.offsetHeight;\n      newTop = Math.max(Math.min(top, maxTop), 0);\n    }\n    if (animateLeft) {\n      maxLeft = el.scrollWidth - el.offsetWidth;\n      newLeft = Math.max(Math.min(left, maxLeft), 0);\n    }\n    let startTime = null;\n    if (animateTop && newTop === currentTop) animateTop = false;\n    if (animateLeft && newLeft === currentLeft) animateLeft = false;\n    function render(time = new Date().getTime()) {\n      if (startTime === null) {\n        startTime = time;\n      }\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = easing === \'linear\' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));\n      let done;\n      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));\n      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));\n      if (animateTop && newTop > currentTop && scrollTop >= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateTop && newTop < currentTop && scrollTop <= newTop) {\n        el.scrollTop = newTop;\n        done = true;\n      }\n      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {\n        el.scrollLeft = newLeft;\n        done = true;\n      }\n\n      if (done) {\n        if (callback) callback();\n        return;\n      }\n      if (animateTop) el.scrollTop = scrollTop;\n      if (animateLeft) el.scrollLeft = scrollLeft;\n      requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n  });\n}\n// scrollTop(top, duration, easing, callback) {\nfunction scrollTop(...args) {\n  let [top, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === \'function\') {\n    [top, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof top === \'undefined\') {\n    if (dom.length > 0) return dom[0].scrollTop;\n    return null;\n  }\n  return dom.scrollTo(undefined, top, duration, easing, callback);\n}\nfunction scrollLeft(...args) {\n  let [left, duration, easing, callback] = args;\n  if (args.length === 3 && typeof easing === \'function\') {\n    [left, duration, callback, easing] = args;\n  }\n  const dom = this;\n  if (typeof left === \'undefined\') {\n    if (dom.length > 0) return dom[0].scrollLeft;\n    return null;\n  }\n  return dom.scrollTo(left, undefined, duration, easing, callback);\n}\n\nfunction animate(initialProps, initialParams) {\n  const els = this;\n  const a = {\n    props: Object.assign({}, initialProps),\n    params: Object.assign({\n      duration: 300,\n      easing: \'swing\', // or \'linear\'\n      /* Callbacks\n      begin(elements)\n      complete(elements)\n      progress(elements, complete, remaining, start, tweenValue)\n      */\n    }, initialParams),\n\n    elements: els,\n    animating: false,\n    que: [],\n\n    easingProgress(easing, progress) {\n      if (easing === \'swing\') {\n        return 0.5 - (Math.cos(progress * Math.PI) / 2);\n      }\n      if (typeof easing === \'function\') {\n        return easing(progress);\n      }\n      return progress;\n    },\n    stop() {\n      if (a.frameId) {\n        cancelAnimationFrame(a.frameId);\n      }\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      a.que = [];\n    },\n    done(complete) {\n      a.animating = false;\n      a.elements.each((index, el) => {\n        const element = el;\n        delete element.dom7AnimateInstance;\n      });\n      if (complete) complete(els);\n      if (a.que.length > 0) {\n        const que = a.que.shift();\n        a.animate(que[0], que[1]);\n      }\n    },\n    animate(props, params) {\n      if (a.animating) {\n        a.que.push([props, params]);\n        return a;\n      }\n      const elements = [];\n\n      // Define & Cache Initials & Units\n      a.elements.each((index, el) => {\n        let initialFullValue;\n        let initialValue;\n        let unit;\n        let finalValue;\n        let finalFullValue;\n\n        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;\n\n        elements[index] = {\n          container: el,\n        };\n        Object.keys(props).forEach((prop) => {\n          initialFullValue = ssr_window__WEBPACK_IMPORTED_MODULE_0__["window"].getComputedStyle(el, null).getPropertyValue(prop).replace(\',\', \'.\');\n          initialValue = parseFloat(initialFullValue);\n          unit = initialFullValue.replace(initialValue, \'\');\n          finalValue = parseFloat(props[prop]);\n          finalFullValue = props[prop] + unit;\n          elements[index][prop] = {\n            initialFullValue,\n            initialValue,\n            unit,\n            finalValue,\n            finalFullValue,\n            currentValue: initialValue,\n          };\n        });\n      });\n\n      let startTime = null;\n      let time;\n      let elementsDone = 0;\n      let propsDone = 0;\n      let done;\n      let began = false;\n\n      a.animating = true;\n\n      function render() {\n        time = new Date().getTime();\n        let progress;\n        let easeProgress;\n        // let el;\n        if (!began) {\n          began = true;\n          if (params.begin) params.begin(els);\n        }\n        if (startTime === null) {\n          startTime = time;\n        }\n        if (params.progress) {\n          // eslint-disable-next-line\n          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);\n        }\n\n        elements.forEach((element) => {\n          const el = element;\n          if (done || el.done) return;\n          Object.keys(props).forEach((prop) => {\n            if (done || el.done) return;\n            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);\n            easeProgress = a.easingProgress(params.easing, progress);\n            const { initialValue, finalValue, unit } = el[prop];\n            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));\n            const currentValue = el[prop].currentValue;\n\n            if (\n              (finalValue > initialValue && currentValue >= finalValue) ||\n              (finalValue < initialValue && currentValue <= finalValue)) {\n              el.container.style[prop] = finalValue + unit;\n              propsDone += 1;\n              if (propsDone === Object.keys(props).length) {\n                el.done = true;\n                elementsDone += 1;\n              }\n              if (elementsDone === elements.length) {\n                done = true;\n              }\n            }\n            if (done) {\n              a.done(params.complete);\n              return;\n            }\n            el.container.style[prop] = currentValue + unit;\n          });\n        });\n        if (done) return;\n        // Then call\n        a.frameId = requestAnimationFrame(render);\n      }\n      a.frameId = requestAnimationFrame(render);\n      return a;\n    },\n  };\n\n  if (a.elements.length === 0) {\n    return els;\n  }\n\n  let animateInstance;\n  for (let i = 0; i < a.elements.length; i += 1) {\n    if (a.elements[i].dom7AnimateInstance) {\n      animateInstance = a.elements[i].dom7AnimateInstance;\n    } else a.elements[i].dom7AnimateInstance = a;\n  }\n  if (!animateInstance) {\n    animateInstance = a;\n  }\n\n  if (initialProps === \'stop\') {\n    animateInstance.stop();\n  } else {\n    animateInstance.animate(a.props, a.params);\n  }\n\n  return els;\n}\n\nfunction stop() {\n  const els = this;\n  for (let i = 0; i < els.length; i += 1) {\n    if (els[i].dom7AnimateInstance) {\n      els[i].dom7AnimateInstance.stop();\n    }\n  }\n}\n\nconst noTrigger = (\'resize scroll\').split(\' \');\nfunction eventShortcut(name, ...args) {\n  if (typeof args[0] === \'undefined\') {\n    for (let i = 0; i < this.length; i += 1) {\n      if (noTrigger.indexOf(name) < 0) {\n        if (name in this[i]) this[i][name]();\n        else {\n          $(this[i]).trigger(name);\n        }\n      }\n    }\n    return this;\n  }\n  return this.on(name, ...args);\n}\n\nfunction click(...args) {\n  return eventShortcut.bind(this)(\'click\', ...args);\n}\nfunction blur(...args) {\n  return eventShortcut.bind(this)(\'blur\', ...args);\n}\nfunction focus(...args) {\n  return eventShortcut.bind(this)(\'focus\', ...args);\n}\nfunction focusin(...args) {\n  return eventShortcut.bind(this)(\'focusin\', ...args);\n}\nfunction focusout(...args) {\n  return eventShortcut.bind(this)(\'focusout\', ...args);\n}\nfunction keyup(...args) {\n  return eventShortcut.bind(this)(\'keyup\', ...args);\n}\nfunction keydown(...args) {\n  return eventShortcut.bind(this)(\'keydown\', ...args);\n}\nfunction keypress(...args) {\n  return eventShortcut.bind(this)(\'keypress\', ...args);\n}\nfunction submit(...args) {\n  return eventShortcut.bind(this)(\'submit\', ...args);\n}\nfunction change(...args) {\n  return eventShortcut.bind(this)(\'change\', ...args);\n}\nfunction mousedown(...args) {\n  return eventShortcut.bind(this)(\'mousedown\', ...args);\n}\nfunction mousemove(...args) {\n  return eventShortcut.bind(this)(\'mousemove\', ...args);\n}\nfunction mouseup(...args) {\n  return eventShortcut.bind(this)(\'mouseup\', ...args);\n}\nfunction mouseenter(...args) {\n  return eventShortcut.bind(this)(\'mouseenter\', ...args);\n}\nfunction mouseleave(...args) {\n  return eventShortcut.bind(this)(\'mouseleave\', ...args);\n}\nfunction mouseout(...args) {\n  return eventShortcut.bind(this)(\'mouseout\', ...args);\n}\nfunction mouseover(...args) {\n  return eventShortcut.bind(this)(\'mouseover\', ...args);\n}\nfunction touchstart(...args) {\n  return eventShortcut.bind(this)(\'touchstart\', ...args);\n}\nfunction touchend(...args) {\n  return eventShortcut.bind(this)(\'touchend\', ...args);\n}\nfunction touchmove(...args) {\n  return eventShortcut.bind(this)(\'touchmove\', ...args);\n}\nfunction resize(...args) {\n  return eventShortcut.bind(this)(\'resize\', ...args);\n}\nfunction scroll(...args) {\n  return eventShortcut.bind(this)(\'scroll\', ...args);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/dom7/dist/dom7.modular.js?')},"./node_modules/ssr-window/dist/ssr-window.esm.js":function node_modulesSsrWindowDistSsrWindowEsmJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"document\", function() { return doc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"window\", function() { return win; });\n/**\n * SSR Window 2.0.0\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2020, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: May 12, 2020\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n    return (obj !== null &&\n        typeof obj === 'object' &&\n        'constructor' in obj &&\n        obj.constructor === Object);\n}\nfunction extend(target, src) {\n    if (target === void 0) { target = {}; }\n    if (src === void 0) { src = {}; }\n    Object.keys(src).forEach(function (key) {\n        if (typeof target[key] === 'undefined')\n            target[key] = src[key];\n        else if (isObject(src[key]) &&\n            isObject(target[key]) &&\n            Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\n\nvar doc = typeof document !== 'undefined' ? document : {};\nvar ssrDocument = {\n    body: {},\n    addEventListener: function () { },\n    removeEventListener: function () { },\n    activeElement: {\n        blur: function () { },\n        nodeName: '',\n    },\n    querySelector: function () {\n        return null;\n    },\n    querySelectorAll: function () {\n        return [];\n    },\n    getElementById: function () {\n        return null;\n    },\n    createEvent: function () {\n        return {\n            initEvent: function () { },\n        };\n    },\n    createElement: function () {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute: function () { },\n            getElementsByTagName: function () {\n                return [];\n            },\n        };\n    },\n    createElementNS: function () {\n        return {};\n    },\n    importNode: function () {\n        return null;\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n};\nextend(doc, ssrDocument);\n\nvar win = typeof window !== 'undefined' ? window : {};\nvar ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: '',\n    },\n    location: {\n        hash: '',\n        host: '',\n        hostname: '',\n        href: '',\n        origin: '',\n        pathname: '',\n        protocol: '',\n        search: '',\n    },\n    history: {\n        replaceState: function () { },\n        pushState: function () { },\n        go: function () { },\n        back: function () { },\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener: function () { },\n    removeEventListener: function () { },\n    getComputedStyle: function () {\n        return {\n            getPropertyValue: function () {\n                return '';\n            },\n        };\n    },\n    Image: function () { },\n    Date: function () { },\n    screen: {},\n    setTimeout: function () { },\n    clearTimeout: function () { },\n    matchMedia: function () {\n        return {};\n    },\n};\nextend(win, ssrWindow);\n\n\n\n\n//# sourceURL=webpack:///./node_modules/ssr-window/dist/ssr-window.esm.js?")},"./node_modules/swiper/js/swiper.esm.bundle.js":function node_modulesSwiperJsSwiperEsmBundleJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom7/dist/dom7.modular */ \"./node_modules/dom7/dist/dom7.modular.js\");\n/* harmony import */ var ssr_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ssr-window */ \"./node_modules/ssr-window/dist/ssr-window.esm.js\");\n/**\n * Swiper 5.4.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * http://swiperjs.com\n *\n * Copyright 2014-2020 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: June 16, 2020\n */\n\n\n\n\nconst Methods = {\n  addClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"addClass\"],\n  removeClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"removeClass\"],\n  hasClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"hasClass\"],\n  toggleClass: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"toggleClass\"],\n  attr: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"attr\"],\n  removeAttr: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"removeAttr\"],\n  data: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"data\"],\n  transform: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transform\"],\n  transition: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transition\"],\n  on: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"on\"],\n  off: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"off\"],\n  trigger: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"trigger\"],\n  transitionEnd: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"transitionEnd\"],\n  outerWidth: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"outerWidth\"],\n  outerHeight: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"outerHeight\"],\n  offset: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"offset\"],\n  css: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"css\"],\n  each: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"each\"],\n  html: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"html\"],\n  text: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"text\"],\n  is: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"is\"],\n  index: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"index\"],\n  eq: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"eq\"],\n  append: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"append\"],\n  prepend: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prepend\"],\n  next: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"next\"],\n  nextAll: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"nextAll\"],\n  prev: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prev\"],\n  prevAll: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"prevAll\"],\n  parent: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"parent\"],\n  parents: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"parents\"],\n  closest: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"closest\"],\n  find: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"find\"],\n  children: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"children\"],\n  filter: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"filter\"],\n  remove: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"remove\"],\n  add: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"add\"],\n  styles: dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"styles\"],\n};\n\nObject.keys(Methods).forEach((methodName) => {\n  dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"].fn[methodName] = dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"].fn[methodName] || Methods[methodName];\n});\n\nconst Utils = {\n  deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key) => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  },\n  nextTick(callback, delay = 0) {\n    return setTimeout(callback, delay);\n  },\n  now() {\n    return Date.now();\n  },\n  getTranslate(el, axis = 'x') {\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n\n    const curStyle = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].getComputedStyle(el, null);\n\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map((a) => a.replace(',', '.')).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) curTransform = transformMatrix.m41;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebKitCSSMatrix) curTransform = transformMatrix.m42;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n  },\n  parseUrlQuery(url) {\n    const query = {};\n    let urlToParse = url || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.href;\n    let i;\n    let params;\n    let param;\n    let length;\n    if (typeof urlToParse === 'string' && urlToParse.length) {\n      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\\S*\\?/, '') : '';\n      params = urlToParse.split('&').filter((paramsPart) => paramsPart !== '');\n      length = params.length;\n\n      for (i = 0; i < length; i += 1) {\n        param = params[i].replace(/#\\S+/g, '').split('=');\n        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';\n      }\n    }\n    return query;\n  },\n  isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;\n  },\n  extend(...args) {\n    const to = Object(args[0]);\n    for (let i = 1; i < args.length; i += 1) {\n      const nextSource = args[i];\n      if (nextSource !== undefined && nextSource !== null) {\n        const keysArray = Object.keys(Object(nextSource));\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  },\n};\n\nconst Support = (function Support() {\n  return {\n    touch: !!(('ontouchstart' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]) || (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].DocumentTouch && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"] instanceof ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].DocumentTouch)),\n\n    pointerEvents: !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].PointerEvent && ('maxTouchPoints' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator) && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.maxTouchPoints >= 0,\n\n    observer: (function checkObserver() {\n      return ('MutationObserver' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"] || 'WebkitMutationObserver' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]);\n    }()),\n\n    passiveListener: (function checkPassiveListener() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          // eslint-disable-next-line\n          get() {\n            supportsPassive = true;\n          },\n        });\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('testPassiveListener', null, opts);\n      } catch (e) {\n        // No support\n      }\n      return supportsPassive;\n    }()),\n\n    gestures: (function checkGestures() {\n      return 'ongesturestart' in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"];\n    }()),\n  };\n}());\n\nclass SwiperClass {\n  constructor(params = {}) {\n    const self = this;\n    self.params = params;\n\n    // Events\n    self.eventsListeners = {};\n\n    if (self.params && self.params.on) {\n      Object.keys(self.params.on).forEach((eventName) => {\n        self.on(eventName, self.params.on[eventName]);\n      });\n    }\n  }\n\n  on(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach((event) => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  }\n\n  once(events, handler, priority) {\n    const self = this;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      self.off(events, onceHandler);\n      if (onceHandler.f7proxy) {\n        delete onceHandler.f7proxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.f7proxy = handler;\n    return self.on(events, onceHandler, priority);\n  }\n\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach((event) => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  }\n\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach((event) => {\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        const handlers = [];\n        self.eventsListeners[event].forEach((eventHandler) => {\n          handlers.push(eventHandler);\n        });\n        handlers.forEach((eventHandler) => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n\n  useModulesParams(instanceParams) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      // Extend params\n      if (module.params) {\n        Utils.extend(instanceParams, module.params);\n      }\n    });\n  }\n\n  useModules(modulesParams = {}) {\n    const instance = this;\n    if (!instance.modules) return;\n    Object.keys(instance.modules).forEach((moduleName) => {\n      const module = instance.modules[moduleName];\n      const moduleParams = modulesParams[moduleName] || {};\n      // Extend instance methods and props\n      if (module.instance) {\n        Object.keys(module.instance).forEach((modulePropName) => {\n          const moduleProp = module.instance[modulePropName];\n          if (typeof moduleProp === 'function') {\n            instance[modulePropName] = moduleProp.bind(instance);\n          } else {\n            instance[modulePropName] = moduleProp;\n          }\n        });\n      }\n      // Add event listeners\n      if (module.on && instance.on) {\n        Object.keys(module.on).forEach((moduleEventName) => {\n          instance.on(moduleEventName, module.on[moduleEventName]);\n        });\n      }\n\n      // Module create callback\n      if (module.create) {\n        module.create.bind(instance)(moduleParams);\n      }\n    });\n  }\n\n  static set components(components) {\n    const Class = this;\n    if (!Class.use) return;\n    Class.use(components);\n  }\n\n  static installModule(module, ...params) {\n    const Class = this;\n    if (!Class.prototype.modules) Class.prototype.modules = {};\n    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);\n    Class.prototype.modules[name] = module;\n    // Prototype\n    if (module.proto) {\n      Object.keys(module.proto).forEach((key) => {\n        Class.prototype[key] = module.proto[key];\n      });\n    }\n    // Class\n    if (module.static) {\n      Object.keys(module.static).forEach((key) => {\n        Class[key] = module.static[key];\n      });\n    }\n    // Callback\n    if (module.install) {\n      module.install.apply(Class, params);\n    }\n    return Class;\n  }\n\n  static use(module, ...params) {\n    const Class = this;\n    if (Array.isArray(module)) {\n      module.forEach((m) => Class.installModule(m));\n      return Class;\n    }\n    return Class.installModule(module, ...params);\n  }\n}\n\nfunction updateSize () {\n  const swiper = this;\n  let width;\n  let height;\n  const $el = swiper.$el;\n  if (typeof swiper.params.width !== 'undefined') {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined') {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);\n  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);\n\n  Utils.extend(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n}\n\nfunction updateSlides () {\n  const swiper = this;\n  const params = swiper.params;\n\n  const {\n    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n\n  function slidesForMargin(slideIndex) {\n    if (!params.cssMode) return true;\n    if (slideIndex === slides.length - 1) {\n      return false;\n    }\n    return true;\n  }\n\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.snapGrid.length;\n\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  if (rtl) slides.css({ marginLeft: '', marginTop: '' });\n  else slides.css({ marginRight: '', marginBottom: '' });\n\n  let slidesNumberEvenToRows;\n  if (params.slidesPerColumn > 1) {\n    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\n    }\n    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\n    }\n  }\n\n  // Calc slides\n  let slideSize;\n  const slidesPerColumn = params.slidesPerColumn;\n  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\n  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n    if (params.slidesPerColumn > 1) {\n      // Set slides order\n      let newSlideOrderIndex;\n      let column;\n      let row;\n      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {\n        const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));\n        const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;\n        const columnsInGroup = groupIndex === 0\n          ? params.slidesPerGroup\n          : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\n        column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;\n\n        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);\n        slide\n          .css({\n            '-webkit-box-ordinal-group': newSlideOrderIndex,\n            '-moz-box-ordinal-group': newSlideOrderIndex,\n            '-ms-flex-order': newSlideOrderIndex,\n            '-webkit-order': newSlideOrderIndex,\n            order: newSlideOrderIndex,\n          });\n      } else if (params.slidesPerColumnFill === 'column') {\n        column = Math.floor(i / slidesPerColumn);\n        row = i - (column * slidesPerColumn);\n        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {\n          row += 1;\n          if (row >= slidesPerColumn) {\n            row = 0;\n            column += 1;\n          }\n        }\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - (row * slidesPerRow);\n      }\n      slide.css(\n        `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,\n        (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)\n      );\n    }\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      const slideStyles = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].getComputedStyle(slide[0], null);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal()\n          ? slide.outerWidth(true)\n          : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        if (swiper.isHorizontal()) {\n          const width = parseFloat(slideStyles.getPropertyValue('width'));\n          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));\n          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));\n          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));\n          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;\n          }\n        } else {\n          const height = parseFloat(slideStyles.getPropertyValue('height'));\n          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));\n          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));\n          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));\n          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = height + marginTop + marginBottom;\n          } else {\n            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;\n          }\n        }\n      }\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        if (swiper.isHorizontal()) {\n          slides[i].style.width = `${slideSize}px`;\n        } else {\n          slides[i].style.height = `${slideSize}px`;\n        }\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  let newSlidesGrid;\n\n  if (\n    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n  if (params.setWrapperSize) {\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n  }\n\n  if (params.slidesPerColumn > 1) {\n    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\n    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });\n    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });\n    if (params.centeredSlides) {\n      newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid = newSlidesGrid;\n    }\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    if (swiper.isHorizontal()) {\n      if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });\n      else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });\n    } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map((snap) => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach((slideSizeValue) => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Utils.extend(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid,\n  });\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateSlidesOffset();\n  }\n}\n\nfunction updateAutoHeight (speed) {\n  const swiper = this;\n  const activeSlides = [];\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      swiper.visibleSlides.each((index, slide) => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length) break;\n        activeSlides.push(swiper.slides.eq(index)[0]);\n      }\n    }\n  } else {\n    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);\n}\n\nfunction updateSlidesOffset () {\n  const swiper = this;\n  const slides = swiper.slides;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n}\n\nfunction updateSlidesProgress (translate = (this && this.translate) || 0) {\n  const swiper = this;\n  const params = swiper.params;\n\n  const { slides, rtlTranslate: rtl } = swiper;\n\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.removeClass(params.slideVisibleClass);\n\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    const slideProgress = (\n      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset\n    ) / (slide.swiperSlideSize + params.spaceBetween);\n    if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {\n      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)\n                || (slideAfter > 1 && slideAfter <= swiper.size)\n                || (slideBefore <= 0 && slideAfter >= swiper.size);\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n  }\n  swiper.visibleSlides = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.visibleSlides);\n}\n\nfunction updateProgress (translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let { progress, isBeginning, isEnd } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / (translatesDiff);\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Utils.extend(swiper, {\n    progress,\n    isBeginning,\n    isEnd,\n  });\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n}\n\nfunction updateSlidesClasses () {\n  const swiper = this;\n\n  const {\n    slides, params, $wrapperEl, activeIndex, realIndex,\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n\n  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);\n\n  let activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n\n  // Active classes\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`)\n        .addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  // Next Slide\n  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  // Prev Slide\n  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl\n        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr('data-swiper-slide-index')}\"]`)\n        .addClass(params.slideDuplicatePrevClass);\n    }\n  }\n}\n\nfunction updateActiveIndex (newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  if (typeof activeIndex === 'undefined') {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n\n  // Get real index\n  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n\n  Utils.extend(swiper, {\n    snapIndex,\n    realIndex,\n    previousIndex,\n    activeIndex,\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n\nfunction updateClickedSlide (e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).closest(`.${params.slideClass}`)[0];\n  let slideFound = false;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) slideFound = true;\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slide).index();\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide,\n};\n\nfunction getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n\n  const {\n    params, rtlTranslate: rtl, translate, $wrapperEl,\n  } = swiper;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n\n  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);\n  if (rtl) currentTranslate = -currentTranslate;\n\n  return currentTranslate || 0;\n}\n\nfunction setTranslate (translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress,\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate () {\n  return (-this.snapGrid[0]);\n}\n\nfunction maxTranslate () {\n  return (-this.snapGrid[this.snapGrid.length - 1]);\n}\n\nfunction translateTo (translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {\n  const swiper = this;\n\n  const {\n    params,\n    wrapperEl,\n  } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n  else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -newTranslate,\n          behavior: 'smooth',\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n      }\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\nvar translate = {\n  getTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo,\n};\n\nfunction setTransition (duration, byController) {\n  const swiper = this;\n\n  if (!swiper.params.cssMode) {\n    swiper.$wrapperEl.transition(duration);\n  }\n\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionStart (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, params, previousIndex } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionStart');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionStart');\n      return;\n    }\n    swiper.emit('slideChangeTransitionStart');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionStart');\n    } else {\n      swiper.emit('slidePrevTransitionStart');\n    }\n  }\n}\n\nfunction transitionEnd (runCallbacks = true, direction) {\n  const swiper = this;\n  const { activeIndex, previousIndex, params } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';\n    else if (activeIndex < previousIndex) dir = 'prev';\n    else dir = 'reset';\n  }\n\n  swiper.emit('transitionEnd');\n\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit('slideResetTransitionEnd');\n      return;\n    }\n    swiper.emit('slideChangeTransitionEnd');\n    if (dir === 'next') {\n      swiper.emit('slideNextTransitionEnd');\n    } else {\n      swiper.emit('slidePrevTransitionEnd');\n    }\n  }\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd,\n};\n\nfunction slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  const translate = -snapGrid[snapIndex];\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    let t = -translate;\n    if (rtl) {\n      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;\n    }\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: t,\n          behavior: 'smooth',\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n\nfunction slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    newIndex += swiper.loopedSlides;\n  }\n\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const { params, animating } = swiper;\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params, animating, snapGrid, slidesGrid, rtlTranslate,\n  } = swiper;\n\n  if (params.loop) {\n    if (animating) return false;\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n  const normalizedSlidesGrid = slidesGrid.map((val) => normalize(val));\n\n  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    snapGrid.forEach((snap) => {\n      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;\n    });\n  }\n  let prevIndex;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset (speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest (speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if ((translate - prevSnap) <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))\n        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))\n      ) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n          .eq(0)\n          .index();\n\n        Utils.nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl\n        .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n        .eq(0)\n        .index();\n\n      Utils.nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide,\n};\n\nfunction loopCreate () {\n  const swiper = this;\n  const { params, $wrapperEl } = swiper;\n  // Remove duplicated slides\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n\n  let slides = $wrapperEl.children(`.${params.slideClass}`);\n\n  if (params.loopFillGroupWithBlank) {\n    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (let i = 0; i < blankSlidesNum; i += 1) {\n        const blankNode = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n        $wrapperEl.append(blankNode);\n      }\n      slides = $wrapperEl.children(`.${params.slideClass}`);\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n\n  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  const prependSlides = [];\n  const appendSlides = [];\n  slides.each((index, el) => {\n    const slide = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(el);\n    if (index < swiper.loopedSlides) appendSlides.push(el);\n    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);\n    slide.attr('data-swiper-slide-index', index);\n  });\n  for (let i = 0; i < appendSlides.length; i += 1) {\n    $wrapperEl.append(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n    $wrapperEl.prepend(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n}\n\nfunction loopFix () {\n  const swiper = this;\n\n  swiper.emit('beforeLoopFix');\n\n  const {\n    activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,\n  } = swiper;\n  let newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n\n  const snapTranslate = -snapGrid[activeIndex];\n  const diff = snapTranslate - swiper.getTranslate();\n\n  // Fix For Negative Oversliding\n  if (activeIndex < loopedSlides) {\n    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  } else if (activeIndex >= slides.length - loopedSlides) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n    if (slideChanged && diff !== 0) {\n      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  swiper.emit('loopFix');\n}\n\nfunction loopDestroy () {\n  const swiper = this;\n  const { $wrapperEl, params, slides } = swiper;\n  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();\n  slides.removeAttr('data-swiper-slide-index');\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy,\n};\n\nfunction setGrabCursor (moving) {\n  const swiper = this;\n  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;\n  const el = swiper.el;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n}\n\nfunction unsetGrabCursor () {\n  const swiper = this;\n  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;\n  swiper.el.style.cursor = '';\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor,\n};\n\nfunction appendSlide (slides) {\n  const swiper = this;\n  const { $wrapperEl, params } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n}\n\nfunction prependSlide (slides) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.prepend(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\nfunction addSlide (index, slides) {\n  const swiper = this;\n  const { $wrapperEl, params, activeIndex } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides.eq(i);\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) $wrapperEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    $wrapperEl.append(slides);\n  }\n\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    $wrapperEl.append(slidesBuffer[i]);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeSlide (slidesIndexes) {\n  const swiper = this;\n  const { params, $wrapperEl, activeIndex } = swiper;\n\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeAllSlides () {\n  const swiper = this;\n\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n\nvar manipulation = {\n  appendSlide,\n  prependSlide,\n  addSlide,\n  removeSlide,\n  removeAllSlides,\n};\n\nconst Device = (function Device() {\n  const platform = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.platform;\n  const ua = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent;\n\n  const device = {\n    ios: false,\n    android: false,\n    androidChrome: false,\n    desktop: false,\n    iphone: false,\n    ipod: false,\n    ipad: false,\n    edge: false,\n    ie: false,\n    firefox: false,\n    macos: false,\n    windows: false,\n    cordova: !!(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].cordova || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].phonegap),\n    phonegap: !!(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].cordova || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].phonegap),\n    electron: false,\n  };\n\n  const screenWidth = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].screen.width;\n  const screenHeight = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].screen.height;\n\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n  const edge = ua.indexOf('Edge/') >= 0;\n  const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;\n  const windows = platform === 'Win32';\n  const electron = ua.toLowerCase().indexOf('electron') >= 0;\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  if (!ipad\n    && macos\n    && Support.touch\n    && (\n      (screenWidth === 1024 && screenHeight === 1366) // Pro 12.9\n      || (screenWidth === 834 && screenHeight === 1194) // Pro 11\n      || (screenWidth === 834 && screenHeight === 1112) // Pro 10.5\n      || (screenWidth === 768 && screenHeight === 1024) // other\n    )\n  ) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    macos = false;\n  }\n\n  device.ie = ie;\n  device.edge = edge;\n  device.firefox = firefox;\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.osVersion = android[2];\n    device.android = true;\n    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n  // iOS\n  if (iphone && !ipod) {\n    device.osVersion = iphone[2].replace(/_/g, '.');\n    device.iphone = true;\n  }\n  if (ipad) {\n    device.osVersion = ipad[2].replace(/_/g, '.');\n    device.ipad = true;\n  }\n  if (ipod) {\n    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    device.ipod = true;\n  }\n  // iOS 8+ changed UA\n  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {\n    if (device.osVersion.split('.')[0] === '10') {\n      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];\n    }\n  }\n\n  // Webview\n  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.standalone))\n    || (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].matchMedia && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].matchMedia('(display-mode: standalone)').matches);\n  device.webview = device.webView;\n  device.standalone = device.webView;\n\n  // Desktop\n  device.desktop = !(device.ios || device.android) || electron;\n  if (device.desktop) {\n    device.electron = electron;\n    device.macos = macos;\n    device.windows = windows;\n    if (device.macos) {\n      device.os = 'macos';\n    }\n    if (device.windows) {\n      device.os = 'windows';\n    }\n  }\n\n  // Pixel Ratio\n  device.pixelRatio = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].devicePixelRatio || 1;\n\n  // Export object\n  return device;\n}());\n\nfunction onTouchStart (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  const $targetEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target);\n\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!$targetEl.closest(swiper.wrapperEl).length) return;\n  }\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!$targetEl.closest(params.swipeHandler)[0]) return;\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (\n    edgeSwipeDetection\n    && ((startX <= edgeSwipeThreshold)\n    || (startX >= ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].screen.width - edgeSwipeThreshold))\n  ) {\n    return;\n  }\n\n  Utils.extend(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = Utils.now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  if (e.type !== 'touchstart') {\n    let preventDefault = true;\n    if ($targetEl.is(data.formElements)) preventDefault = false;\n    if (\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement\n      && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement).is(data.formElements)\n      && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement !== $targetEl[0]\n    ) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.blur();\n    }\n\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if (params.touchStartForcePreventDefault || shouldPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const { params, touches, rtlTranslate: rtl } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  if (data.isTouchEvent && e.type !== 'touchmove') return;\n  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\n  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    // isMoved = true;\n    swiper.allowClick = false;\n    if (data.isTouched) {\n      Utils.extend(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = Utils.now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())\n        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())\n      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement) {\n    if (e.target === ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is(data.formElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;\n\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if ((diffX * diffX) + (diffY * diffY) >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) diff = -diff;\n\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode) {\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: Utils.now(),\n    });\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const {\n    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {\n    const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize () {\n  const swiper = this;\n\n  const { params, el } = swiper;\n\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  swiper.updateSlidesClasses();\n  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    swiper.slideTo(swiper.activeIndex, 0, false, true);\n  }\n\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    swiper.autoplay.run();\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick (e) {\n  const swiper = this;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction onScroll () {\n  const swiper = this;\n  const { wrapperEl, rtlTranslate } = swiper;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    if (rtlTranslate) {\n      swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);\n    } else {\n      swiper.translate = -wrapperEl.scrollLeft;\n    }\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === -0) swiper.translate = 0;\n\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n\nlet dummyEventAttached = false;\nfunction dummyEventListener() {}\n\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n\n  const capture = !!params.nested;\n\n  // Touch Events\n  if (!Support.touch && Support.pointerEvents) {\n    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);\n    ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEvents.move, swiper.onTouchMove, capture);\n    ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    if (Support.touch) {\n      const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n      el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);\n      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      if (touchEvents.cancel) {\n        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n      }\n      if (!dummyEventAttached) {\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener('touchstart', dummyEventListener);\n        dummyEventAttached = true;\n      }\n    }\n    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n      el.addEventListener('mousedown', swiper.onTouchStart, false);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener('mousemove', swiper.onTouchMove, capture);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener('mouseup', swiper.onTouchEnd, false);\n    }\n  }\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el.addEventListener('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl.addEventListener('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);\n  } else {\n    swiper.on('observerUpdate', onResize, true);\n  }\n}\n\nfunction detachEvents() {\n  const swiper = this;\n\n  const {\n    params, touchEvents, el, wrapperEl,\n  } = swiper;\n\n  const capture = !!params.nested;\n\n  // Touch Events\n  if (!Support.touch && Support.pointerEvents) {\n    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\n    ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n    ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\n  } else {\n    if (Support.touch) {\n      const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      if (touchEvents.cancel) {\n        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n      }\n    }\n    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n      el.removeEventListener('mousedown', swiper.onTouchStart, false);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener('mousemove', swiper.onTouchMove, capture);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener('mouseup', swiper.onTouchEnd, false);\n    }\n  }\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el.removeEventListener('click', swiper.onClick, true);\n  }\n\n  if (params.cssMode) {\n    wrapperEl.removeEventListener('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);\n}\n\nvar events = {\n  attachEvents,\n  detachEvents,\n};\n\nfunction setBreakpoint () {\n  const swiper = this;\n  const {\n    activeIndex, initialized, loopedSlides = 0, params, $el,\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints);\n\n  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    if (breakpointOnlyParams) {\n      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach((param) => {\n        const paramValue = breakpointOnlyParams[param];\n        if (typeof paramValue === 'undefined') return;\n        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {\n          breakpointOnlyParams[param] = 'auto';\n        } else if (param === 'slidesPerView') {\n          breakpointOnlyParams[param] = parseFloat(paramValue);\n        } else {\n          breakpointOnlyParams[param] = parseInt(paramValue, 10);\n        }\n      });\n    }\n\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = params.slidesPerColumn > 1;\n    const isMultiRow = breakpointParams.slidesPerColumn > 1;\n    if (wasMultiRow && !isMultiRow) {\n      $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);\n    } else if (!wasMultiRow && isMultiRow) {\n      $el.addClass(`${params.containerModifierClass}multirow`);\n      if (breakpointParams.slidesPerColumnFill === 'column') {\n        $el.addClass(`${params.containerModifierClass}multirow-column`);\n      }\n    }\n\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n\n    Utils.extend(swiper.params, breakpointParams);\n\n    Utils.extend(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n    });\n\n    swiper.currentBreakpoint = breakpoint;\n\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate();\n      swiper.updateSlides();\n      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);\n    }\n\n    swiper.emit('breakpoint', breakpointParams);\n  }\n}\n\nfunction getBreakpoint (breakpoints) {\n  // Get breakpoint for window width\n  if (!breakpoints) return undefined;\n  let breakpoint = false;\n\n  const points = Object.keys(breakpoints).map((point) => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerHeight * minRatio;\n      return { value, point };\n    }\n    return { value: point, point };\n  });\n\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const { point, value } = points[i];\n    if (value <= ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = { setBreakpoint, getBreakpoint };\n\nfunction addClasses () {\n  const swiper = this;\n  const {\n    classNames, params, rtl, $el,\n  } = swiper;\n  const suffixes = [];\n\n  suffixes.push('initialized');\n  suffixes.push(params.direction);\n\n  if (params.freeMode) {\n    suffixes.push('free-mode');\n  }\n  if (params.autoHeight) {\n    suffixes.push('autoheight');\n  }\n  if (rtl) {\n    suffixes.push('rtl');\n  }\n  if (params.slidesPerColumn > 1) {\n    suffixes.push('multirow');\n    if (params.slidesPerColumnFill === 'column') {\n      suffixes.push('multirow-column');\n    }\n  }\n  if (Device.android) {\n    suffixes.push('android');\n  }\n  if (Device.ios) {\n    suffixes.push('ios');\n  }\n\n  if (params.cssMode) {\n    suffixes.push('css-mode');\n  }\n\n  suffixes.forEach((suffix) => {\n    classNames.push(params.containerModifierClass + suffix);\n  });\n\n  $el.addClass(classNames.join(' '));\n}\n\nfunction removeClasses () {\n  const swiper = this;\n  const { $el, classNames } = swiper;\n\n  $el.removeClass(classNames.join(' '));\n}\n\nvar classes = { addClasses, removeClasses };\n\nfunction loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {\n  let image;\n  function onReady() {\n    if (callback) callback();\n  }\n  const isPicture = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(imageEl).parent('picture')[0];\n\n  if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n    if (src) {\n      image = new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n}\n\nfunction preloadImages () {\n  const swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) swiper.update();\n      swiper.emit('imagesReady');\n    }\n  }\n  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    const imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(\n      imageEl,\n      imageEl.currentSrc || imageEl.getAttribute('src'),\n      imageEl.srcset || imageEl.getAttribute('srcset'),\n      imageEl.sizes || imageEl.getAttribute('sizes'),\n      true,\n      onReady\n    );\n  }\n}\n\nvar images = {\n  loadImage,\n  preloadImages,\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const params = swiper.params;\n  const wasLocked = swiper.isLocked;\n  const lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);\n\n  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {\n    swiper.isLocked = lastSlidePosition <= swiper.size;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n\n  swiper.allowSlideNext = !swiper.isLocked;\n  swiper.allowSlidePrev = !swiper.isLocked;\n\n  // events\n  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n    if (swiper.navigation) swiper.navigation.update();\n  }\n}\n\nvar checkOverflow$1 = { checkOverflow };\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'container',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  //\n  preventInteractionOnTransition: false,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n\n  // Free mode\n  freeMode: false,\n  freeModeMomentum: true,\n  freeModeMomentumRatio: 1,\n  freeModeMomentumBounce: true,\n  freeModeMomentumBounceRatio: 1,\n  freeModeMomentumVelocityRatio: 1,\n  freeModeSticky: false,\n  freeModeMinimumVelocity: 0.02,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerColumn: 1,\n  slidesPerColumnFill: 'column',\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: false,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n  watchSlidesVisibility: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopFillGroupWithBlank: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  // NS\n  containerModifierClass: 'swiper-container-', // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n\n  // Callbacks\n  runCallbacksOnInit: true,\n};\n\n/* eslint no-param-reassign: \"off\" */\n\nconst prototypes = {\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  manipulation,\n  events,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes,\n  images,\n};\n\nconst extendedDefaults = {};\n\nclass Swiper extends SwiperClass {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n\n    params = Utils.extend({}, params);\n    if (el && !params.el) params.el = el;\n\n    super(params);\n\n    Object.keys(prototypes).forEach((prototypeGroup) => {\n      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n        if (!Swiper.prototype[protoMethod]) {\n          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        }\n      });\n    });\n\n    // Swiper Instance\n    const swiper = this;\n    if (typeof swiper.modules === 'undefined') {\n      swiper.modules = {};\n    }\n    Object.keys(swiper.modules).forEach((moduleName) => {\n      const module = swiper.modules[moduleName];\n      if (module.params) {\n        const moduleParamName = Object.keys(module.params)[0];\n        const moduleParams = module.params[moduleParamName];\n        if (typeof moduleParams !== 'object' || moduleParams === null) return;\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = { enabled: true };\n        }\n        if (\n          typeof params[moduleParamName] === 'object'\n          && !('enabled' in params[moduleParamName])\n        ) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };\n      }\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = Utils.extend({}, defaults);\n    swiper.useModulesParams(swiperParams);\n\n    // Extend defaults with passed params\n    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = Utils.extend({}, swiper.params);\n    swiper.passedParams = Utils.extend({}, params);\n\n    // Save Dom lib\n    swiper.$ = dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"];\n\n    // Find el\n    const $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return undefined;\n    }\n\n    if ($el.length > 1) {\n      const swipers = [];\n      $el.each((index, containerEl) => {\n        const newParams = Utils.extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n\n    el.swiper = swiper;\n    $el.data('swiper', swiper);\n\n    // Find Wrapper\n    let $wrapperEl;\n    if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n      $wrapperEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));\n      // Children needs to return slot items\n      $wrapperEl.children = (options) => $el.children(options);\n    } else {\n      $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);\n    }\n    // Extend Swiper\n    Utils.extend(swiper, {\n      $el,\n      el,\n      $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // RTL\n      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEvents: (function touchEvents() {\n        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n        let desktop = ['mousedown', 'mousemove', 'mouseup'];\n        if (Support.pointerEvents) {\n          desktop = ['pointerdown', 'pointermove', 'pointerup'];\n        }\n        swiper.touchEventsTouch = {\n          start: touch[0],\n          move: touch[1],\n          end: touch[2],\n          cancel: touch[3],\n        };\n        swiper.touchEventsDesktop = {\n          start: desktop[0],\n          move: desktop[1],\n          end: desktop[2],\n        };\n        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\n      }()),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        formElements: 'input, select, option, textarea, button, video, label',\n        // Last click time\n        lastClickTime: Utils.now(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined,\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n\n    });\n\n    // Install Modules\n    swiper.useModules();\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    return swiper;\n  }\n\n  slidesPerViewDynamic() {\n    const swiper = this;\n    const {\n      params, slides, slidesGrid, size: swiperSize, activeIndex,\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex].swiperSlideSize;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {\n          spv += 1;\n        }\n      }\n    }\n    return spv;\n  }\n\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const { snapGrid, params } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (swiper.params.freeMode) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {\n      return swiper;\n    }\n\n    swiper.$el\n      .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)\n      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n\n    swiper.params.direction = newDirection;\n\n    swiper.slides.each((slideIndex, slideEl) => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n\n    return swiper;\n  }\n\n  init() {\n    const swiper = this;\n    if (swiper.initialized) return;\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    // Init Flag\n    swiper.initialized = true;\n\n    // Emit\n    swiper.emit('init');\n  }\n\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params, $el, $wrapperEl, slides,\n    } = swiper;\n\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n      if (slides && slides.length) {\n        slides\n          .removeClass([\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass,\n          ].join(' '))\n          .removeAttr('style')\n          .removeAttr('data-swiper-slide-index');\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach((eventName) => {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      swiper.$el.data('swiper', null);\n      Utils.deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n\n    return null;\n  }\n\n  static extendDefaults(newDefaults) {\n    Utils.extend(extendedDefaults, newDefaults);\n  }\n\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n\n  static get defaults() {\n    return defaults;\n  }\n\n  static get Class() {\n    return SwiperClass;\n  }\n\n  static get $() {\n    return dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"];\n  }\n}\n\nvar Device$1 = {\n  name: 'device',\n  proto: {\n    device: Device,\n  },\n  static: {\n    device: Device,\n  },\n};\n\nvar Support$1 = {\n  name: 'support',\n  proto: {\n    support: Support,\n  },\n  static: {\n    support: Support,\n  },\n};\n\nconst Browser = (function Browser() {\n  function isSafari() {\n    const ua = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.toLowerCase();\n    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);\n  }\n  return {\n    isEdge: !!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.match(/Edge/g),\n    isSafari: isSafari(),\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent),\n  };\n}());\n\nvar Browser$1 = {\n  name: 'browser',\n  proto: {\n    browser: Browser,\n  },\n  static: {\n    browser: Browser,\n  },\n};\n\nvar Resize = {\n  name: 'resize',\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      resize: {\n        resizeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('beforeResize');\n          swiper.emit('resize');\n        },\n        orientationChangeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) return;\n          swiper.emit('orientationchange');\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      // Emit resize\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('resize', swiper.resize.resizeHandler);\n\n      // Emit orientationchange\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n    destroy() {\n      const swiper = this;\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('resize', swiper.resize.resizeHandler);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n  },\n};\n\nconst Observer = {\n  func: ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].MutationObserver || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].WebkitMutationObserver,\n  attach(target, options = {}) {\n    const swiper = this;\n\n    const ObserverFunc = Observer.func;\n    const observer = new ObserverFunc((mutations) => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (mutations.length === 1) {\n        swiper.emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        swiper.emit('observerUpdate', mutations[0]);\n      };\n\n      if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].requestAnimationFrame) {\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].requestAnimationFrame(observerUpdate);\n      } else {\n        ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].setTimeout(observerUpdate, 0);\n      }\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    swiper.observer.observers.push(observer);\n  },\n  init() {\n    const swiper = this;\n    if (!Support.observer || !swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = swiper.$el.parents();\n      for (let i = 0; i < containerParents.length; i += 1) {\n        swiper.observer.attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });\n\n    // Observe wrapper\n    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });\n  },\n  destroy() {\n    const swiper = this;\n    swiper.observer.observers.forEach((observer) => {\n      observer.disconnect();\n    });\n    swiper.observer.observers = [];\n  },\n};\n\nvar Observer$1 = {\n  name: 'observer',\n  params: {\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false,\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      observer: {\n        init: Observer.init.bind(swiper),\n        attach: Observer.attach.bind(swiper),\n        destroy: Observer.destroy.bind(swiper),\n        observers: [],\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.observer.init();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.observer.destroy();\n    },\n  },\n};\n\nconst Virtual = {\n  update(force) {\n    const swiper = this;\n    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;\n    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      renderSlide,\n      offset: previousOffset,\n    } = swiper.virtual;\n    swiper.updateActiveIndex();\n    const activeIndex = swiper.activeIndex || 0;\n\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';\n    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;\n      slidesBefore = slidesPerGroup + addSlidesAfter;\n    }\n    const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\n    Utils.extend(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      if (swiper.lazy && swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.css(offsetProp, `${offset}px`);\n      }\n      swiper.updateProgress();\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: (function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()),\n      });\n      onRendered();\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    if (force) {\n      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`).remove();\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      if (i >= from && i <= to) {\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(i);\n        } else {\n          if (i > previousTo) appendIndexes.push(i);\n          if (i < previousFrom) prependIndexes.push(i);\n        }\n      }\n    }\n    appendIndexes.forEach((index) => {\n      swiper.$wrapperEl.append(renderSlide(slides[index], index));\n    });\n    prependIndexes.sort((a, b) => b - a).forEach((index) => {\n      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n    });\n    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n    onRendered();\n  },\n  renderSlide(slide, index) {\n    const swiper = this;\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    const $slideEl = params.renderSlide\n      ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.renderSlide.call(swiper, slide, index))\n      : Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`);\n    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n    if (params.cache) swiper.virtual.cache[index] = $slideEl;\n    return $slideEl;\n  },\n  appendSlide(slides) {\n    const swiper = this;\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    swiper.virtual.update(true);\n  },\n  prependSlide(slides) {\n    const swiper = this;\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach((cachedIndex) => {\n        const $cachedEl = cache[cachedIndex];\n        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');\n        if (cachedElIndex) {\n          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  },\n  removeSlide(slidesIndexes) {\n    const swiper = this;\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n        }\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n      }\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(activeIndex, 0);\n  },\n  removeAllSlides() {\n    const swiper = this;\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    swiper.virtual.update(true);\n    swiper.slideTo(0, 0);\n  },\n};\n\nvar Virtual$1 = {\n  name: 'virtual',\n  params: {\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      virtual: {\n        update: Virtual.update.bind(swiper),\n        appendSlide: Virtual.appendSlide.bind(swiper),\n        prependSlide: Virtual.prependSlide.bind(swiper),\n        removeSlide: Virtual.removeSlide.bind(swiper),\n        removeAllSlides: Virtual.removeAllSlides.bind(swiper),\n        renderSlide: Virtual.renderSlide.bind(swiper),\n        slides: swiper.params.virtual.slides,\n        cache: {},\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      const overwriteParams = {\n        watchSlidesProgress: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n\n      if (!swiper.params.initialSlide) {\n        swiper.virtual.update();\n      }\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.virtual.enabled) return;\n      swiper.virtual.update();\n    },\n  },\n};\n\nconst Keyboard = {\n  handle(event) {\n    const swiper = this;\n    const { rtlTranslate: rtl } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName && (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName.toLowerCase() === 'input' || ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].activeElement.nodeName.toLowerCase() === 'textarea')) {\n      return undefined;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {\n        return undefined;\n      }\n      const windowWidth = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerWidth;\n      const windowHeight = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].innerHeight;\n      const swiperOffset = swiper.$el.offset();\n      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiper.width, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiper.height],\n        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n      ];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (\n          point[0] >= 0 && point[0] <= windowWidth\n          && point[1] >= 0 && point[1] <= windowHeight\n        ) {\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) swiper.slideNext();\n      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();\n        else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext();\n      if (isPageUp || isArrowUp) swiper.slidePrev();\n    }\n    swiper.emit('keyPress', kc);\n    return undefined;\n  },\n  enable() {\n    const swiper = this;\n    if (swiper.keyboard.enabled) return;\n    Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"]).on('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = true;\n  },\n  disable() {\n    const swiper = this;\n    if (!swiper.keyboard.enabled) return;\n    Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"]).off('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = false;\n  },\n};\n\nvar Keyboard$1 = {\n  name: 'keyboard',\n  params: {\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      keyboard: {\n        enabled: false,\n        enable: Keyboard.enable.bind(swiper),\n        disable: Keyboard.disable.bind(swiper),\n        handle: Keyboard.handle.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.keyboard.enabled) {\n        swiper.keyboard.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.keyboard.enabled) {\n        swiper.keyboard.disable();\n      }\n    },\n  },\n};\n\nfunction isEventSupported() {\n  const eventName = 'onwheel';\n  let isSupported = eventName in ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"];\n\n  if (!isSupported) {\n    const element = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature('', '') !== true\n  ) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\nconst Mousewheel = {\n  lastScrollTime: Utils.now(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event() {\n    if (ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) { // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else { // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = (pX < 1) ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = (pY < 1) ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  },\n  handleMouseEnter() {\n    const swiper = this;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave() {\n    const swiper = this;\n    swiper.mouseEntered = false;\n  },\n  handle(event) {\n    let e = event;\n    const swiper = this;\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.mousewheel.eventsTarged);\n    }\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\n    const data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n        else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n      else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n\n    if (params.invert) delta = -delta;\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: Utils.now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event,\n      };\n\n      // Keep the most recent events\n      const recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };\n      const { lastEventBeforeSnap } = swiper.mousewheel;\n      const ignoreWheelEvents = lastEventBeforeSnap\n        && newEvent.time < lastEventBeforeSnap.time + 500\n        && newEvent.delta <= lastEventBeforeSnap.delta\n        && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n        let position = swiper.getTranslate() + (delta * params.sensitivity);\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momuntum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          const recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15\n              && newEvent.time - firstEvent.time < 500\n              && firstEvent.delta - newEvent.delta >= 1\n              && newEvent.delta <= 6\n          ) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            swiper.mousewheel.timeout = Utils.nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = Utils.nextTick(() => {\n              const snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) swiper.emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    return false;\n  },\n  animateSlider(newEvent) {\n    const swiper = this;\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    swiper.mousewheel.lastScrollTime = (new ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].Date()).getTime();\n    // Return false as a default\n    return false;\n  },\n  releaseScroll(newEvent) {\n    const swiper = this;\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  },\n  enable() {\n    const swiper = this;\n    const event = Mousewheel.event();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.mousewheel.eventsTarged);\n    }\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable() {\n    const swiper = this;\n    const event = Mousewheel.event();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    let target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(swiper.params.mousewheel.eventsTarged);\n    }\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  },\n};\n\nvar Mousewheel$1 = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarged: 'container',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      mousewheel: {\n        enabled: false,\n        enable: Mousewheel.enable.bind(swiper),\n        disable: Mousewheel.disable.bind(swiper),\n        handle: Mousewheel.handle.bind(swiper),\n        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),\n        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),\n        animateSlider: Mousewheel.animateSlider.bind(swiper),\n        releaseScroll: Mousewheel.releaseScroll.bind(swiper),\n        lastScrollTime: Utils.now(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    },\n  },\n};\n\nconst Navigation = {\n  update() {\n    // Update Navigation Buttons\n    const swiper = this;\n    const params = swiper.params.navigation;\n\n    if (swiper.params.loop) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        $prevEl.addClass(params.disabledClass);\n      } else {\n        $prevEl.removeClass(params.disabledClass);\n      }\n      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        $nextEl.addClass(params.disabledClass);\n      } else {\n        $nextEl.removeClass(params.disabledClass);\n      }\n      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n    }\n  },\n  onPrevClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop) return;\n    swiper.slidePrev();\n  },\n  onNextClick(e) {\n    const swiper = this;\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop) return;\n    swiper.slideNext();\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.navigation;\n    if (!(params.nextEl || params.prevEl)) return;\n\n    let $nextEl;\n    let $prevEl;\n    if (params.nextEl) {\n      $nextEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.nextEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.nextEl === 'string'\n        && $nextEl.length > 1\n        && swiper.$el.find(params.nextEl).length === 1\n      ) {\n        $nextEl = swiper.$el.find(params.nextEl);\n      }\n    }\n    if (params.prevEl) {\n      $prevEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.prevEl);\n      if (\n        swiper.params.uniqueNavElements\n        && typeof params.prevEl === 'string'\n        && $prevEl.length > 1\n        && swiper.$el.find(params.prevEl).length === 1\n      ) {\n        $prevEl = swiper.$el.find(params.prevEl);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', swiper.navigation.onNextClick);\n    }\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', swiper.navigation.onPrevClick);\n    }\n\n    Utils.extend(swiper.navigation, {\n      $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl,\n      prevEl: $prevEl && $prevEl[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const { $nextEl, $prevEl } = swiper.navigation;\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click', swiper.navigation.onNextClick);\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click', swiper.navigation.onPrevClick);\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  },\n};\n\nvar Navigation$1 = {\n  name: 'navigation',\n  params: {\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      navigation: {\n        init: Navigation.init.bind(swiper),\n        update: Navigation.update.bind(swiper),\n        destroy: Navigation.destroy.bind(swiper),\n        onNextClick: Navigation.onNextClick.bind(swiper),\n        onPrevClick: Navigation.onPrevClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.navigation.init();\n      swiper.navigation.update();\n    },\n    toEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    fromEdge() {\n      const swiper = this;\n      swiper.navigation.update();\n    },\n    destroy() {\n      const swiper = this;\n      swiper.navigation.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      const { $nextEl, $prevEl } = swiper.navigation;\n      if (\n        swiper.params.navigation.hideOnClick\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is($prevEl)\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).is($nextEl)\n      ) {\n        let isHidden;\n        if ($nextEl) {\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n        } else if ($prevEl) {\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n        }\n        if (isHidden === true) {\n          swiper.emit('navigationShow', swiper);\n        } else {\n          swiper.emit('navigationHide', swiper);\n        }\n        if ($nextEl) {\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n        if ($prevEl) {\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n      }\n    },\n  },\n};\n\nconst Pagination = {\n  update() {\n    // Render || Update Pagination bullets/items\n    const swiper = this;\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const $el = swiper.pagination.$el;\n    // Current/Total\n    let current;\n    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {\n        current -= (slidesLength - (swiper.loopedSlides * 2));\n      }\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);\n          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {\n            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (swiper.pagination.dynamicBulletIndex < 0) {\n            swiper.pagination.dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = current - swiper.pagination.dynamicBulletIndex;\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);\n      if ($el.length > 1) {\n        bullets.each((index, bullet) => {\n          const $bullet = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(bullet);\n          const bulletIndex = $bullet.index();\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(`${params.bulletActiveClass}-main`);\n            }\n            if (bulletIndex === firstIndex) {\n              $bullet\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev`)\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev-prev`);\n            }\n            if (bulletIndex === lastIndex) {\n              $bullet\n                .next()\n                .addClass(`${params.bulletActiveClass}-next`)\n                .next()\n                .addClass(`${params.bulletActiveClass}-next-next`);\n            }\n          }\n        });\n      } else {\n        const $bullet = bullets.eq(current);\n        const bulletIndex = $bullet.index();\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          const $firstDisplayedBullet = bullets.eq(firstIndex);\n          const $lastDisplayedBullet = bullets.eq(lastIndex);\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n          }\n          if (swiper.params.loop) {\n            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {\n              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {\n                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);\n              }\n              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);\n            } else {\n              $firstDisplayedBullet\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev`)\n                .prev()\n                .addClass(`${params.bulletActiveClass}-prev-prev`);\n              $lastDisplayedBullet\n                .next()\n                .addClass(`${params.bulletActiveClass}-next`)\n                .next()\n                .addClass(`${params.bulletActiveClass}-next-next`);\n            }\n          } else {\n            $firstDisplayedBullet\n              .prev()\n              .addClass(`${params.bulletActiveClass}-prev`)\n              .prev()\n              .addClass(`${params.bulletActiveClass}-prev-prev`);\n            $lastDisplayedBullet\n              .next()\n              .addClass(`${params.bulletActiveClass}-next`)\n              .next()\n              .addClass(`${params.bulletActiveClass}-next-next`);\n          }\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n      }\n    }\n    if (params.type === 'fraction') {\n      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));\n      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));\n    }\n    if (params.type === 'progressbar') {\n      let progressbarDirection;\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n      const scale = (current + 1) / total;\n      let scaleX = 1;\n      let scaleY = 1;\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);\n    }\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', swiper, $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', swiper, $el[0]);\n    }\n    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n  },\n  render() {\n    // Render Container\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\n    const $el = swiper.pagination.$el;\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span>`\n        + ' / '\n        + `<span class=\"${params.totalClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n\n    let $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.el);\n    if ($el.length === 0) return;\n\n    if (\n      swiper.params.uniqueNavElements\n      && typeof params.el === 'string'\n      && $el.length > 1\n    ) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n      swiper.pagination.dynamicBulletIndex = 0;\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', `.${params.bulletClass}`, function onClick(e) {\n        e.preventDefault();\n        let index = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    Utils.extend(swiper.pagination, {\n      $el,\n      el: $el[0],\n    });\n  },\n  destroy() {\n    const swiper = this;\n    const params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    const $el = swiper.pagination.$el;\n\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n    if (params.clickable) {\n      $el.off('click', `.${params.bulletClass}`);\n    }\n  },\n};\n\nvar Pagination$1 = {\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: (number) => number,\n      formatFractionTotal: (number) => number,\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-', // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\n      clickableClass: 'swiper-pagination-clickable', // NEW\n      lockClass: 'swiper-pagination-lock',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      pagination: {\n        init: Pagination.init.bind(swiper),\n        render: Pagination.render.bind(swiper),\n        update: Pagination.update.bind(swiper),\n        destroy: Pagination.destroy.bind(swiper),\n        dynamicBulletIndex: 0,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange() {\n      const swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange() {\n      const swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.pagination.destroy();\n    },\n    click(e) {\n      const swiper = this;\n      if (\n        swiper.params.pagination.el\n        && swiper.params.pagination.hideOnClick\n        && swiper.pagination.$el.length > 0\n        && !Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).hasClass(swiper.params.pagination.bulletClass)\n      ) {\n        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);\n        if (isHidden === true) {\n          swiper.emit('paginationShow', swiper);\n        } else {\n          swiper.emit('paginationHide', swiper);\n        }\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    },\n  },\n};\n\nconst Scrollbar = {\n  setTranslate() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const { scrollbar, rtlTranslate: rtl, progress } = swiper;\n    const {\n      dragSize, trackSize, $dragEl, $el,\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n      $dragEl[0].style.width = `${newSize}px`;\n    } else {\n      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n      $dragEl[0].style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.timeout);\n      $el[0].style.opacity = 1;\n      swiper.scrollbar.timeout = setTimeout(() => {\n        $el[0].style.opacity = 0;\n        $el.transition(400);\n      }, 1000);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.$dragEl.transition(duration);\n  },\n  updateSize() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\n    const { scrollbar } = swiper;\n    const { $dragEl, $el } = scrollbar;\n\n    $dragEl[0].style.width = '';\n    $dragEl[0].style.height = '';\n    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n\n    const divider = swiper.size / swiper.virtualSize;\n    const moveDivider = divider * (trackSize / swiper.size);\n    let dragSize;\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      $dragEl[0].style.width = `${dragSize}px`;\n    } else {\n      $dragEl[0].style.height = `${dragSize}px`;\n    }\n\n    if (divider >= 1) {\n      $el[0].style.display = 'none';\n    } else {\n      $el[0].style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      $el[0].style.opacity = 0;\n    }\n    Utils.extend(scrollbar, {\n      trackSize,\n      divider,\n      moveDivider,\n      dragSize,\n    });\n    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\n  },\n  getPointerPosition(e) {\n    const swiper = this;\n    if (swiper.isHorizontal()) {\n      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);\n    }\n    return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);\n  },\n  setDragPosition(e) {\n    const swiper = this;\n    const { scrollbar, rtlTranslate: rtl } = swiper;\n    const {\n      $el,\n      dragSize,\n      trackSize,\n      dragStartPos,\n    } = scrollbar;\n\n    let positionRatio;\n    positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']\n      - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  },\n  onDragStart(e) {\n    const swiper = this;\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n    swiper.scrollbar.isTouched = true;\n    swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)\n      ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n    e.preventDefault();\n    e.stopPropagation();\n\n    $wrapperEl.transition(100);\n    $dragEl.transition(100);\n    scrollbar.setDragPosition(e);\n\n    clearTimeout(swiper.scrollbar.dragTimeout);\n\n    $el.transition(0);\n    if (params.hide) {\n      $el.css('opacity', 1);\n    }\n    if (swiper.params.cssMode) {\n      swiper.$wrapperEl.css('scroll-snap-type', 'none');\n    }\n    swiper.emit('scrollbarDragStart', e);\n  },\n  onDragMove(e) {\n    const swiper = this;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el, $dragEl } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n    scrollbar.setDragPosition(e);\n    $wrapperEl.transition(0);\n    $el.transition(0);\n    $dragEl.transition(0);\n    swiper.emit('scrollbarDragMove', e);\n  },\n  onDragEnd(e) {\n    const swiper = this;\n\n    const params = swiper.params.scrollbar;\n    const { scrollbar, $wrapperEl } = swiper;\n    const { $el } = scrollbar;\n\n    if (!swiper.scrollbar.isTouched) return;\n    swiper.scrollbar.isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.$wrapperEl.css('scroll-snap-type', '');\n      $wrapperEl.transition('');\n    }\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.dragTimeout);\n      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {\n        $el.css('opacity', 0);\n        $el.transition(400);\n      }, 1000);\n    }\n    swiper.emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  },\n  enableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  disableDraggable() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const {\n      scrollbar, touchEventsTouch, touchEventsDesktop, params,\n    } = swiper;\n    const $el = scrollbar.$el;\n    const target = $el[0];\n    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\n    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n    if (!Support.touch) {\n      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\n    } else {\n      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\n      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\n      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.scrollbar.el) return;\n    const { scrollbar, $el: $swiperEl } = swiper;\n    const params = swiper.params.scrollbar;\n\n    let $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(params.el);\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\n      $el = $swiperEl.find(params.el);\n    }\n\n    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n    if ($dragEl.length === 0) {\n      $dragEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n      $el.append($dragEl);\n    }\n\n    Utils.extend(scrollbar, {\n      $el,\n      el: $el[0],\n      $dragEl,\n      dragEl: $dragEl[0],\n    });\n\n    if (params.draggable) {\n      scrollbar.enableDraggable();\n    }\n  },\n  destroy() {\n    const swiper = this;\n    swiper.scrollbar.disableDraggable();\n  },\n};\n\nvar Scrollbar$1 = {\n  name: 'scrollbar',\n  params: {\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      scrollbar: {\n        init: Scrollbar.init.bind(swiper),\n        destroy: Scrollbar.destroy.bind(swiper),\n        updateSize: Scrollbar.updateSize.bind(swiper),\n        setTranslate: Scrollbar.setTranslate.bind(swiper),\n        setTransition: Scrollbar.setTransition.bind(swiper),\n        enableDraggable: Scrollbar.enableDraggable.bind(swiper),\n        disableDraggable: Scrollbar.disableDraggable.bind(swiper),\n        setDragPosition: Scrollbar.setDragPosition.bind(swiper),\n        getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),\n        onDragStart: Scrollbar.onDragStart.bind(swiper),\n        onDragMove: Scrollbar.onDragMove.bind(swiper),\n        onDragEnd: Scrollbar.onDragEnd.bind(swiper),\n        isTouched: false,\n        timeout: null,\n        dragTimeout: null,\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      swiper.scrollbar.init();\n      swiper.scrollbar.updateSize();\n      swiper.scrollbar.setTranslate();\n    },\n    update() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    resize() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    observerUpdate() {\n      const swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    setTranslate() {\n      const swiper = this;\n      swiper.scrollbar.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      swiper.scrollbar.setTransition(duration);\n    },\n    destroy() {\n      const swiper = this;\n      swiper.scrollbar.destroy();\n    },\n  },\n};\n\nconst Parallax = {\n  setTransform(el, progress) {\n    const swiper = this;\n    const { rtl } = swiper;\n\n    const $el = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(el);\n    const rtlFactor = rtl ? -1 : 1;\n\n    const p = $el.attr('data-swiper-parallax') || '0';\n    let x = $el.attr('data-swiper-parallax-x');\n    let y = $el.attr('data-swiper-parallax-y');\n    const scale = $el.attr('data-swiper-parallax-scale');\n    const opacity = $el.attr('data-swiper-parallax-opacity');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if ((x).indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if ((y).indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));\n      $el[0].style.opacity = currentOpacity;\n    }\n    if (typeof scale === 'undefined' || scale === null) {\n      $el.transform(`translate3d(${x}, ${y}, 0px)`);\n    } else {\n      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));\n      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n    }\n  },\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, slides, progress, snapGrid,\n    } = swiper;\n    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')\n      .each((index, el) => {\n        swiper.parallax.setTransform(el, progress);\n      });\n    slides.each((slideIndex, slideEl) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')\n        .each((index, el) => {\n          swiper.parallax.setTransform(el, slideProgress);\n        });\n    });\n  },\n  setTransition(duration = this.params.speed) {\n    const swiper = this;\n    const { $el } = swiper;\n    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')\n      .each((index, parallaxEl) => {\n        const $parallaxEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(parallaxEl);\n        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        $parallaxEl.transition(parallaxDuration);\n      });\n  },\n};\n\nvar Parallax$1 = {\n  name: 'parallax',\n  params: {\n    parallax: {\n      enabled: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      parallax: {\n        setTransform: Parallax.setTransform.bind(swiper),\n        setTranslate: Parallax.setTranslate.bind(swiper),\n        setTransition: Parallax.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    init() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTranslate() {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (!swiper.params.parallax.enabled) return;\n      swiper.parallax.setTransition(duration);\n    },\n  },\n};\n\nconst Zoom = {\n  // Calc Scale From Multi-touches\n  getDistanceBetweenTouches(e) {\n    if (e.targetTouches.length < 2) return 1;\n    const x1 = e.targetTouches[0].pageX;\n    const y1 = e.targetTouches[0].pageY;\n    const x2 = e.targetTouches[1].pageX;\n    const y2 = e.targetTouches[1].pageY;\n    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));\n    return distance;\n  },\n  // Events\n  onGestureStart(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    zoom.fakeGestureTouched = false;\n    zoom.fakeGestureMoved = false;\n    if (!Support.gestures) {\n      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureTouched = true;\n      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$slideEl || !gesture.$slideEl.length) {\n      gesture.$slideEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target).closest(`.${swiper.params.slideClass}`);\n      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      if (gesture.$imageWrapEl.length === 0) {\n        gesture.$imageEl = undefined;\n        return;\n      }\n    }\n    if (gesture.$imageEl) {\n      gesture.$imageEl.transition(0);\n    }\n    swiper.zoom.isScaling = true;\n  },\n  onGestureChange(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureMoved = true;\n      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (Support.gestures) {\n      zoom.scale = e.scale * zoom.currentScale;\n    } else {\n      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;\n    }\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);\n    }\n    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  onGestureEnd(e) {\n    const swiper = this;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (!Support.gestures) {\n      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {\n        return;\n      }\n      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {\n        return;\n      }\n      zoom.fakeGestureTouched = false;\n      zoom.fakeGestureMoved = false;\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    zoom.currentScale = zoom.scale;\n    zoom.isScaling = false;\n    if (zoom.scale === 1) gesture.$slideEl = undefined;\n  },\n  onTouchStart(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (image.isTouched) return;\n    if (Device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  },\n  onTouchMove(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    swiper.allowClick = false;\n    if (!image.isTouched || !gesture.$slideEl) return;\n\n    if (!image.isMoved) {\n      image.width = gesture.$imageEl[0].offsetWidth;\n      image.height = gesture.$imageEl[0].offsetHeight;\n      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n      gesture.$imageWrapEl.transition(0);\n      if (swiper.rtl) {\n        image.startX = -image.startX;\n        image.startY = -image.startY;\n      }\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n    if (!image.isMoved && !zoom.isScaling) {\n      if (\n        swiper.isHorizontal()\n        && (\n          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)\n          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      } if (\n        !swiper.isHorizontal()\n        && (\n          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)\n          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n\n    image.isMoved = true;\n    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;\n    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;\n\n    if (image.currentX < image.minX) {\n      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTouchEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture, image, velocity } = zoom;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n  },\n  onTransitionEnd() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    const { gesture } = zoom;\n    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n      if (gesture.$imageEl) {\n        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n      }\n      if (gesture.$imageWrapEl) {\n        gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n      }\n\n      zoom.scale = 1;\n      zoom.currentScale = 1;\n\n      gesture.$slideEl = undefined;\n      gesture.$imageEl = undefined;\n      gesture.$imageWrapEl = undefined;\n    }\n  },\n  // Toggle Zoom\n  toggle(e) {\n    const swiper = this;\n    const zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoom.out();\n    } else {\n      // Zoom In\n      zoom.in(e);\n    }\n  },\n  in(e) {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture, image } = zoom;\n\n    if (!gesture.$slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n      } else {\n        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      }\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    if (e) {\n      slideWidth = gesture.$slideEl[0].offsetWidth;\n      slideHeight = gesture.$slideEl[0].offsetHeight;\n      offsetX = gesture.$slideEl.offset().left;\n      offsetY = gesture.$slideEl.offset().top;\n      diffX = (offsetX + (slideWidth / 2)) - touchX;\n      diffY = (offsetY + (slideHeight / 2)) - touchY;\n\n      imageWidth = gesture.$imageEl[0].offsetWidth;\n      imageHeight = gesture.$imageEl[0].offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);\n      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n  },\n  out() {\n    const swiper = this;\n\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    const { gesture } = zoom;\n\n    if (!gesture.$slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n      } else {\n        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n      }\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');\n      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n    zoom.scale = 1;\n    zoom.currentScale = 1;\n    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n    gesture.$slideEl = undefined;\n  },\n  // Attach/Detach Events\n  enable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;\n\n    const slideSelector = `.${swiper.params.slideClass}`;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);\n      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);\n      if (swiper.touchEvents.cancel) {\n        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);\n      }\n    }\n\n    // Move image\n    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);\n  },\n  disable() {\n    const swiper = this;\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n\n    swiper.zoom.enabled = false;\n\n    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;\n\n    const slideSelector = `.${swiper.params.slideClass}`;\n\n    // Scale image\n    if (Support.gestures) {\n      swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);\n      swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);\n      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);\n      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);\n      if (swiper.touchEvents.cancel) {\n        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);\n      }\n    }\n\n    // Move image\n    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);\n  },\n};\n\nvar Zoom$1 = {\n  name: 'zoom',\n  params: {\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  },\n  create() {\n    const swiper = this;\n    const zoom = {\n      enabled: false,\n      scale: 1,\n      currentScale: 1,\n      isScaling: false,\n      gesture: {\n        $slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        $imageEl: undefined,\n        $imageWrapEl: undefined,\n        maxRatio: 3,\n      },\n      image: {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {},\n      },\n      velocity: {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined,\n      },\n    };\n\n    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {\n      zoom[methodName] = Zoom[methodName].bind(swiper);\n    });\n    Utils.extend(swiper, {\n      zoom,\n    });\n\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n      set(value) {\n        if (scale !== value) {\n          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;\n          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;\n          swiper.emit('zoomChange', value, imageEl, slideEl);\n        }\n        scale = value;\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.zoom.enabled) {\n        swiper.zoom.enable();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      swiper.zoom.disable();\n    },\n    touchStart(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchStart(e);\n    },\n    touchEnd(e) {\n      const swiper = this;\n      if (!swiper.zoom.enabled) return;\n      swiper.zoom.onTouchEnd(e);\n    },\n    doubleTap(e) {\n      const swiper = this;\n      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        swiper.zoom.toggle(e);\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        swiper.zoom.onTransitionEnd();\n      }\n    },\n    slideChange() {\n      const swiper = this;\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n        swiper.zoom.onTransitionEnd();\n      }\n    },\n  },\n};\n\nconst Lazy = {\n  loadInSlide(index, loadInDuplicate = true) {\n    const swiper = this;\n    const params = swiper.params.lazy;\n    if (typeof index === 'undefined') return;\n    if (swiper.slides.length === 0) return;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    const $slideEl = isVirtual\n      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n      : swiper.slides.eq(index);\n\n    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);\n    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\n      $images = $images.add($slideEl[0]);\n    }\n    if ($images.length === 0) return;\n\n    $images.each((imageIndex, imageEl) => {\n      const $imageEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(imageEl);\n      $imageEl.addClass(params.loadingClass);\n\n      const background = $imageEl.attr('data-background');\n      const src = $imageEl.attr('data-src');\n      const srcset = $imageEl.attr('data-srcset');\n      const sizes = $imageEl.attr('data-sizes');\n      const $pictureEl = $imageEl.parent('picture');\n\n      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {\n        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;\n        if (background) {\n          $imageEl.css('background-image', `url(\"${background}\")`);\n          $imageEl.removeAttr('data-background');\n        } else {\n          if (srcset) {\n            $imageEl.attr('srcset', srcset);\n            $imageEl.removeAttr('data-srcset');\n          }\n          if (sizes) {\n            $imageEl.attr('sizes', sizes);\n            $imageEl.removeAttr('data-sizes');\n          }\n          if ($pictureEl.length) {\n            $pictureEl.children('source').each((sourceIndex, sourceEl) => {\n              const $source = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(sourceEl);\n\n              if ($source.attr('data-srcset')) {\n                $source.attr('srcset', $source.attr('data-srcset'));\n                $source.removeAttr('data-srcset');\n              }\n            });\n          }\n          if (src) {\n            $imageEl.attr('src', src);\n            $imageEl.removeAttr('data-src');\n          }\n        }\n\n        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n        $slideEl.find(`.${params.preloaderClass}`).remove();\n        if (swiper.params.loop && loadInDuplicate) {\n          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`);\n            swiper.lazy.loadInSlide(originalSlide.index(), false);\n          } else {\n            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`);\n            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);\n          }\n        }\n        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n        if (swiper.params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n      });\n\n      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n    });\n  },\n  load() {\n    const swiper = this;\n    const {\n      $wrapperEl, params: swiperParams, slides, activeIndex,\n    } = swiper;\n    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n    const params = swiperParams.lazy;\n\n    let slidesPerView = swiperParams.slidesPerView;\n    if (slidesPerView === 'auto') {\n      slidesPerView = 0;\n    }\n\n    function slideExist(index) {\n      if (isVirtual) {\n        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`).length) {\n          return true;\n        }\n      } else if (slides[index]) return true;\n      return false;\n    }\n\n    function slideIndex(slideEl) {\n      if (isVirtual) {\n        return Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).attr('data-swiper-slide-index');\n      }\n      return Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).index();\n    }\n\n    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;\n    if (swiper.params.watchSlidesVisibility) {\n      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {\n        const index = isVirtual ? Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).attr('data-swiper-slide-index') : Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(slideEl).index();\n        swiper.lazy.loadInSlide(index);\n      });\n    } else if (slidesPerView > 1) {\n      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n        if (slideExist(i)) swiper.lazy.loadInSlide(i);\n      }\n    } else {\n      swiper.lazy.loadInSlide(activeIndex);\n    }\n    if (params.loadPrevNext) {\n      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n        const amount = params.loadPrevNextAmount;\n        const spv = slidesPerView;\n        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\n        // Next Slides\n        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n        // Prev Slides\n        for (let i = minIndex; i < activeIndex; i += 1) {\n          if (slideExist(i)) swiper.lazy.loadInSlide(i);\n        }\n      } else {\n        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));\n\n        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));\n      }\n    }\n  },\n};\n\nvar Lazy$1 = {\n  name: 'lazy',\n  params: {\n    lazy: {\n      enabled: false,\n      loadPrevNext: false,\n      loadPrevNextAmount: 1,\n      loadOnTransitionStart: false,\n\n      elementClass: 'swiper-lazy',\n      loadingClass: 'swiper-lazy-loading',\n      loadedClass: 'swiper-lazy-loaded',\n      preloaderClass: 'swiper-lazy-preloader',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      lazy: {\n        initialImageLoaded: false,\n        load: Lazy.load.bind(swiper),\n        loadInSlide: Lazy.loadInSlide.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n        swiper.params.preloadImages = false;\n      }\n    },\n    init() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {\n        swiper.lazy.load();\n      }\n    },\n    scroll() {\n      const swiper = this;\n      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {\n        swiper.lazy.load();\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    scrollbarDragMove() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    transitionStart() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {\n          swiper.lazy.load();\n        }\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n        swiper.lazy.load();\n      }\n    },\n    slideChange() {\n      const swiper = this;\n      if (swiper.params.lazy.enabled && swiper.params.cssMode) {\n        swiper.lazy.load();\n      }\n    },\n  },\n};\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n\nconst Controller = {\n  LinearSpline: function LinearSpline(x, y) {\n    const binarySearch = (function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }());\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];\n    };\n    return this;\n  },\n  // xxx: for now i will just save one spline function to to\n  getInterpolateFunction(c) {\n    const swiper = this;\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop\n        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)\n        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  },\n  setTranslate(setTranslate, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        swiper.controller.getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  },\n  setTransition(duration, byController) {\n    const swiper = this;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          Utils.nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        c.$wrapperEl.transitionEnd(() => {\n          if (!controlled) return;\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  },\n};\nvar Controller$1 = {\n  name: 'controller',\n  params: {\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      controller: {\n        control: swiper.params.controller.control,\n        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),\n        setTranslate: Controller.setTranslate.bind(swiper),\n        setTransition: Controller.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    update() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    setTranslate(translate, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTranslate(translate, byController);\n    },\n    setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.controller.control) return;\n      swiper.controller.setTransition(duration, byController);\n    },\n  },\n};\n\nconst a11y = {\n  makeElFocusable($el) {\n    $el.attr('tabIndex', '0');\n    return $el;\n  },\n  makeElNotFocusable($el) {\n    $el.attr('tabIndex', '-1');\n    return $el;\n  },\n  addElRole($el, role) {\n    $el.attr('role', role);\n    return $el;\n  },\n  addElLabel($el, label) {\n    $el.attr('aria-label', label);\n    return $el;\n  },\n  disableEl($el) {\n    $el.attr('aria-disabled', true);\n    return $el;\n  },\n  enableEl($el) {\n    $el.attr('aria-disabled', false);\n    return $el;\n  },\n  onEnterKey(e) {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (e.keyCode !== 13) return;\n    const $targetEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(e.target);\n    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        swiper.a11y.notify(params.lastSlideMessage);\n      } else {\n        swiper.a11y.notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        swiper.a11y.notify(params.firstSlideMessage);\n      } else {\n        swiper.a11y.notify(params.prevSlideMessage);\n      }\n    }\n    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {\n      $targetEl[0].click();\n    }\n  },\n  notify(message) {\n    const swiper = this;\n    const notification = swiper.a11y.liveRegion;\n    if (notification.length === 0) return;\n    notification.html('');\n    notification.html(message);\n  },\n  updateNavigation() {\n    const swiper = this;\n\n    if (swiper.params.loop || !swiper.navigation) return;\n    const { $nextEl, $prevEl } = swiper.navigation;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        swiper.a11y.disableEl($prevEl);\n        swiper.a11y.makeElNotFocusable($prevEl);\n      } else {\n        swiper.a11y.enableEl($prevEl);\n        swiper.a11y.makeElFocusable($prevEl);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        swiper.a11y.disableEl($nextEl);\n        swiper.a11y.makeElNotFocusable($nextEl);\n      } else {\n        swiper.a11y.enableEl($nextEl);\n        swiper.a11y.makeElFocusable($nextEl);\n      }\n    }\n  },\n  updatePagination() {\n    const swiper = this;\n    const params = swiper.params.a11y;\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {\n        const $bulletEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(bulletEl);\n        swiper.a11y.makeElFocusable($bulletEl);\n        swiper.a11y.addElRole($bulletEl, 'button');\n        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, $bulletEl.index() + 1));\n      });\n    }\n  },\n  init() {\n    const swiper = this;\n\n    swiper.$el.append(swiper.a11y.liveRegion);\n\n    // Navigation\n    const params = swiper.params.a11y;\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      swiper.a11y.makeElFocusable($nextEl);\n      swiper.a11y.addElRole($nextEl, 'button');\n      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);\n      $nextEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      swiper.a11y.makeElFocusable($prevEl);\n      swiper.a11y.addElRole($prevEl, 'button');\n      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);\n      $prevEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();\n\n    let $nextEl;\n    let $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      $nextEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      $prevEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);\n    }\n  },\n};\nvar A11y = {\n  name: 'a11y',\n  params: {\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      a11y: {\n        liveRegion: Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`),\n      },\n    });\n    Object.keys(a11y).forEach((methodName) => {\n      swiper.a11y[methodName] = a11y[methodName].bind(swiper);\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.init();\n      swiper.a11y.updateNavigation();\n    },\n    toEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    fromEdge() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updateNavigation();\n    },\n    paginationUpdate() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.updatePagination();\n    },\n    destroy() {\n      const swiper = this;\n      if (!swiper.params.a11y.enabled) return;\n      swiper.a11y.destroy();\n    },\n  },\n};\n\nconst History = {\n  init() {\n    const swiper = this;\n    if (!swiper.params.history) return;\n    if (!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history || !ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    const history = swiper.history;\n    history.initialized = true;\n    history.paths = History.getPathValues();\n    if (!history.paths.key && !history.paths.value) return;\n    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].addEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (!swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].removeEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  setHistoryPopState() {\n    const swiper = this;\n    swiper.history.paths = History.getPathValues();\n    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);\n  },\n  getPathValues() {\n    const pathArray = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.pathname.slice(1).split('/').filter((part) => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return { key, value };\n  },\n  setHistory(key, index) {\n    const swiper = this;\n    if (!swiper.history.initialized || !swiper.params.history.enabled) return;\n    const slide = swiper.slides.eq(index);\n    let value = History.slugify(slide.attr('data-history'));\n    if (!ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].location.pathname.includes(key)) {\n      value = `${key}/${value}`;\n    }\n    const currentState = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState({ value }, null, value);\n    } else {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.pushState({ value }, null, value);\n    }\n  },\n  slugify(text) {\n    return text.toString()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  },\n  scrollToSlide(speed, value, runCallbacks) {\n    const swiper = this;\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHistory = History.slugify(slide.attr('data-history'));\n        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  },\n};\n\nvar History$1 = {\n  name: 'history',\n  params: {\n    history: {\n      enabled: false,\n      replaceState: false,\n      key: 'slides',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      history: {\n        init: History.init.bind(swiper),\n        setHistory: History.setHistory.bind(swiper),\n        setHistoryPopState: History.setHistoryPopState.bind(swiper),\n        scrollToSlide: History.scrollToSlide.bind(swiper),\n        destroy: History.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.history.initialized) {\n        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    },\n    slideChange() {\n      const swiper = this;\n      if (swiper.history.initialized && swiper.params.cssMode) {\n        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    },\n  },\n};\n\nconst HashNavigation = {\n  onHashCange() {\n    const swiper = this;\n    swiper.emit('hashChange');\n    const newHash = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash.replace('#', '');\n    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`).index();\n      if (typeof newIndex === 'undefined') return;\n      swiper.slideTo(newIndex);\n    }\n  },\n  setHash() {\n    const swiper = this;\n    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;\n    if (swiper.params.hashNavigation.replaceState && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history && ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState) {\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"].history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));\n      swiper.emit('hashSet');\n    } else {\n      const slide = swiper.slides.eq(swiper.activeIndex);\n      const hash = slide.attr('data-hash') || slide.attr('data-history');\n      ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash = hash || '';\n      swiper.emit('hashSet');\n    }\n  },\n  init() {\n    const swiper = this;\n    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;\n    swiper.hashNavigation.initialized = true;\n    const hash = ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"document\"].location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides.eq(i);\n        const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          const index = slide.index();\n          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n        }\n      }\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]).on('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n  destroy() {\n    const swiper = this;\n    if (swiper.params.hashNavigation.watchState) {\n      Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(ssr_window__WEBPACK_IMPORTED_MODULE_1__[\"window\"]).off('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n};\nvar HashNavigation$1 = {\n  name: 'hash-navigation',\n  params: {\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      hashNavigation: {\n        initialized: false,\n        init: HashNavigation.init.bind(swiper),\n        destroy: HashNavigation.destroy.bind(swiper),\n        setHash: HashNavigation.setHash.bind(swiper),\n        onHashCange: HashNavigation.onHashCange.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.init();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.destroy();\n      }\n    },\n    transitionEnd() {\n      const swiper = this;\n      if (swiper.hashNavigation.initialized) {\n        swiper.hashNavigation.setHash();\n      }\n    },\n    slideChange() {\n      const swiper = this;\n      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {\n        swiper.hashNavigation.setHash();\n      }\n    },\n  },\n};\n\n/* eslint no-underscore-dangle: \"off\" */\n\nconst Autoplay = {\n  run() {\n    const swiper = this;\n    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    let delay = swiper.params.autoplay.delay;\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n    clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.timeout = Utils.nextTick(() => {\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else {\n          swiper.autoplay.stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();\n    }, delay);\n  },\n  start() {\n    const swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop() {\n    const swiper = this;\n    if (!swiper.autoplay.running) return false;\n    if (typeof swiper.autoplay.timeout === 'undefined') return false;\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause(speed) {\n    const swiper = this;\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.paused = true;\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n    }\n  },\n};\n\nvar Autoplay$1 = {\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      autoplay: {\n        running: false,\n        paused: false,\n        run: Autoplay.run.bind(swiper),\n        start: Autoplay.start.bind(swiper),\n        stop: Autoplay.stop.bind(swiper),\n        pause: Autoplay.pause.bind(swiper),\n        onVisibilityChange() {\n          if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n            swiper.autoplay.pause();\n          }\n          if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n            swiper.autoplay.run();\n            swiper.autoplay.paused = false;\n          }\n        },\n        onTransitionEnd(e) {\n          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n          swiper.autoplay.paused = false;\n          if (!swiper.autoplay.running) {\n            swiper.autoplay.stop();\n          } else {\n            swiper.autoplay.run();\n          }\n        },\n      },\n    });\n  },\n  on: {\n    init() {\n      const swiper = this;\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n      }\n    },\n    beforeTransitionStart(speed, internal) {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    touchEnd() {\n      const swiper = this;\n      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\n        swiper.autoplay.run();\n      }\n    },\n    destroy() {\n      const swiper = this;\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n    },\n  },\n};\n\nconst Fade = {\n  setTranslate() {\n    const swiper = this;\n    const { slides } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset = $slideEl[0].swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade\n        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      $slideEl\n        .css({\n          opacity: slideOpacity,\n        })\n        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, $wrapperEl } = swiper;\n    slides.transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      slides.transitionEnd(() => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFade = {\n  name: 'effect-fade',\n  params: {\n    fadeEffect: {\n      crossFade: false,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      fadeEffect: {\n        setTranslate: Fade.setTranslate.bind(swiper),\n        setTransition: Fade.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'fade') return;\n      swiper.fadeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Cube = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let $cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])('<div class=\"swiper-cube-shadow\"></div>');\n          $wrapperEl.append($cubeShadowEl);\n        }\n        $cubeShadowEl.css({ height: `${swiperWidth}px` });\n      } else {\n        $cubeShadowEl = $el.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])('<div class=\"swiper-cube-shadow\"></div>');\n          $el.append($cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + (round * 4 * swiperSize);\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = (3 * swiperSize) + (swiperSize * 4 * round);\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = (slideIndex * 90) + (progress * 90);\n        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);\n      }\n      $slideEl.transform(transform);\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n    }\n    $wrapperEl.css({\n      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,\n      'transform-origin': `50% 50% -${swiperSize / 2}px`,\n    });\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);\n        const multiplier = 1.5 - (\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)\n          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)\n        );\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);\n      }\n    }\n    const zFactor = (Browser.isSafari || Browser.isWebView) ? (-swiperSize / 2) : 0;\n    $wrapperEl\n      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { $el, slides } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      $el.find('.swiper-cube-shadow').transition(duration);\n    }\n  },\n};\n\nvar EffectCube = {\n  name: 'effect-cube',\n  params: {\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      cubeEffect: {\n        setTranslate: Cube.setTranslate.bind(swiper),\n        setTransition: Cube.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'cube') return;\n      swiper.cubeEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Flip = {\n  setTranslate() {\n    const swiper = this;\n    const { slides, rtlTranslate: rtl } = swiper;\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = slides.eq(i);\n      let progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      }\n      const offset = $slideEl[0].swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (swiper.params.flipEffect.slideShadows) {\n        // Set shadows\n        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}\"></div>`);\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n      }\n      $slideEl\n        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    const { slides, activeIndex, $wrapperEl } = swiper;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      // eslint-disable-next-line\n      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFlip = {\n  name: 'effect-flip',\n  params: {\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      flipEffect: {\n        setTranslate: Flip.setTranslate.bind(swiper),\n        setTransition: Flip.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      const overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'flip') return;\n      swiper.flipEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Coverflow = {\n  setTranslate() {\n    const swiper = this;\n    const {\n      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const $slideEl = slides.eq(i);\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = $slideEl[0].swiperSlideOffset;\n      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;\n\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = ((parseFloat(params.stretch) / 100) * slideSize);\n      }\n      let translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);\n      let translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;\n\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n\n      $slideEl.transform(slideTransform);\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if ($shadowBeforeEl.length === 0) {\n          $shadowBeforeEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n          $slideEl.append($shadowBeforeEl);\n        }\n        if ($shadowAfterEl.length === 0) {\n          $shadowAfterEl = Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n          $slideEl.append($shadowAfterEl);\n        }\n        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;\n      }\n    }\n\n    // Set correct perspective for IE10\n    if (Support.pointerEvents || Support.prefixedPointerEvents) {\n      const ws = $wrapperEl[0].style;\n      ws.perspectiveOrigin = `${center}px 50%`;\n    }\n  },\n  setTransition(duration) {\n    const swiper = this;\n    swiper.slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n  },\n};\n\nvar EffectCoverflow = {\n  name: 'effect-coverflow',\n  params: {\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true,\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      coverflowEffect: {\n        setTranslate: Coverflow.setTranslate.bind(swiper),\n        setTransition: Coverflow.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n\n      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    setTranslate() {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTranslate();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      if (swiper.params.effect !== 'coverflow') return;\n      swiper.coverflowEffect.setTransition(duration);\n    },\n  },\n};\n\nconst Thumbs = {\n  init() {\n    const swiper = this;\n    const { thumbs: thumbsParams } = swiper.params;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Utils.extend(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n      Utils.extend(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      });\n    } else if (Utils.isObject(thumbsParams.swiper)) {\n      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {\n        watchSlidesVisibility: true,\n        watchSlidesProgress: true,\n        slideToClickedSlide: false,\n      }));\n      swiper.thumbs.swiperCreated = true;\n    }\n    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);\n  },\n  onThumbClick() {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(Object(dom7_dist_dom7_modular__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      let currentIndex = swiper.activeIndex;\n      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n        swiper.loopFix();\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n        currentIndex = swiper.activeIndex;\n      }\n      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`).eq(0).index();\n      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n      else slideToIndex = prevIndex;\n    }\n    swiper.slideTo(slideToIndex);\n  },\n  update(initial) {\n    const swiper = this;\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper) return;\n\n    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'\n      ? thumbsSwiper.slidesPerViewDynamic()\n      : thumbsSwiper.params.slidesPerView;\n\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      let currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n          thumbsSwiper.loopFix();\n          // eslint-disable-next-line\n          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n          currentThumbsIndex = thumbsSwiper.activeIndex;\n        }\n        // Find actual thumbs index to slide to\n        const prevThumbsIndex = thumbsSwiper.slides\n          .eq(currentThumbsIndex)\n          .prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0)\n          .index();\n        const nextThumbsIndex = thumbsSwiper.slides\n          .eq(currentThumbsIndex)\n          .nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`).eq(0)\n          .index();\n        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;\n        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;\n        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;\n        else newThumbsIndex = prevThumbsIndex;\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n\n      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex) {\n          newThumbsIndex = newThumbsIndex - slidesPerView + 1;\n        }\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n\n    thumbsToActivate = Math.floor(thumbsToActivate);\n\n    thumbsSwiper.slides.removeClass(thumbActiveClass);\n    if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).addClass(thumbActiveClass);\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n      }\n    }\n  },\n};\nvar Thumbs$1 = {\n  name: 'thumbs',\n  params: {\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-container-thumbs',\n    },\n  },\n  create() {\n    const swiper = this;\n    Utils.extend(swiper, {\n      thumbs: {\n        swiper: null,\n        init: Thumbs.init.bind(swiper),\n        update: Thumbs.update.bind(swiper),\n        onThumbClick: Thumbs.onThumbClick.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit() {\n      const swiper = this;\n      const { thumbs } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      swiper.thumbs.init();\n      swiper.thumbs.update(true);\n    },\n    slideChange() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    update() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    resize() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    observerUpdate() {\n      const swiper = this;\n      if (!swiper.thumbs.swiper) return;\n      swiper.thumbs.update();\n    },\n    setTransition(duration) {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      thumbsSwiper.setTransition(duration);\n    },\n    beforeDestroy() {\n      const swiper = this;\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper) return;\n      if (swiper.thumbs.swiperCreated && thumbsSwiper) {\n        thumbsSwiper.destroy();\n      }\n    },\n  },\n};\n\n// Swiper Class\n\nconst components = [\n  Device$1,\n  Support$1,\n  Browser$1,\n  Resize,\n  Observer$1,\n  Virtual$1,\n  Keyboard$1,\n  Mousewheel$1,\n  Navigation$1,\n  Pagination$1,\n  Scrollbar$1,\n  Parallax$1,\n  Zoom$1,\n  Lazy$1,\n  Controller$1,\n  A11y,\n  History$1,\n  HashNavigation$1,\n  Autoplay$1,\n  EffectFade,\n  EffectCube,\n  EffectFlip,\n  EffectCoverflow,\n  Thumbs$1\n];\n\nif (typeof Swiper.use === 'undefined') {\n  Swiper.use = Swiper.Class.use;\n  Swiper.installModule = Swiper.Class.installModule;\n}\n\nSwiper.use(components);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Swiper);\n//# sourceMappingURL=swiper.esm.bundle.js.map\n\n\n//# sourceURL=webpack:///./node_modules/swiper/js/swiper.esm.bundle.js?")},0:function _(module,exports,__webpack_require__){eval('__webpack_require__(/*! D:\\Repositories\\portfolio\\dev\\js\\app.js */"./dev/js/app.js");\n__webpack_require__(/*! D:\\Repositories\\portfolio\\dev\\js\\Common\\mobile-menu.js */"./dev/js/Common/mobile-menu.js");\nmodule.exports = __webpack_require__(/*! D:\\Repositories\\portfolio\\dev\\js\\Common\\swiper.js */"./dev/js/Common/swiper.js");\n\n\n//# sourceURL=webpack:///multi_./dev/js/app.js_./dev/js/Common/mobile-menu.js_./dev/js/Common/swiper.js?')}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjJlN2NlNTMzYTNhMjUyNzBlNDFjLmpzIl0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJleHBvcnRzIiwibW9kdWxlIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJvYmplY3QiLCJwcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCIuL2Rldi9qcy9Db21tb24vbW9iaWxlLW1lbnUuanMiLCJkZXZKc0NvbW1vbk1vYmlsZU1lbnVKcyIsImV2YWwiLCIuL2Rldi9qcy9Db21tb24vc3dpcGVyLmpzIiwiZGV2SnNDb21tb25Td2lwZXJKcyIsIl9fd2VicGFja19leHBvcnRzX18iLCIuL2Rldi9qcy9hcHAuanMiLCJkZXZKc0FwcEpzIiwiLi9ub2RlX21vZHVsZXMvZG9tNy9kaXN0L2RvbTcubW9kdWxhci5qcyIsIm5vZGVfbW9kdWxlc0RvbTdEaXN0RG9tN01vZHVsYXJKcyIsIi4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvZGlzdC9zc3Itd2luZG93LmVzbS5qcyIsIm5vZGVfbW9kdWxlc1NzcldpbmRvd0Rpc3RTc3JXaW5kb3dFc21KcyIsIi4vbm9kZV9tb2R1bGVzL3N3aXBlci9qcy9zd2lwZXIuZXNtLmJ1bmRsZS5qcyIsIm5vZGVfbW9kdWxlc1N3aXBlckpzU3dpcGVyRXNtQnVuZGxlSnMiLCIwIiwiXyJdLCJtYXBwaW5ncyI6IkFBQUEsYUFFQSxTQUFTQSxRQUFRQyxHQUFtVixPQUF0T0QsUUFBckQsbUJBQVhFLFFBQW9ELGlCQUFwQkEsT0FBT0MsU0FBbUMsU0FBaUJGLEdBQU8sY0FBY0EsR0FBMkIsU0FBaUJBLEdBQU8sT0FBT0EsR0FBeUIsbUJBQVhDLFFBQXlCRCxFQUFJRyxjQUFnQkYsUUFBVUQsSUFBUUMsT0FBT0csVUFBWSxnQkFBa0JKLElBQXlCQSxJQUduWCxTQUFXSyxHQU9ULElBQUlDLEVBQW1CLEdBUXZCLFNBQVNDLEVBQW9CQyxHQU8zQixHQUFJRixFQUFpQkUsR0FFbkIsT0FBT0YsRUFBaUJFLEdBQVVDLFFBU3BDLElBQUlDLEVBQVNKLEVBQWlCRSxHQUFZLENBRXhDRyxFQUFHSCxFQUdISSxHQUFHLEVBR0hILFFBQVMsSUEyQlgsT0FoQkFKLEVBQVFHLEdBQVVLLEtBQUtILEVBQU9ELFFBQVNDLEVBQVFBLEVBQU9ELFFBQVNGLEdBUS9ERyxFQUFPRSxHQUFJLEVBUUpGLEVBQU9ELFFBYWhCRixFQUFvQk8sRUFBSVQsRUFReEJFLEVBQW9CUSxFQUFJVCxFQVF4QkMsRUFBb0JTLEVBQUksU0FBVVAsRUFBU1EsRUFBTUMsR0FFMUNYLEVBQW9CWSxFQUFFVixFQUFTUSxJQUVsQ0csT0FBT0MsZUFBZVosRUFBU1EsRUFBTSxDQUNuQ0ssWUFBWSxFQUNaQyxJQUFLTCxLQWVYWCxFQUFvQmlCLEVBQUksU0FBVWYsR0FFVixvQkFBWFIsUUFBMEJBLE9BQU93QixhQUUxQ0wsT0FBT0MsZUFBZVosRUFBU1IsT0FBT3dCLFlBQWEsQ0FDakRDLE1BQU8sV0FPWE4sT0FBT0MsZUFBZVosRUFBUyxhQUFjLENBQzNDaUIsT0FBTyxLQXdCWG5CLEVBQW9Cb0IsRUFBSSxTQUFVRCxFQUFPRSxHQUt2QyxHQUhXLEVBQVBBLElBQVVGLEVBQVFuQixFQUFvQm1CLElBRy9CLEVBQVBFLEVBQVUsT0FBT0YsRUFHckIsR0FBVyxFQUFQRSxHQUErQixXQUFuQjdCLFFBQVEyQixJQUF1QkEsR0FBU0EsRUFBTUcsV0FBWSxPQUFPSCxFQUdqRixJQUFJSSxFQUFLVixPQUFPVyxPQUFPLE1BYXZCLEdBVkF4QixFQUFvQmlCLEVBQUVNLEdBSXRCVixPQUFPQyxlQUFlUyxFQUFJLFVBQVcsQ0FDbkNSLFlBQVksRUFDWkksTUFBT0EsSUFJRSxFQUFQRSxHQUE0QixpQkFBVEYsRUFBbUIsSUFBSyxJQUFJTSxLQUFPTixFQUN4RG5CLEVBQW9CUyxFQUFFYyxFQUFJRSxFQUFLLFNBQVVBLEdBQ3ZDLE9BQU9OLEVBQU1NLElBQ2JDLEtBQUssS0FBTUQsSUFJZixPQUFPRixHQVdUdkIsRUFBb0IyQixFQUFJLFNBQVV4QixHQUVoQyxJQUFJUSxFQUFTUixHQUFVQSxFQUFPbUIsV0FFOUIsV0FDRSxPQUFPbkIsRUFBZ0IsU0FHekIsV0FDRSxPQUFPQSxHQVFULE9BSkFILEVBQW9CUyxFQUFFRSxFQUFRLElBQUtBLEdBSTVCQSxHQVdUWCxFQUFvQlksRUFBSSxTQUFVZ0IsRUFBUUMsR0FDeEMsT0FBT2hCLE9BQU9oQixVQUFVaUMsZUFBZXhCLEtBQUtzQixFQUFRQyxJQVV0RDdCLEVBQW9CK0IsRUFBSSxHQVVqQi9CLEVBQW9CQSxFQUFvQmdDLEVBQUksR0F0UHJELENBNFBBLENBRUVDLGlDQVFBLFNBQVNDLHdCQUF3Qi9CLE9BQVFELFNBQ3ZDaUMsS0FBSywyZUFLUEMsNEJBUUEsU0FBU0Msb0JBQW9CbEMsT0FBUW1DLG9CQUFxQnRDLHFCQUd4RG1DLEtBQUssdWZBS1BJLGtCQVFBLFNBQVNDLFdBQVdyQyxPQUFRbUMsb0JBQXFCdEMscUJBRy9DbUMsS0FBSywrakJBS1BNLDJDQVFBLFNBQVNDLGtDQUFrQ3ZDLE9BQVFtQyxvQkFBcUJ0QyxxQkFHdEVtQyxLQUFLLG9wbERBS1BRLG1EQVFBLFNBQVNDLHdDQUF3Q3pDLE9BQVFtQyxvQkFBcUJ0QyxxQkFHNUVtQyxLQUFLLDhqSEFLUFUsZ0RBUUEsU0FBU0Msc0NBQXNDM0MsT0FBUW1DLG9CQUFxQnRDLHFCQUcxRW1DLEtBQUssNHcwUUFLUFksRUFRQSxTQUFTQyxFQUFFN0MsT0FBUUQsUUFBU0YscUJBQzFCbUMsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKioqKiovXG4oZnVuY3Rpb24gKG1vZHVsZXMpIHtcbiAgLy8gd2VicGFja0Jvb3RzdHJhcFxuXG4gIC8qKioqKiovXG4gIC8vIFRoZSBtb2R1bGUgY2FjaGVcblxuICAvKioqKioqL1xuICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cbiAgLyoqKioqKi9cblxuICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgLyoqKioqKi9cblxuICAgIC8qKioqKiovXG4gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cbiAgICAvKioqKioqL1xuICAgIGlmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuICAgICAgLyoqKioqKi9cbiAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi9cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXG4gICAgLyoqKioqKi9cblxuXG4gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuICAgICAgLyoqKioqKi9cbiAgICAgIGk6IG1vZHVsZUlkLFxuXG4gICAgICAvKioqKioqL1xuICAgICAgbDogZmFsc2UsXG5cbiAgICAgIC8qKioqKiovXG4gICAgICBleHBvcnRzOiB7fVxuICAgICAgLyoqKioqKi9cblxuICAgIH07XG4gICAgLyoqKioqKi9cblxuICAgIC8qKioqKiovXG4gICAgLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cbiAgICAvKioqKioqL1xuXG4gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cblxuICAgIC8qKioqKiovXG4gICAgLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXG4gICAgLyoqKioqKi9cblxuICAgIG1vZHVsZS5sID0gdHJ1ZTtcbiAgICAvKioqKioqL1xuXG4gICAgLyoqKioqKi9cbiAgICAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXG4gICAgLyoqKioqKi9cblxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAvKioqKioqL1xuICB9XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXG4gIC8qKioqKiovXG5cblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cbiAgLyoqKioqKi9cblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuXG4gIC8qKioqKiovXG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24gKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuICAgIC8qKioqKiovXG4gICAgaWYgKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiAgICAgIC8qKioqKiovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgICAvKioqKioqL1xuICAgIH1cbiAgICAvKioqKioqL1xuXG4gIH07XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuXG4gIC8qKioqKiovXG5cblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgIC8qKioqKiovXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgICAgLyoqKioqKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgdmFsdWU6ICdNb2R1bGUnXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqKioqKi9cbiAgfTtcbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcblxuICAvKioqKioqL1xuICAvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcblxuICAvKioqKioqL1xuICAvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcblxuICAvKioqKioqL1xuICAvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcblxuICAvKioqKioqL1xuICAvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgIC8qKioqKiovXG4gICAgaWYgKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuICAgIC8qKioqKiovXG5cbiAgICBpZiAobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiAgICAvKioqKioqL1xuXG4gICAgaWYgKG1vZGUgJiA0ICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gICAgLyoqKioqKi9cblxuICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqKioqKi9cblxuICAgIF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gICAgLyoqKioqKi9cblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICAvKioqKioqL1xuXG4gICAgaWYgKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgIH0uYmluZChudWxsLCBrZXkpKTtcbiAgICB9XG4gICAgLyoqKioqKi9cblxuICAgIHJldHVybiBucztcbiAgICAvKioqKioqL1xuICB9O1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKioqKioqL1xuICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuICAgIC8qKioqKiovXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTtcbiAgICB9IDpcbiAgICAvKioqKioqL1xuICAgIGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH07XG4gICAgLyoqKioqKi9cblxuICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiAgICAvKioqKioqL1xuXG5cbiAgICByZXR1cm4gZ2V0dGVyO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgfTtcbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXG4gIC8qKioqKiovXG5cblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cbiAgLyoqKioqKi9cblxuICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiAgLyoqKioqKi9cbn0pKFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqKioqKi9cbntcbiAgLyoqKi9cbiAgXCIuL2Rldi9qcy9Db21tb24vbW9iaWxlLW1lbnUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL2Rldi9qcy9Db21tb24vbW9iaWxlLW1lbnUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gZGV2SnNDb21tb25Nb2JpbGVNZW51SnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcImNvbnN0IHBhZ2VNYXAgPSB7XFxuICAnI2hvbWUnOiAnLmhlcm8nLFxcbiAgJyNhYm91dCc6ICcuYWJvdXQnLFxcbiAgJyNwb3J0Zm9saW8nOiAnLnBvcnRmb2xpbycsXFxuICAnI2Jsb2cnOiAnLmJsb2cnLFxcbiAgJyNjb250YWN0JzogJy5jb250YWN0JyxcXG59O1xcblxcbmNvbnN0IGhhbmRsZVBhZ2UgPSAoKSA9PiB7XFxuICBjb25zdCBwYWdlTmFtZSA9IHBhZ2VNYXBbd2luZG93LmxvY2F0aW9uLmhhc2hdO1xcbiAgaWYgKHBhZ2VOYW1lKSB7XFxuICAgIGNvbnN0IHBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhZ2VOYW1lKTtcXG4gICAgcGFnZS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcXG4gIH1cXG59O1xcblxcbmhhbmRsZVBhZ2UoKTtcXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGhhbmRsZVBhZ2UpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2Rldi9qcy9Db21tb24vbW9iaWxlLW1lbnUuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL2Rldi9qcy9Db21tb24vc3dpcGVyLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vZGV2L2pzL0NvbW1vbi9zd2lwZXIuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBubyBleHBvcnRzIHByb3ZpZGVkICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gZGV2SnNDb21tb25Td2lwZXJKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHN3aXBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3dpcGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zd2lwZXIvanMvc3dpcGVyLmVzbS5idW5kbGUuanNcXFwiKTtcXG5cXG5cXG5jb25zdCBjb21tb25Td2lwZXIgPSBuZXcgc3dpcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSgnLnN3aXBlciAuc3dpcGVyLWNvbnRhaW5lcicsIHtcXG4gIGxvb3A6IHRydWUsXFxuICBncmFiQ3Vyc29yOiB0cnVlLFxcbiAgbmF2aWdhdGlvbjoge1xcbiAgICBuZXh0RWw6ICcuc3dpcGVyX19idXR0b25fbmV4dCcsXFxuICAgIHByZXZFbDogJy5zd2lwZXJfX2J1dHRvbl9wcmV2JyxcXG4gIH0sXFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vZGV2L2pzL0NvbW1vbi9zd2lwZXIuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL2Rldi9qcy9hcHAuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL2Rldi9qcy9hcHAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBkZXZKc0FwcEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX0NvbW1vbl9zd2lwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ29tbW9uL3N3aXBlciAqLyBcXFwiLi9kZXYvanMvQ29tbW9uL3N3aXBlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfQ29tbW9uX21vYmlsZV9tZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0NvbW1vbi9tb2JpbGUtbWVudSAqLyBcXFwiLi9kZXYvanMvQ29tbW9uL21vYmlsZS1tZW51LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9Db21tb25fbW9iaWxlX21lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfQ29tbW9uX21vYmlsZV9tZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2Rldi9qcy9hcHAuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9kb203L2Rpc3QvZG9tNy5tb2R1bGFyLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2RvbTcvZGlzdC9kb203Lm1vZHVsYXIuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiAkLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsIGhhc0NsYXNzLCB0b2dnbGVDbGFzcywgYXR0ciwgcmVtb3ZlQXR0ciwgcHJvcCwgZGF0YSwgcmVtb3ZlRGF0YSwgZGF0YXNldCwgdmFsLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24sIG9uLCBvZmYsIG9uY2UsIHRyaWdnZXIsIHRyYW5zaXRpb25FbmQsIGFuaW1hdGlvbkVuZCwgd2lkdGgsIG91dGVyV2lkdGgsIGhlaWdodCwgb3V0ZXJIZWlnaHQsIG9mZnNldCwgaGlkZSwgc2hvdywgc3R5bGVzLCBjc3MsIHRvQXJyYXksIGVhY2gsIGZvckVhY2gsIGZpbHRlciwgbWFwLCBodG1sLCB0ZXh0LCBpcywgaW5kZXhPZiwgaW5kZXgsIGVxLCBhcHBlbmQsIGFwcGVuZFRvLCBwcmVwZW5kLCBwcmVwZW5kVG8sIGluc2VydEJlZm9yZSwgaW5zZXJ0QWZ0ZXIsIG5leHQsIG5leHRBbGwsIHByZXYsIHByZXZBbGwsIHNpYmxpbmdzLCBwYXJlbnQsIHBhcmVudHMsIGNsb3Nlc3QsIGZpbmQsIGNoaWxkcmVuLCByZW1vdmUsIGRldGFjaCwgYWRkLCBlbXB0eSwgc2Nyb2xsVG8sIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgYW5pbWF0ZSwgc3RvcCwgY2xpY2ssIGJsdXIsIGZvY3VzLCBmb2N1c2luLCBmb2N1c291dCwga2V5dXAsIGtleWRvd24sIGtleXByZXNzLCBzdWJtaXQsIGNoYW5nZSwgbW91c2Vkb3duLCBtb3VzZW1vdmUsIG1vdXNldXAsIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsIG1vdXNlb3V0LCBtb3VzZW92ZXIsIHRvdWNoc3RhcnQsIHRvdWNoZW5kLCB0b3VjaG1vdmUsIHJlc2l6ZSwgc2Nyb2xsICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzRG9tN0Rpc3REb203TW9kdWxhckpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCIkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZGRDbGFzc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWRkQ2xhc3M7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlbW92ZUNsYXNzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW1vdmVDbGFzczsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGFzQ2xhc3NcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhhc0NsYXNzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0b2dnbGVDbGFzc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9nZ2xlQ2xhc3M7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImF0dHJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF0dHI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlbW92ZUF0dHJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZUF0dHI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInByb3BcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByb3A7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRhdGFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGE7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlbW92ZURhdGFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZURhdGE7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRhdGFzZXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGFzZXQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInZhbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0cmFuc2Zvcm1cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRyYW5zZm9ybTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidHJhbnNpdGlvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJhbnNpdGlvbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9uOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJvZmZcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9mZjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib25jZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb25jZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidHJpZ2dlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJpZ2dlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidHJhbnNpdGlvbkVuZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJhbnNpdGlvbkVuZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYW5pbWF0aW9uRW5kXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbmltYXRpb25FbmQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIndpZHRoXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aWR0aDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib3V0ZXJXaWR0aFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3V0ZXJXaWR0aDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGVpZ2h0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoZWlnaHQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm91dGVySGVpZ2h0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvdXRlckhlaWdodDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib2Zmc2V0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvZmZzZXQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImhpZGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhpZGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNob3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3c7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0eWxlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc3R5bGVzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjc3NcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNzczsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidG9BcnJheVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9BcnJheTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZWFjaFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFjaDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZm9yRWFjaFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9yRWFjaDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZmlsdGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaWx0ZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1hcFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFwOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJodG1sXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBodG1sOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0ZXh0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0ZXh0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImluZGV4T2ZcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluZGV4T2Y7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImluZGV4XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmRleDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZXFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVxOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhcHBlbmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFwcGVuZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwZW5kVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFwcGVuZFRvOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwcmVwZW5kXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcmVwZW5kOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwcmVwZW5kVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByZXBlbmRUbzsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaW5zZXJ0QmVmb3JlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnNlcnRCZWZvcmU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImluc2VydEFmdGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnNlcnRBZnRlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibmV4dFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV4dDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibmV4dEFsbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV4dEFsbDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicHJldlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJldjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicHJldkFsbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJldkFsbDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2libGluZ3NcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNpYmxpbmdzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwYXJlbnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcmVudDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicGFyZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyZW50czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2xvc2VzdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xvc2VzdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZmluZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2hpbGRyZW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNoaWxkcmVuOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW1vdmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGV0YWNoXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZXRhY2g7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFkZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWRkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJlbXB0eVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZW1wdHk7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbFRvXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxUbzsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsVG9wXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxUb3A7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbExlZnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbExlZnQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFuaW1hdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFuaW1hdGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0b3BcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0b3A7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGljazsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYmx1clxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmx1cjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZvY3VzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJmb2N1c2luXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmb2N1c2luOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJmb2N1c291dFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9jdXNvdXQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImtleXVwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBrZXl1cDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5ZG93blxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4ga2V5ZG93bjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5cHJlc3NcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGtleXByZXNzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzdWJtaXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN1Ym1pdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2hhbmdlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjaGFuZ2U7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2Vkb3duOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb3VzZW1vdmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdXNlbW92ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW91c2V1cFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2V1cDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW91c2VlbnRlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2VlbnRlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW91c2VsZWF2ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2VsZWF2ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW91c2VvdXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdXNlb3V0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb3VzZW92ZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdXNlb3ZlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidG91Y2hzdGFydFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG91Y2hzdGFydDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidG91Y2hlbmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvdWNoZW5kOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0b3VjaG1vdmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvdWNobW92ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVzaXplXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZXNpemU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Nyb2xsOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyoqXFxuICogRG9tNyAyLjEuNVxcbiAqIE1pbmltYWxpc3RpYyBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIERPTSBtYW5pcHVsYXRpb24sIHdpdGggYSBqUXVlcnktY29tcGF0aWJsZSBBUElcXG4gKiBodHRwOi8vZnJhbWV3b3JrNy5pby9kb2NzL2RvbS5odG1sXFxuICpcXG4gKiBDb3B5cmlnaHQgMjAyMCwgVmxhZGltaXIgS2hhcmxhbXBpZGlcXG4gKiBUaGUgaURhbmdlcm8udXNcXG4gKiBodHRwOi8vd3d3LmlkYW5nZXJvLnVzL1xcbiAqXFxuICogTGljZW5zZWQgdW5kZXIgTUlUXFxuICpcXG4gKiBSZWxlYXNlZCBvbjogTWF5IDE1LCAyMDIwXFxuICovXFxuXFxuXFxuY2xhc3MgRG9tNyB7XFxuICBjb25zdHJ1Y3RvcihhcnIpIHtcXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XFxuICAgIC8vIENyZWF0ZSBhcnJheS1saWtlIG9iamVjdFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIHNlbGZbaV0gPSBhcnJbaV07XFxuICAgIH1cXG4gICAgc2VsZi5sZW5ndGggPSBhcnIubGVuZ3RoO1xcbiAgICAvLyBSZXR1cm4gY29sbGVjdGlvbiB3aXRoIG1ldGhvZHNcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcXG4gIGNvbnN0IGFyciA9IFtdO1xcbiAgbGV0IGkgPSAwO1xcbiAgaWYgKHNlbGVjdG9yICYmICFjb250ZXh0KSB7XFxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcXG4gICAgICByZXR1cm4gc2VsZWN0b3I7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIC8vIFN0cmluZ1xcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xcbiAgICAgIGxldCBlbHM7XFxuICAgICAgbGV0IHRlbXBQYXJlbnQ7XFxuICAgICAgY29uc3QgaHRtbCA9IHNlbGVjdG9yLnRyaW0oKTtcXG4gICAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XFxuICAgICAgICBsZXQgdG9DcmVhdGUgPSAnZGl2JztcXG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxsaScpID09PSAwKSB0b0NyZWF0ZSA9ICd1bCc7XFxuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dHInKSA9PT0gMCkgdG9DcmVhdGUgPSAndGJvZHknO1xcbiAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRkJykgPT09IDAgfHwgaHRtbC5pbmRleE9mKCc8dGgnKSA9PT0gMCkgdG9DcmVhdGUgPSAndHInO1xcbiAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRib2R5JykgPT09IDApIHRvQ3JlYXRlID0gJ3RhYmxlJztcXG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxvcHRpb24nKSA9PT0gMCkgdG9DcmVhdGUgPSAnc2VsZWN0JztcXG4gICAgICAgIHRlbXBQYXJlbnQgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRvY3VtZW50XFxcIl0uY3JlYXRlRWxlbWVudCh0b0NyZWF0ZSk7XFxuICAgICAgICB0ZW1wUGFyZW50LmlubmVySFRNTCA9IGh0bWw7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcFBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgIGFyci5wdXNoKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICghY29udGV4dCAmJiBzZWxlY3RvclswXSA9PT0gJyMnICYmICFzZWxlY3Rvci5tYXRjaCgvWyAuPD46fl0vKSkge1xcbiAgICAgICAgICAvLyBQdXJlIElEIHNlbGVjdG9yXFxuICAgICAgICAgIGVscyA9IFtzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRvY3VtZW50XFxcIl0uZ2V0RWxlbWVudEJ5SWQoc2VsZWN0b3IudHJpbSgpLnNwbGl0KCcjJylbMV0pXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIE90aGVyIHNlbGVjdG9yc1xcbiAgICAgICAgICBlbHMgPSAoY29udGV4dCB8fCBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRvY3VtZW50XFxcIl0pLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IudHJpbSgpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgICAgaWYgKGVsc1tpXSkgYXJyLnB1c2goZWxzW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUgfHwgc2VsZWN0b3IgPT09IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0gfHwgc2VsZWN0b3IgPT09IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZG9jdW1lbnRcXFwiXSkge1xcbiAgICAgIC8vIE5vZGUvZWxlbWVudFxcbiAgICAgIGFyci5wdXNoKHNlbGVjdG9yKTtcXG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5sZW5ndGggPiAwICYmIHNlbGVjdG9yWzBdLm5vZGVUeXBlKSB7XFxuICAgICAgLy8gQXJyYXkgb2YgZWxlbWVudHMgb3IgaW5zdGFuY2Ugb2YgRG9tXFxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9yLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICBhcnIucHVzaChzZWxlY3RvcltpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IERvbTcoYXJyKTtcXG59XFxuXFxuJC5mbiA9IERvbTcucHJvdG90eXBlO1xcbiQuQ2xhc3MgPSBEb203O1xcbiQuRG9tNyA9IERvbTc7XFxuXFxuZnVuY3Rpb24gdW5pcXVlKGFycikge1xcbiAgY29uc3QgdW5pcXVlQXJyYXkgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmICh1bmlxdWVBcnJheS5pbmRleE9mKGFycltpXSkgPT09IC0xKSB1bmlxdWVBcnJheS5wdXNoKGFycltpXSk7XFxuICB9XFxuICByZXR1cm4gdW5pcXVlQXJyYXk7XFxufVxcbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cmluZykge1xcbiAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgKG1hdGNoLCBncm91cDEpID0+IGdyb3VwMS50b1VwcGVyQ2FzZSgpKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XFxuICBpZiAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XFxuICBlbHNlIGlmIChzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0ud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcXG4gIHJldHVybiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XFxufVxcbmZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XFxuICBpZiAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS5jYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0uY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xcbiAgZWxzZSBpZiAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0ud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xcbiAgcmV0dXJuIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0uY2xlYXJUaW1lb3V0KGlkKTtcXG59XFxuXFxuLy8gQ2xhc3NlcyBhbmQgYXR0cmlidXRlc1xcbmZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzTmFtZSkge1xcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykgdGhpc1tqXS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59XFxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XFxuICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpc1tqXS5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB0aGlzW2pdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlc1tpXSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcXG4gIGlmICghdGhpc1swXSkgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuIHRoaXNbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XFxufVxcbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzTmFtZSkge1xcbiAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykgdGhpc1tqXS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzZXNbaV0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59XFxuZnVuY3Rpb24gYXR0cihhdHRycywgdmFsdWUpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcXG4gICAgLy8gR2V0IGF0dHJcXG4gICAgaWYgKHRoaXNbMF0pIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRycyk7XFxuICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICAvLyBTZXQgYXR0cnNcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xcbiAgICAgIC8vIFN0cmluZ1xcbiAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJzLCB2YWx1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gT2JqZWN0XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRycykge1xcbiAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XFxuICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5mdW5jdGlvbiByZW1vdmVBdHRyKGF0dHIpIHtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGlzW2ldLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5mdW5jdGlvbiBwcm9wKHByb3BzLCB2YWx1ZSkge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xcbiAgICAvLyBHZXQgcHJvcFxcbiAgICBpZiAodGhpc1swXSkgcmV0dXJuIHRoaXNbMF1bcHJvcHNdO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gU2V0IHByb3BzXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XFxuICAgICAgICAvLyBTdHJpbmdcXG4gICAgICAgIHRoaXNbaV1bcHJvcHNdID0gdmFsdWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIE9iamVjdFxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHByb3BzKSB7XFxuICAgICAgICAgIHRoaXNbaV1bcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG59XFxuZnVuY3Rpb24gZGF0YShrZXksIHZhbHVlKSB7XFxuICBsZXQgZWw7XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xcbiAgICBlbCA9IHRoaXNbMF07XFxuICAgIC8vIEdldCB2YWx1ZVxcbiAgICBpZiAoZWwpIHtcXG4gICAgICBpZiAoZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZSAmJiAoa2V5IGluIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UpKSB7XFxuICAgICAgICByZXR1cm4gZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBkYXRhS2V5ID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLSR7a2V5fWApO1xcbiAgICAgIGlmIChkYXRhS2V5KSB7XFxuICAgICAgICByZXR1cm4gZGF0YUtleTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgLy8gU2V0IHZhbHVlXFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgZWwgPSB0aGlzW2ldO1xcbiAgICBpZiAoIWVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UpIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UgPSB7fTtcXG4gICAgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldID0gdmFsdWU7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59XFxuZnVuY3Rpb24gcmVtb3ZlRGF0YShrZXkpIHtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBjb25zdCBlbCA9IHRoaXNbaV07XFxuICAgIGlmIChlbC5kb203RWxlbWVudERhdGFTdG9yYWdlICYmIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XSkge1xcbiAgICAgIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XSA9IG51bGw7XFxuICAgICAgZGVsZXRlIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XTtcXG4gICAgfVxcbiAgfVxcbn1cXG5mdW5jdGlvbiBkYXRhc2V0KCkge1xcbiAgY29uc3QgZWwgPSB0aGlzWzBdO1xcbiAgaWYgKCFlbCkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIGNvbnN0IGRhdGFzZXQgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgaWYgKGVsLmRhdGFzZXQpIHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgIGZvciAoY29uc3QgZGF0YUtleSBpbiBlbC5kYXRhc2V0KSB7XFxuICAgICAgZGF0YXNldFtkYXRhS2V5XSA9IGVsLmRhdGFzZXRbZGF0YUtleV07XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICAgIGNvbnN0IGF0dHIgPSBlbC5hdHRyaWJ1dGVzW2ldO1xcbiAgICAgIGlmIChhdHRyLm5hbWUuaW5kZXhPZignZGF0YS0nKSA+PSAwKSB7XFxuICAgICAgICBkYXRhc2V0W3RvQ2FtZWxDYXNlKGF0dHIubmFtZS5zcGxpdCgnZGF0YS0nKVsxXSldID0gYXR0ci52YWx1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgZm9yIChjb25zdCBrZXkgaW4gZGF0YXNldCkge1xcbiAgICBpZiAoZGF0YXNldFtrZXldID09PSAnZmFsc2UnKSBkYXRhc2V0W2tleV0gPSBmYWxzZTtcXG4gICAgZWxzZSBpZiAoZGF0YXNldFtrZXldID09PSAndHJ1ZScpIGRhdGFzZXRba2V5XSA9IHRydWU7XFxuICAgIGVsc2UgaWYgKHBhcnNlRmxvYXQoZGF0YXNldFtrZXldKSA9PT0gZGF0YXNldFtrZXldICogMSkgZGF0YXNldFtrZXldICo9IDE7XFxuICB9XFxuICByZXR1cm4gZGF0YXNldDtcXG59XFxuZnVuY3Rpb24gdmFsKHZhbHVlKSB7XFxuICBjb25zdCBkb20gPSB0aGlzO1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgaWYgKGRvbVswXSkge1xcbiAgICAgIGlmIChkb21bMF0ubXVsdGlwbGUgJiYgZG9tWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tWzBdLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICB2YWx1ZXMucHVzaChkb21bMF0uc2VsZWN0ZWRPcHRpb25zW2ldLnZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBkb21bMF0udmFsdWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIH1cXG5cXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGNvbnN0IGVsID0gZG9tW2ldO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgZWwubXVsdGlwbGUgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcpIHtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsLm9wdGlvbnMubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICAgIGVsLm9wdGlvbnNbal0uc2VsZWN0ZWQgPSB2YWx1ZS5pbmRleE9mKGVsLm9wdGlvbnNbal0udmFsdWUpID49IDA7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkb207XFxufVxcbi8vIFRyYW5zZm9ybXNcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5mdW5jdGlvbiB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZWxTdHlsZSA9IHRoaXNbaV0uc3R5bGU7XFxuICAgIGVsU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xcbiAgICBlbFN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiB0cmFuc2l0aW9uKGR1cmF0aW9uKSB7XFxuICBpZiAodHlwZW9mIGR1cmF0aW9uICE9PSAnc3RyaW5nJykge1xcbiAgICBkdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgfVxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGNvbnN0IGVsU3R5bGUgPSB0aGlzW2ldLnN0eWxlO1xcbiAgICBlbFN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xcbiAgICBlbFN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbi8vIEV2ZW50c1xcbmZ1bmN0aW9uIG9uKC4uLmFyZ3MpIHtcXG4gIGxldCBbZXZlbnRUeXBlLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcXG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBbZXZlbnRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xcbiAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcXG4gIH1cXG4gIGlmICghY2FwdHVyZSkgY2FwdHVyZSA9IGZhbHNlO1xcblxcbiAgZnVuY3Rpb24gaGFuZGxlTGl2ZUV2ZW50KGUpIHtcXG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XFxuICAgIGlmICghdGFyZ2V0KSByZXR1cm47XFxuICAgIGNvbnN0IGV2ZW50RGF0YSA9IGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW107XFxuICAgIGlmIChldmVudERhdGEuaW5kZXhPZihlKSA8IDApIHtcXG4gICAgICBldmVudERhdGEudW5zaGlmdChlKTtcXG4gICAgfVxcbiAgICBpZiAoJCh0YXJnZXQpLmlzKHRhcmdldFNlbGVjdG9yKSkgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBldmVudERhdGEpO1xcbiAgICBlbHNlIHtcXG4gICAgICBjb25zdCBwYXJlbnRzID0gJCh0YXJnZXQpLnBhcmVudHMoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGFyZW50cy5sZW5ndGg7IGsgKz0gMSkge1xcbiAgICAgICAgaWYgKCQocGFyZW50c1trXSkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseShwYXJlbnRzW2tdLCBldmVudERhdGEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSkge1xcbiAgICBjb25zdCBldmVudERhdGEgPSBlICYmIGUudGFyZ2V0ID8gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXSA6IFtdO1xcbiAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XFxuICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XFxuICAgIH1cXG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcXG4gIH1cXG4gIGNvbnN0IGV2ZW50cyA9IGV2ZW50VHlwZS5zcGxpdCgnICcpO1xcbiAgbGV0IGo7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZWwgPSB0aGlzW2ldO1xcbiAgICBpZiAoIXRhcmdldFNlbGVjdG9yKSB7XFxuICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbal07XFxuICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnMpIGVsLmRvbTdMaXN0ZW5lcnMgPSB7fTtcXG4gICAgICAgIGlmICghZWwuZG9tN0xpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdID0gW107XFxuICAgICAgICBlbC5kb203TGlzdGVuZXJzW2V2ZW50XS5wdXNoKHtcXG4gICAgICAgICAgbGlzdGVuZXIsXFxuICAgICAgICAgIHByb3h5TGlzdGVuZXI6IGhhbmRsZUV2ZW50LFxcbiAgICAgICAgfSk7XFxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgY2FwdHVyZSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIExpdmUgZXZlbnRzXFxuICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbal07XFxuICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzKSBlbC5kb203TGl2ZUxpc3RlbmVycyA9IHt9O1xcbiAgICAgICAgaWYgKCFlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xcbiAgICAgICAgZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdLnB1c2goe1xcbiAgICAgICAgICBsaXN0ZW5lcixcXG4gICAgICAgICAgcHJveHlMaXN0ZW5lcjogaGFuZGxlTGl2ZUV2ZW50LFxcbiAgICAgICAgfSk7XFxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVMaXZlRXZlbnQsIGNhcHR1cmUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIG9mZiguLi5hcmdzKSB7XFxuICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XFxuICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgW2V2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcXG4gICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuICB9XFxuICBpZiAoIWNhcHR1cmUpIGNhcHR1cmUgPSBmYWxzZTtcXG5cXG4gIGNvbnN0IGV2ZW50cyA9IGV2ZW50VHlwZS5zcGxpdCgnICcpO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIGNvbnN0IGVsID0gdGhpc1tqXTtcXG4gICAgICBsZXQgaGFuZGxlcnM7XFxuICAgICAgaWYgKCF0YXJnZXRTZWxlY3RvciAmJiBlbC5kb203TGlzdGVuZXJzKSB7XFxuICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdO1xcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIHtcXG4gICAgICAgIGhhbmRsZXJzID0gZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoKSB7XFxuICAgICAgICBmb3IgKGxldCBrID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrIC09IDEpIHtcXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW2tdO1xcbiAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcXG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIuZG9tN3Byb3h5ICYmIGhhbmRsZXIubGlzdGVuZXIuZG9tN3Byb3h5ID09PSBsaXN0ZW5lcikge1xcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIucHJveHlMaXN0ZW5lciwgY2FwdHVyZSk7XFxuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCFsaXN0ZW5lcikge1xcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIucHJveHlMaXN0ZW5lciwgY2FwdHVyZSk7XFxuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59XFxuZnVuY3Rpb24gb25jZSguLi5hcmdzKSB7XFxuICBjb25zdCBkb20gPSB0aGlzO1xcbiAgbGV0IFtldmVudE5hbWUsIHRhcmdldFNlbGVjdG9yLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIFtldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XFxuICAgIHRhcmdldFNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgfVxcbiAgZnVuY3Rpb24gb25jZUhhbmRsZXIoLi4uZXZlbnRBcmdzKSB7XFxuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGV2ZW50QXJncyk7XFxuICAgIGRvbS5vZmYoZXZlbnROYW1lLCB0YXJnZXRTZWxlY3Rvciwgb25jZUhhbmRsZXIsIGNhcHR1cmUpO1xcbiAgICBpZiAob25jZUhhbmRsZXIuZG9tN3Byb3h5KSB7XFxuICAgICAgZGVsZXRlIG9uY2VIYW5kbGVyLmRvbTdwcm94eTtcXG4gICAgfVxcbiAgfVxcbiAgb25jZUhhbmRsZXIuZG9tN3Byb3h5ID0gbGlzdGVuZXI7XFxuICByZXR1cm4gZG9tLm9uKGV2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIG9uY2VIYW5kbGVyLCBjYXB0dXJlKTtcXG59XFxuZnVuY3Rpb24gdHJpZ2dlciguLi5hcmdzKSB7XFxuICBjb25zdCBldmVudHMgPSBhcmdzWzBdLnNwbGl0KCcgJyk7XFxuICBjb25zdCBldmVudERhdGEgPSBhcmdzWzFdO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIGNvbnN0IGVsID0gdGhpc1tqXTtcXG4gICAgICBsZXQgZXZ0O1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBldnQgPSBuZXcgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS5DdXN0b21FdmVudChldmVudCwge1xcbiAgICAgICAgICBkZXRhaWw6IGV2ZW50RGF0YSxcXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGV2dCA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZG9jdW1lbnRcXFwiXS5jcmVhdGVFdmVudCgnRXZlbnQnKTtcXG4gICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xcbiAgICAgICAgZXZ0LmRldGFpbCA9IGV2ZW50RGF0YTtcXG4gICAgICB9XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IGFyZ3MuZmlsdGVyKChkYXRhLCBkYXRhSW5kZXgpID0+IGRhdGFJbmRleCA+IDApO1xcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcXG4gICAgICBlbC5kb203RXZlbnREYXRhID0gW107XFxuICAgICAgZGVsZXRlIGVsLmRvbTdFdmVudERhdGE7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGNhbGxiYWNrKSB7XFxuICBjb25zdCBldmVudHMgPSBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xcbiAgY29uc3QgZG9tID0gdGhpcztcXG4gIGxldCBpO1xcbiAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcXG4gICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXFxuICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgZG9tLm9mZihldmVudHNbaV0sIGZpcmVDYWxsQmFjayk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChjYWxsYmFjaykge1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgZG9tLm9uKGV2ZW50c1tpXSwgZmlyZUNhbGxCYWNrKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIGFuaW1hdGlvbkVuZChjYWxsYmFjaykge1xcbiAgY29uc3QgZXZlbnRzID0gWyd3ZWJraXRBbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uZW5kJ107XFxuICBjb25zdCBkb20gPSB0aGlzO1xcbiAgbGV0IGk7XFxuICBmdW5jdGlvbiBmaXJlQ2FsbEJhY2soZSkge1xcbiAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcXG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGRvbS5vZmYoZXZlbnRzW2ldLCBmaXJlQ2FsbEJhY2spO1xcbiAgICB9XFxuICB9XFxuICBpZiAoY2FsbGJhY2spIHtcXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGRvbS5vbihldmVudHNbaV0sIGZpcmVDYWxsQmFjayk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG4vLyBTaXppbmcvU3R5bGVzXFxuZnVuY3Rpb24gd2lkdGgoKSB7XFxuICBpZiAodGhpc1swXSA9PT0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXSkge1xcbiAgICByZXR1cm4gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS5pbm5lcldpZHRoO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNzcygnd2lkdGgnKSk7XFxuICB9XFxuXFxuICByZXR1cm4gbnVsbDtcXG59XFxuZnVuY3Rpb24gb3V0ZXJXaWR0aChpbmNsdWRlTWFyZ2lucykge1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xcbiAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGg7XFxuICB9XFxuICByZXR1cm4gbnVsbDtcXG59XFxuZnVuY3Rpb24gaGVpZ2h0KCkge1xcbiAgaWYgKHRoaXNbMF0gPT09IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0pIHtcXG4gICAgcmV0dXJuIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0uaW5uZXJIZWlnaHQ7XFxuICB9XFxuXFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuY3NzKCdoZWlnaHQnKSk7XFxuICB9XFxuXFxuICByZXR1cm4gbnVsbDtcXG59XFxuZnVuY3Rpb24gb3V0ZXJIZWlnaHQoaW5jbHVkZU1hcmdpbnMpIHtcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcXG4gICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQ7XFxuICB9XFxuICByZXR1cm4gbnVsbDtcXG59XFxuZnVuY3Rpb24gb2Zmc2V0KCkge1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICBjb25zdCBlbCA9IHRoaXNbMF07XFxuICAgIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICBjb25zdCBib2R5ID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkb2N1bWVudFxcXCJdLmJvZHk7XFxuICAgIGNvbnN0IGNsaWVudFRvcCA9IGVsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xcbiAgICBjb25zdCBjbGllbnRMZWZ0ID0gZWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcXG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gZWwgPT09IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0gPyBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XFxuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXSA/IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0uc2Nyb2xsWCA6IGVsLnNjcm9sbExlZnQ7XFxuICAgIHJldHVybiB7XFxuICAgICAgdG9wOiAoYm94LnRvcCArIHNjcm9sbFRvcCkgLSBjbGllbnRUb3AsXFxuICAgICAgbGVmdDogKGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCkgLSBjbGllbnRMZWZ0LFxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufVxcbmZ1bmN0aW9uIGhpZGUoKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIHNob3coKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZWwgPSB0aGlzW2ldO1xcbiAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XFxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xcbiAgICB9XFxuICAgIGlmIChzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XFxuICAgICAgLy8gU3RpbGwgbm90IHZpc2libGVcXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIHN0eWxlcygpIHtcXG4gIGlmICh0aGlzWzBdKSByZXR1cm4gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXS5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpO1xcbiAgcmV0dXJuIHt9O1xcbn1cXG5mdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XFxuICBsZXQgaTtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XFxuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wcyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xcbiAgICAgICAgICB0aGlzW2ldLnN0eWxlW3Byb3BdID0gcHJvcHNbcHJvcF07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XFxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgdGhpc1tpXS5zdHlsZVtwcm9wc10gPSB2YWx1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5cXG4vLyBEb20gbWFuaXB1bGF0aW9uXFxuZnVuY3Rpb24gdG9BcnJheSgpIHtcXG4gIGNvbnN0IGFyciA9IFtdO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGFyci5wdXNoKHRoaXNbaV0pO1xcbiAgfVxcbiAgcmV0dXJuIGFycjtcXG59XFxuLy8gSXRlcmF0ZSBvdmVyIHRoZSBjb2xsZWN0aW9uIHBhc3NpbmcgZWxlbWVudHMgdG8gYGNhbGxiYWNrYFxcbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcXG4gIC8vIERvbid0IGJvdGhlciBjb250aW51aW5nIHdpdGhvdXQgYSBjYWxsYmFja1xcbiAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XFxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgY29sbGVjdGlvblxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIC8vIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXFxuICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNbaV0sIGksIHRoaXNbaV0pID09PSBmYWxzZSkge1xcbiAgICAgIC8vIEVuZCB0aGUgbG9vcCBlYXJseVxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9XFxuICAvLyBSZXR1cm4gYHRoaXNgIHRvIGFsbG93IGNoYWluZWQgRE9NIG9wZXJhdGlvbnNcXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrKSB7XFxuICAvLyBEb24ndCBib3RoZXIgY29udGludWluZyB3aXRob3V0IGEgY2FsbGJhY2tcXG4gIGlmICghY2FsbGJhY2spIHJldHVybiB0aGlzO1xcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IGNvbGxlY3Rpb25cXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAvLyBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxcbiAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzW2ldLCB0aGlzW2ldLCBpKSA9PT0gZmFsc2UpIHtcXG4gICAgICAvLyBFbmQgdGhlIGxvb3AgZWFybHlcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcbiAgfVxcbiAgLy8gUmV0dXJuIGB0aGlzYCB0byBhbGxvdyBjaGFpbmVkIERPTSBvcGVyYXRpb25zXFxuICByZXR1cm4gdGhpcztcXG59XFxuZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrKSB7XFxuICBjb25zdCBtYXRjaGVkSXRlbXMgPSBbXTtcXG4gIGNvbnN0IGRvbSA9IHRoaXM7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAoY2FsbGJhY2suY2FsbChkb21baV0sIGksIGRvbVtpXSkpIG1hdGNoZWRJdGVtcy5wdXNoKGRvbVtpXSk7XFxuICB9XFxuICByZXR1cm4gbmV3IERvbTcobWF0Y2hlZEl0ZW1zKTtcXG59XFxuZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XFxuICBjb25zdCBtb2RpZmllZEl0ZW1zID0gW107XFxuICBjb25zdCBkb20gPSB0aGlzO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgbW9kaWZpZWRJdGVtcy5wdXNoKGNhbGxiYWNrLmNhbGwoZG9tW2ldLCBpLCBkb21baV0pKTtcXG4gIH1cXG4gIHJldHVybiBuZXcgRG9tNyhtb2RpZmllZEl0ZW1zKTtcXG59XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuZnVuY3Rpb24gaHRtbChodG1sKSB7XFxuICBpZiAodHlwZW9mIGh0bWwgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgdGhpc1tpXS5pbm5lckhUTUwgPSBodG1sO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbmZ1bmN0aW9uIHRleHQodGV4dCkge1xcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJykge1xcbiAgICBpZiAodGhpc1swXSkge1xcbiAgICAgIHJldHVybiB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKTtcXG4gICAgfVxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gdGV4dDtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiBpcyhzZWxlY3Rvcikge1xcbiAgY29uc3QgZWwgPSB0aGlzWzBdO1xcbiAgbGV0IGNvbXBhcmVXaXRoO1xcbiAgbGV0IGk7XFxuICBpZiAoIWVsIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XFxuICAgIGlmIChlbC5tYXRjaGVzKSByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XFxuICAgIGVsc2UgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XFxuICAgIGVsc2UgaWYgKGVsLm1zTWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xcblxcbiAgICBjb21wYXJlV2l0aCA9ICQoc2VsZWN0b3IpO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGFyZVdpdGgubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRvY3VtZW50XFxcIl0pIHJldHVybiBlbCA9PT0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkb2N1bWVudFxcXCJdO1xcbiAgZWxzZSBpZiAoc2VsZWN0b3IgPT09IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwid2luZG93XFxcIl0pIHJldHVybiBlbCA9PT0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3aW5kb3dcXFwiXTtcXG5cXG4gIGlmIChzZWxlY3Rvci5ub2RlVHlwZSB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcXG4gICAgY29tcGFyZVdpdGggPSBzZWxlY3Rvci5ub2RlVHlwZSA/IFtzZWxlY3Rvcl0gOiBzZWxlY3RvcjtcXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBhcmVXaXRoLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKGNvbXBhcmVXaXRoW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5mdW5jdGlvbiBpbmRleE9mKGVsKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKHRoaXNbaV0gPT09IGVsKSByZXR1cm4gaTtcXG4gIH1cXG4gIHJldHVybiAtMTtcXG59XFxuZnVuY3Rpb24gaW5kZXgoKSB7XFxuICBsZXQgY2hpbGQgPSB0aGlzWzBdO1xcbiAgbGV0IGk7XFxuICBpZiAoY2hpbGQpIHtcXG4gICAgaSA9IDA7XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICB3aGlsZSAoKGNoaWxkID0gY2hpbGQucHJldmlvdXNTaWJsaW5nKSAhPT0gbnVsbCkge1xcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgaSArPSAxO1xcbiAgICB9XFxuICAgIHJldHVybiBpO1xcbiAgfVxcbiAgcmV0dXJuIHVuZGVmaW5lZDtcXG59XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuZnVuY3Rpb24gZXEoaW5kZXgpIHtcXG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcztcXG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xcbiAgbGV0IHJldHVybkluZGV4O1xcbiAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xcbiAgICByZXR1cm4gbmV3IERvbTcoW10pO1xcbiAgfVxcbiAgaWYgKGluZGV4IDwgMCkge1xcbiAgICByZXR1cm5JbmRleCA9IGxlbmd0aCArIGluZGV4O1xcbiAgICBpZiAocmV0dXJuSW5kZXggPCAwKSByZXR1cm4gbmV3IERvbTcoW10pO1xcbiAgICByZXR1cm4gbmV3IERvbTcoW3RoaXNbcmV0dXJuSW5kZXhdXSk7XFxuICB9XFxuICByZXR1cm4gbmV3IERvbTcoW3RoaXNbaW5kZXhdXSk7XFxufVxcbmZ1bmN0aW9uIGFwcGVuZCguLi5hcmdzKSB7XFxuICBsZXQgbmV3Q2hpbGQ7XFxuXFxuICBmb3IgKGxldCBrID0gMDsgayA8IGFyZ3MubGVuZ3RoOyBrICs9IDEpIHtcXG4gICAgbmV3Q2hpbGQgPSBhcmdzW2tdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZG9jdW1lbnRcXFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gbmV3Q2hpbGQ7XFxuICAgICAgICB3aGlsZSAodGVtcERpdi5maXJzdENoaWxkKSB7XFxuICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKG5ld0NoaWxkW2pdKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuZnVuY3Rpb24gYXBwZW5kVG8ocGFyZW50KSB7XFxuICAkKHBhcmVudCkuYXBwZW5kKHRoaXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIHByZXBlbmQobmV3Q2hpbGQpIHtcXG4gIGxldCBpO1xcbiAgbGV0IGo7XFxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xcbiAgICAgIGNvbnN0IHRlbXBEaXYgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRvY3VtZW50XFxcIl0uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcXG4gICAgICBmb3IgKGogPSB0ZW1wRGl2LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcXG4gICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKHRlbXBEaXYuY2hpbGROb2Rlc1tqXSwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb203KSB7XFxuICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0NoaWxkLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZShuZXdDaGlsZFtqXSwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn1cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5mdW5jdGlvbiBwcmVwZW5kVG8ocGFyZW50KSB7XFxuICAkKHBhcmVudCkucHJlcGVuZCh0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn1cXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUoc2VsZWN0b3IpIHtcXG4gIGNvbnN0IGJlZm9yZSA9ICQoc2VsZWN0b3IpO1xcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmIChiZWZvcmUubGVuZ3RoID09PSAxKSB7XFxuICAgICAgYmVmb3JlWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGJlZm9yZVswXSk7XFxuICAgIH0gZWxzZSBpZiAoYmVmb3JlLmxlbmd0aCA+IDEpIHtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJlZm9yZS5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgYmVmb3JlW2pdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXNbaV0uY2xvbmVOb2RlKHRydWUpLCBiZWZvcmVbal0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihzZWxlY3Rvcikge1xcbiAgY29uc3QgYWZ0ZXIgPSAkKHNlbGVjdG9yKTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBpZiAoYWZ0ZXIubGVuZ3RoID09PSAxKSB7XFxuICAgICAgYWZ0ZXJbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXSwgYWZ0ZXJbMF0ubmV4dFNpYmxpbmcpO1xcbiAgICB9IGVsc2UgaWYgKGFmdGVyLmxlbmd0aCA+IDEpIHtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFmdGVyLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgICBhZnRlcltqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYWZ0ZXJbal0ubmV4dFNpYmxpbmcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5mdW5jdGlvbiBuZXh0KHNlbGVjdG9yKSB7XFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIGlmICh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyAmJiAkKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiBuZXcgRG9tNyhbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG5ldyBEb203KFtdKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpIHJldHVybiBuZXcgRG9tNyhbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcXG4gICAgcmV0dXJuIG5ldyBEb203KFtdKTtcXG4gIH1cXG4gIHJldHVybiBuZXcgRG9tNyhbXSk7XFxufVxcbmZ1bmN0aW9uIG5leHRBbGwoc2VsZWN0b3IpIHtcXG4gIGNvbnN0IG5leHRFbHMgPSBbXTtcXG4gIGxldCBlbCA9IHRoaXNbMF07XFxuICBpZiAoIWVsKSByZXR1cm4gbmV3IERvbTcoW10pO1xcbiAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xcbiAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIGlmICgkKG5leHQpLmlzKHNlbGVjdG9yKSkgbmV4dEVscy5wdXNoKG5leHQpO1xcbiAgICB9IGVsc2UgbmV4dEVscy5wdXNoKG5leHQpO1xcbiAgICBlbCA9IG5leHQ7XFxuICB9XFxuICByZXR1cm4gbmV3IERvbTcobmV4dEVscyk7XFxufVxcbmZ1bmN0aW9uIHByZXYoc2VsZWN0b3IpIHtcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgY29uc3QgZWwgPSB0aGlzWzBdO1xcbiAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZyAmJiAkKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBEb203KFtlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHJldHVybiBuZXcgRG9tNyhbZWwucHJldmlvdXNFbGVtZW50U2libGluZ10pO1xcbiAgICByZXR1cm4gbmV3IERvbTcoW10pO1xcbiAgfVxcbiAgcmV0dXJuIG5ldyBEb203KFtdKTtcXG59XFxuZnVuY3Rpb24gcHJldkFsbChzZWxlY3Rvcikge1xcbiAgY29uc3QgcHJldkVscyA9IFtdO1xcbiAgbGV0IGVsID0gdGhpc1swXTtcXG4gIGlmICghZWwpIHJldHVybiBuZXcgRG9tNyhbXSk7XFxuICB3aGlsZSAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICBpZiAoJChwcmV2KS5pcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcXG4gICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcXG4gICAgZWwgPSBwcmV2O1xcbiAgfVxcbiAgcmV0dXJuIG5ldyBEb203KHByZXZFbHMpO1xcbn1cXG5mdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xcbiAgcmV0dXJuIHRoaXMubmV4dEFsbChzZWxlY3RvcikuYWRkKHRoaXMucHJldkFsbChzZWxlY3RvcikpO1xcbn1cXG5mdW5jdGlvbiBwYXJlbnQoc2VsZWN0b3IpIHtcXG4gIGNvbnN0IHBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmICh0aGlzW2ldLnBhcmVudE5vZGUgIT09IG51bGwpIHtcXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICAgIGlmICgkKHRoaXNbaV0ucGFyZW50Tm9kZSkuaXMoc2VsZWN0b3IpKSBwYXJlbnRzLnB1c2godGhpc1tpXS5wYXJlbnROb2RlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gJCh1bmlxdWUocGFyZW50cykpO1xcbn1cXG5mdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XFxuICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBsZXQgcGFyZW50ID0gdGhpc1tpXS5wYXJlbnROb2RlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuICAgIHdoaWxlIChwYXJlbnQpIHtcXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICAgIGlmICgkKHBhcmVudCkuaXMoc2VsZWN0b3IpKSBwYXJlbnRzLnB1c2gocGFyZW50KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XFxuICAgICAgfVxcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gJCh1bmlxdWUocGFyZW50cykpO1xcbn1cXG5mdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XFxuICBsZXQgY2xvc2VzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XFxuICB9XFxuICBpZiAoIWNsb3Nlc3QuaXMoc2VsZWN0b3IpKSB7XFxuICAgIGNsb3Nlc3QgPSBjbG9zZXN0LnBhcmVudHMoc2VsZWN0b3IpLmVxKDApO1xcbiAgfVxcbiAgcmV0dXJuIGNsb3Nlc3Q7XFxufVxcbmZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcXG4gIGNvbnN0IGZvdW5kRWxlbWVudHMgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICBmb3VuZEVsZW1lbnRzLnB1c2goZm91bmRbal0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IERvbTcoZm91bmRFbGVtZW50cyk7XFxufVxcbmZ1bmN0aW9uIGNoaWxkcmVuKHNlbGVjdG9yKSB7XFxuICBjb25zdCBjaGlsZHJlbiA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXNbaV0uY2hpbGROb2RlcztcXG5cXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XFxuICAgICAgaWYgKCFzZWxlY3Rvcikge1xcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEpIGNoaWxkcmVuLnB1c2goY2hpbGROb2Rlc1tqXSk7XFxuICAgICAgfSBlbHNlIGlmIChjaGlsZE5vZGVzW2pdLm5vZGVUeXBlID09PSAxICYmICQoY2hpbGROb2Rlc1tqXSkuaXMoc2VsZWN0b3IpKSB7XFxuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkTm9kZXNbal0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5ldyBEb203KHVuaXF1ZShjaGlsZHJlbikpO1xcbn1cXG5mdW5jdGlvbiByZW1vdmUoKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKHRoaXNbaV0ucGFyZW50Tm9kZSkgdGhpc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXNbaV0pO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufVxcbmZ1bmN0aW9uIGRldGFjaCgpIHtcXG4gIHJldHVybiB0aGlzLnJlbW92ZSgpO1xcbn1cXG5mdW5jdGlvbiBhZGQoLi4uYXJncykge1xcbiAgY29uc3QgZG9tID0gdGhpcztcXG4gIGxldCBpO1xcbiAgbGV0IGo7XFxuICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBjb25zdCB0b0FkZCA9ICQoYXJnc1tpXSk7XFxuICAgIGZvciAoaiA9IDA7IGogPCB0b0FkZC5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgIGRvbVtkb20ubGVuZ3RoXSA9IHRvQWRkW2pdO1xcbiAgICAgIGRvbS5sZW5ndGggKz0gMTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRvbTtcXG59XFxuZnVuY3Rpb24gZW1wdHkoKSB7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgZWwgPSB0aGlzW2ldO1xcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsLmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcXG4gICAgICAgIGlmIChlbC5jaGlsZE5vZGVzW2pdLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgZWwuY2hpbGROb2Rlc1tqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLmNoaWxkTm9kZXNbal0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBlbC50ZXh0Q29udGVudCA9ICcnO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59XFxuXFxuZnVuY3Rpb24gc2Nyb2xsVG8oLi4uYXJncykge1xcbiAgbGV0IFtsZWZ0LCB0b3AsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXSA9IGFyZ3M7XFxuICBpZiAoYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYWxsYmFjayA9IGVhc2luZztcXG4gICAgW2xlZnQsIHRvcCwgZHVyYXRpb24sIGNhbGxiYWNrLCBlYXNpbmddID0gYXJncztcXG4gIH1cXG4gIGlmICh0eXBlb2YgZWFzaW5nID09PSAndW5kZWZpbmVkJykgZWFzaW5nID0gJ3N3aW5nJztcXG5cXG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gYW5pbWF0ZSgpIHtcXG4gICAgY29uc3QgZWwgPSB0aGlzO1xcbiAgICBsZXQgY3VycmVudFRvcDtcXG4gICAgbGV0IGN1cnJlbnRMZWZ0O1xcbiAgICBsZXQgbWF4VG9wO1xcbiAgICBsZXQgbWF4TGVmdDtcXG4gICAgbGV0IG5ld1RvcDtcXG4gICAgbGV0IG5ld0xlZnQ7XFxuICAgIGxldCBzY3JvbGxUb3A7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG4gICAgbGV0IHNjcm9sbExlZnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG4gICAgbGV0IGFuaW1hdGVUb3AgPSB0b3AgPiAwIHx8IHRvcCA9PT0gMDtcXG4gICAgbGV0IGFuaW1hdGVMZWZ0ID0gbGVmdCA+IDAgfHwgbGVmdCA9PT0gMDtcXG4gICAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgZWFzaW5nID0gJ3N3aW5nJztcXG4gICAgfVxcbiAgICBpZiAoYW5pbWF0ZVRvcCkge1xcbiAgICAgIGN1cnJlbnRUb3AgPSBlbC5zY3JvbGxUb3A7XFxuICAgICAgaWYgKCFkdXJhdGlvbikge1xcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gdG9wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoYW5pbWF0ZUxlZnQpIHtcXG4gICAgICBjdXJyZW50TGVmdCA9IGVsLnNjcm9sbExlZnQ7XFxuICAgICAgaWYgKCFkdXJhdGlvbikge1xcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghZHVyYXRpb24pIHJldHVybjtcXG4gICAgaWYgKGFuaW1hdGVUb3ApIHtcXG4gICAgICBtYXhUb3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5vZmZzZXRIZWlnaHQ7XFxuICAgICAgbmV3VG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCBtYXhUb3ApLCAwKTtcXG4gICAgfVxcbiAgICBpZiAoYW5pbWF0ZUxlZnQpIHtcXG4gICAgICBtYXhMZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5vZmZzZXRXaWR0aDtcXG4gICAgICBuZXdMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4obGVmdCwgbWF4TGVmdCksIDApO1xcbiAgICB9XFxuICAgIGxldCBzdGFydFRpbWUgPSBudWxsO1xcbiAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPT09IGN1cnJlbnRUb3ApIGFuaW1hdGVUb3AgPSBmYWxzZTtcXG4gICAgaWYgKGFuaW1hdGVMZWZ0ICYmIG5ld0xlZnQgPT09IGN1cnJlbnRMZWZ0KSBhbmltYXRlTGVmdCA9IGZhbHNlO1xcbiAgICBmdW5jdGlvbiByZW5kZXIodGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XFxuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbiwgMSksIDApO1xcbiAgICAgIGNvbnN0IGVhc2VQcm9ncmVzcyA9IGVhc2luZyA9PT0gJ2xpbmVhcicgPyBwcm9ncmVzcyA6ICgwLjUgLSAoTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDIpKTtcXG4gICAgICBsZXQgZG9uZTtcXG4gICAgICBpZiAoYW5pbWF0ZVRvcCkgc2Nyb2xsVG9wID0gY3VycmVudFRvcCArIChlYXNlUHJvZ3Jlc3MgKiAobmV3VG9wIC0gY3VycmVudFRvcCkpO1xcbiAgICAgIGlmIChhbmltYXRlTGVmdCkgc2Nyb2xsTGVmdCA9IGN1cnJlbnRMZWZ0ICsgKGVhc2VQcm9ncmVzcyAqIChuZXdMZWZ0IC0gY3VycmVudExlZnQpKTtcXG4gICAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPiBjdXJyZW50VG9wICYmIHNjcm9sbFRvcCA+PSBuZXdUb3ApIHtcXG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcXG4gICAgICAgIGRvbmUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoYW5pbWF0ZVRvcCAmJiBuZXdUb3AgPCBjdXJyZW50VG9wICYmIHNjcm9sbFRvcCA8PSBuZXdUb3ApIHtcXG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcXG4gICAgICAgIGRvbmUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoYW5pbWF0ZUxlZnQgJiYgbmV3TGVmdCA+IGN1cnJlbnRMZWZ0ICYmIHNjcm9sbExlZnQgPj0gbmV3TGVmdCkge1xcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IG5ld0xlZnQ7XFxuICAgICAgICBkb25lID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGFuaW1hdGVMZWZ0ICYmIG5ld0xlZnQgPCBjdXJyZW50TGVmdCAmJiBzY3JvbGxMZWZ0IDw9IG5ld0xlZnQpIHtcXG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xcbiAgICAgICAgZG9uZSA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkb25lKSB7XFxuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmIChhbmltYXRlVG9wKSBlbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XFxuICAgICAgaWYgKGFuaW1hdGVMZWZ0KSBlbC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcXG4gICAgfVxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcXG4gIH0pO1xcbn1cXG4vLyBzY3JvbGxUb3AodG9wLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjaykge1xcbmZ1bmN0aW9uIHNjcm9sbFRvcCguLi5hcmdzKSB7XFxuICBsZXQgW3RvcCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2tdID0gYXJncztcXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIFt0b3AsIGR1cmF0aW9uLCBjYWxsYmFjaywgZWFzaW5nXSA9IGFyZ3M7XFxuICB9XFxuICBjb25zdCBkb20gPSB0aGlzO1xcbiAgaWYgKHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGlmIChkb20ubGVuZ3RoID4gMCkgcmV0dXJuIGRvbVswXS5zY3JvbGxUb3A7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcbiAgcmV0dXJuIGRvbS5zY3JvbGxUbyh1bmRlZmluZWQsIHRvcCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spO1xcbn1cXG5mdW5jdGlvbiBzY3JvbGxMZWZ0KC4uLmFyZ3MpIHtcXG4gIGxldCBbbGVmdCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2tdID0gYXJncztcXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIFtsZWZ0LCBkdXJhdGlvbiwgY2FsbGJhY2ssIGVhc2luZ10gPSBhcmdzO1xcbiAgfVxcbiAgY29uc3QgZG9tID0gdGhpcztcXG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgaWYgKGRvbS5sZW5ndGggPiAwKSByZXR1cm4gZG9tWzBdLnNjcm9sbExlZnQ7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcbiAgcmV0dXJuIGRvbS5zY3JvbGxUbyhsZWZ0LCB1bmRlZmluZWQsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrKTtcXG59XFxuXFxuZnVuY3Rpb24gYW5pbWF0ZShpbml0aWFsUHJvcHMsIGluaXRpYWxQYXJhbXMpIHtcXG4gIGNvbnN0IGVscyA9IHRoaXM7XFxuICBjb25zdCBhID0ge1xcbiAgICBwcm9wczogT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFByb3BzKSxcXG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHtcXG4gICAgICBkdXJhdGlvbjogMzAwLFxcbiAgICAgIGVhc2luZzogJ3N3aW5nJywgLy8gb3IgJ2xpbmVhcidcXG4gICAgICAvKiBDYWxsYmFja3NcXG4gICAgICBiZWdpbihlbGVtZW50cylcXG4gICAgICBjb21wbGV0ZShlbGVtZW50cylcXG4gICAgICBwcm9ncmVzcyhlbGVtZW50cywgY29tcGxldGUsIHJlbWFpbmluZywgc3RhcnQsIHR3ZWVuVmFsdWUpXFxuICAgICAgKi9cXG4gICAgfSwgaW5pdGlhbFBhcmFtcyksXFxuXFxuICAgIGVsZW1lbnRzOiBlbHMsXFxuICAgIGFuaW1hdGluZzogZmFsc2UsXFxuICAgIHF1ZTogW10sXFxuXFxuICAgIGVhc2luZ1Byb2dyZXNzKGVhc2luZywgcHJvZ3Jlc3MpIHtcXG4gICAgICBpZiAoZWFzaW5nID09PSAnc3dpbmcnKSB7XFxuICAgICAgICByZXR1cm4gMC41IC0gKE1hdGguY29zKHByb2dyZXNzICogTWF0aC5QSSkgLyAyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBlYXNpbmcocHJvZ3Jlc3MpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XFxuICAgIH0sXFxuICAgIHN0b3AoKSB7XFxuICAgICAgaWYgKGEuZnJhbWVJZCkge1xcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYS5mcmFtZUlkKTtcXG4gICAgICB9XFxuICAgICAgYS5hbmltYXRpbmcgPSBmYWxzZTtcXG4gICAgICBhLmVsZW1lbnRzLmVhY2goKGluZGV4LCBlbCkgPT4ge1xcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsO1xcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZG9tN0FuaW1hdGVJbnN0YW5jZTtcXG4gICAgICB9KTtcXG4gICAgICBhLnF1ZSA9IFtdO1xcbiAgICB9LFxcbiAgICBkb25lKGNvbXBsZXRlKSB7XFxuICAgICAgYS5hbmltYXRpbmcgPSBmYWxzZTtcXG4gICAgICBhLmVsZW1lbnRzLmVhY2goKGluZGV4LCBlbCkgPT4ge1xcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsO1xcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuZG9tN0FuaW1hdGVJbnN0YW5jZTtcXG4gICAgICB9KTtcXG4gICAgICBpZiAoY29tcGxldGUpIGNvbXBsZXRlKGVscyk7XFxuICAgICAgaWYgKGEucXVlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbnN0IHF1ZSA9IGEucXVlLnNoaWZ0KCk7XFxuICAgICAgICBhLmFuaW1hdGUocXVlWzBdLCBxdWVbMV0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgYW5pbWF0ZShwcm9wcywgcGFyYW1zKSB7XFxuICAgICAgaWYgKGEuYW5pbWF0aW5nKSB7XFxuICAgICAgICBhLnF1ZS5wdXNoKFtwcm9wcywgcGFyYW1zXSk7XFxuICAgICAgICByZXR1cm4gYTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcXG5cXG4gICAgICAvLyBEZWZpbmUgJiBDYWNoZSBJbml0aWFscyAmIFVuaXRzXFxuICAgICAgYS5lbGVtZW50cy5lYWNoKChpbmRleCwgZWwpID0+IHtcXG4gICAgICAgIGxldCBpbml0aWFsRnVsbFZhbHVlO1xcbiAgICAgICAgbGV0IGluaXRpYWxWYWx1ZTtcXG4gICAgICAgIGxldCB1bml0O1xcbiAgICAgICAgbGV0IGZpbmFsVmFsdWU7XFxuICAgICAgICBsZXQgZmluYWxGdWxsVmFsdWU7XFxuXFxuICAgICAgICBpZiAoIWVsLmRvbTdBbmltYXRlSW5zdGFuY2UpIGEuZWxlbWVudHNbaW5kZXhdLmRvbTdBbmltYXRlSW5zdGFuY2UgPSBhO1xcblxcbiAgICAgICAgZWxlbWVudHNbaW5kZXhdID0ge1xcbiAgICAgICAgICBjb250YWluZXI6IGVsLFxcbiAgICAgICAgfTtcXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChwcm9wKSA9PiB7XFxuICAgICAgICAgIGluaXRpYWxGdWxsVmFsdWUgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndpbmRvd1xcXCJdLmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCkucmVwbGFjZSgnLCcsICcuJyk7XFxuICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHBhcnNlRmxvYXQoaW5pdGlhbEZ1bGxWYWx1ZSk7XFxuICAgICAgICAgIHVuaXQgPSBpbml0aWFsRnVsbFZhbHVlLnJlcGxhY2UoaW5pdGlhbFZhbHVlLCAnJyk7XFxuICAgICAgICAgIGZpbmFsVmFsdWUgPSBwYXJzZUZsb2F0KHByb3BzW3Byb3BdKTtcXG4gICAgICAgICAgZmluYWxGdWxsVmFsdWUgPSBwcm9wc1twcm9wXSArIHVuaXQ7XFxuICAgICAgICAgIGVsZW1lbnRzW2luZGV4XVtwcm9wXSA9IHtcXG4gICAgICAgICAgICBpbml0aWFsRnVsbFZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSxcXG4gICAgICAgICAgICB1bml0LFxcbiAgICAgICAgICAgIGZpbmFsVmFsdWUsXFxuICAgICAgICAgICAgZmluYWxGdWxsVmFsdWUsXFxuICAgICAgICAgICAgY3VycmVudFZhbHVlOiBpbml0aWFsVmFsdWUsXFxuICAgICAgICAgIH07XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcXG4gICAgICBsZXQgdGltZTtcXG4gICAgICBsZXQgZWxlbWVudHNEb25lID0gMDtcXG4gICAgICBsZXQgcHJvcHNEb25lID0gMDtcXG4gICAgICBsZXQgZG9uZTtcXG4gICAgICBsZXQgYmVnYW4gPSBmYWxzZTtcXG5cXG4gICAgICBhLmFuaW1hdGluZyA9IHRydWU7XFxuXFxuICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xcbiAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgbGV0IHByb2dyZXNzO1xcbiAgICAgICAgbGV0IGVhc2VQcm9ncmVzcztcXG4gICAgICAgIC8vIGxldCBlbDtcXG4gICAgICAgIGlmICghYmVnYW4pIHtcXG4gICAgICAgICAgYmVnYW4gPSB0cnVlO1xcbiAgICAgICAgICBpZiAocGFyYW1zLmJlZ2luKSBwYXJhbXMuYmVnaW4oZWxzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcXG4gICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXJhbXMucHJvZ3Jlc3MpIHtcXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgICAgIHBhcmFtcy5wcm9ncmVzcyhlbHMsIE1hdGgubWF4KE1hdGgubWluKCh0aW1lIC0gc3RhcnRUaW1lKSAvIHBhcmFtcy5kdXJhdGlvbiwgMSksIDApLCAoKHN0YXJ0VGltZSArIHBhcmFtcy5kdXJhdGlvbikgLSB0aW1lIDwgMCA/IDAgOiAoc3RhcnRUaW1lICsgcGFyYW1zLmR1cmF0aW9uKSAtIHRpbWUpLCBzdGFydFRpbWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xcbiAgICAgICAgICBjb25zdCBlbCA9IGVsZW1lbnQ7XFxuICAgICAgICAgIGlmIChkb25lIHx8IGVsLmRvbmUpIHJldHVybjtcXG4gICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goKHByb3ApID0+IHtcXG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBlbC5kb25lKSByZXR1cm47XFxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBwYXJhbXMuZHVyYXRpb24sIDEpLCAwKTtcXG4gICAgICAgICAgICBlYXNlUHJvZ3Jlc3MgPSBhLmVhc2luZ1Byb2dyZXNzKHBhcmFtcy5lYXNpbmcsIHByb2dyZXNzKTtcXG4gICAgICAgICAgICBjb25zdCB7IGluaXRpYWxWYWx1ZSwgZmluYWxWYWx1ZSwgdW5pdCB9ID0gZWxbcHJvcF07XFxuICAgICAgICAgICAgZWxbcHJvcF0uY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlICsgKGVhc2VQcm9ncmVzcyAqIChmaW5hbFZhbHVlIC0gaW5pdGlhbFZhbHVlKSk7XFxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gZWxbcHJvcF0uY3VycmVudFZhbHVlO1xcblxcbiAgICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICAgIChmaW5hbFZhbHVlID4gaW5pdGlhbFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA+PSBmaW5hbFZhbHVlKSB8fFxcbiAgICAgICAgICAgICAgKGZpbmFsVmFsdWUgPCBpbml0aWFsVmFsdWUgJiYgY3VycmVudFZhbHVlIDw9IGZpbmFsVmFsdWUpKSB7XFxuICAgICAgICAgICAgICBlbC5jb250YWluZXIuc3R5bGVbcHJvcF0gPSBmaW5hbFZhbHVlICsgdW5pdDtcXG4gICAgICAgICAgICAgIHByb3BzRG9uZSArPSAxO1xcbiAgICAgICAgICAgICAgaWYgKHByb3BzRG9uZSA9PT0gT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBlbC5kb25lID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgZWxlbWVudHNEb25lICs9IDE7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNEb25lID09PSBlbGVtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChkb25lKSB7XFxuICAgICAgICAgICAgICBhLmRvbmUocGFyYW1zLmNvbXBsZXRlKTtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWwuY29udGFpbmVyLnN0eWxlW3Byb3BdID0gY3VycmVudFZhbHVlICsgdW5pdDtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XFxuICAgICAgICAvLyBUaGVuIGNhbGxcXG4gICAgICAgIGEuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xcbiAgICAgIH1cXG4gICAgICBhLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcXG4gICAgICByZXR1cm4gYTtcXG4gICAgfSxcXG4gIH07XFxuXFxuICBpZiAoYS5lbGVtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgcmV0dXJuIGVscztcXG4gIH1cXG5cXG4gIGxldCBhbmltYXRlSW5zdGFuY2U7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgaWYgKGEuZWxlbWVudHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZSkge1xcbiAgICAgIGFuaW1hdGVJbnN0YW5jZSA9IGEuZWxlbWVudHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZTtcXG4gICAgfSBlbHNlIGEuZWxlbWVudHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZSA9IGE7XFxuICB9XFxuICBpZiAoIWFuaW1hdGVJbnN0YW5jZSkge1xcbiAgICBhbmltYXRlSW5zdGFuY2UgPSBhO1xcbiAgfVxcblxcbiAgaWYgKGluaXRpYWxQcm9wcyA9PT0gJ3N0b3AnKSB7XFxuICAgIGFuaW1hdGVJbnN0YW5jZS5zdG9wKCk7XFxuICB9IGVsc2Uge1xcbiAgICBhbmltYXRlSW5zdGFuY2UuYW5pbWF0ZShhLnByb3BzLCBhLnBhcmFtcyk7XFxuICB9XFxuXFxuICByZXR1cm4gZWxzO1xcbn1cXG5cXG5mdW5jdGlvbiBzdG9wKCkge1xcbiAgY29uc3QgZWxzID0gdGhpcztcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmIChlbHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZSkge1xcbiAgICAgIGVsc1tpXS5kb203QW5pbWF0ZUluc3RhbmNlLnN0b3AoKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5jb25zdCBub1RyaWdnZXIgPSAoJ3Jlc2l6ZSBzY3JvbGwnKS5zcGxpdCgnICcpO1xcbmZ1bmN0aW9uIGV2ZW50U2hvcnRjdXQobmFtZSwgLi4uYXJncykge1xcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAndW5kZWZpbmVkJykge1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAobm9UcmlnZ2VyLmluZGV4T2YobmFtZSkgPCAwKSB7XFxuICAgICAgICBpZiAobmFtZSBpbiB0aGlzW2ldKSB0aGlzW2ldW25hbWVdKCk7XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgJCh0aGlzW2ldKS50cmlnZ2VyKG5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIHJldHVybiB0aGlzLm9uKG5hbWUsIC4uLmFyZ3MpO1xcbn1cXG5cXG5mdW5jdGlvbiBjbGljayguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdjbGljaycsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBibHVyKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2JsdXInLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gZm9jdXMoLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnZm9jdXMnLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gZm9jdXNpbiguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdmb2N1c2luJywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIGZvY3Vzb3V0KC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2ZvY3Vzb3V0JywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIGtleXVwKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2tleXVwJywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIGtleWRvd24oLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgna2V5ZG93bicsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBrZXlwcmVzcyguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdrZXlwcmVzcycsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBzdWJtaXQoLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnc3VibWl0JywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIGNoYW5nZSguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdjaGFuZ2UnLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gbW91c2Vkb3duKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlZG93bicsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBtb3VzZW1vdmUoLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2Vtb3ZlJywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIG1vdXNldXAoLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2V1cCcsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBtb3VzZWVudGVyKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlZW50ZXInLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gbW91c2VsZWF2ZSguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZWxlYXZlJywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIG1vdXNlb3V0KC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlb3V0JywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIG1vdXNlb3ZlciguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZW92ZXInLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gdG91Y2hzdGFydCguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCd0b3VjaHN0YXJ0JywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIHRvdWNoZW5kKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3RvdWNoZW5kJywgLi4uYXJncyk7XFxufVxcbmZ1bmN0aW9uIHRvdWNobW92ZSguLi5hcmdzKSB7XFxuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCd0b3VjaG1vdmUnLCAuLi5hcmdzKTtcXG59XFxuZnVuY3Rpb24gcmVzaXplKC4uLmFyZ3MpIHtcXG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3Jlc2l6ZScsIC4uLmFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBzY3JvbGwoLi4uYXJncykge1xcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnc2Nyb2xsJywgLi4uYXJncyk7XFxufVxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb203L2Rpc3QvZG9tNy5tb2R1bGFyLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkb2N1bWVudCwgZXh0ZW5kLCB3aW5kb3cgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTc3JXaW5kb3dEaXN0U3NyV2luZG93RXNtSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRvY3VtZW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkb2M7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV4dGVuZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXh0ZW5kOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ3aW5kb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpbjsgfSk7XFxuLyoqXFxuICogU1NSIFdpbmRvdyAyLjAuMFxcbiAqIEJldHRlciBoYW5kbGluZyBmb3Igd2luZG93IG9iamVjdCBpbiBTU1IgZW52aXJvbm1lbnRcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcXG4gKlxcbiAqIENvcHlyaWdodCAyMDIwLCBWbGFkaW1pciBLaGFybGFtcGlkaVxcbiAqXFxuICogTGljZW5zZWQgdW5kZXIgTUlUXFxuICpcXG4gKiBSZWxlYXNlZCBvbjogTWF5IDEyLCAyMDIwXFxuICovXFxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcXG4gICAgcmV0dXJuIChvYmogIT09IG51bGwgJiZcXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXFxuICAgICAgICAnY29uc3RydWN0b3InIGluIG9iaiAmJlxcbiAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xcbn1cXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzcmMpIHtcXG4gICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IHt9OyB9XFxuICAgIGlmIChzcmMgPT09IHZvaWQgMCkgeyBzcmMgPSB7fTsgfVxcbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpXFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNyY1trZXldKSAmJlxcbiAgICAgICAgICAgIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJlxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNyY1trZXldKS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgZXh0ZW5kKHRhcmdldFtrZXldLCBzcmNba2V5XSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5cXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XFxudmFyIHNzckRvY3VtZW50ID0ge1xcbiAgICBib2R5OiB7fSxcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIGFjdGl2ZUVsZW1lbnQ6IHtcXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIG5vZGVOYW1lOiAnJyxcXG4gICAgfSxcXG4gICAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0sXFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgfSxcXG4gICAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9LFxcbiAgICBjcmVhdGVFdmVudDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBpbml0RXZlbnQ6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxcbiAgICAgICAgICAgIHN0eWxlOiB7fSxcXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgICAgICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIGNyZWF0ZUVsZW1lbnROUzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICB9LFxcbiAgICBpbXBvcnROb2RlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSxcXG4gICAgbG9jYXRpb246IHtcXG4gICAgICAgIGhhc2g6ICcnLFxcbiAgICAgICAgaG9zdDogJycsXFxuICAgICAgICBob3N0bmFtZTogJycsXFxuICAgICAgICBocmVmOiAnJyxcXG4gICAgICAgIG9yaWdpbjogJycsXFxuICAgICAgICBwYXRobmFtZTogJycsXFxuICAgICAgICBwcm90b2NvbDogJycsXFxuICAgICAgICBzZWFyY2g6ICcnLFxcbiAgICB9LFxcbn07XFxuZXh0ZW5kKGRvYywgc3NyRG9jdW1lbnQpO1xcblxcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xcbnZhciBzc3JXaW5kb3cgPSB7XFxuICAgIGRvY3VtZW50OiBzc3JEb2N1bWVudCxcXG4gICAgbmF2aWdhdG9yOiB7XFxuICAgICAgICB1c2VyQWdlbnQ6ICcnLFxcbiAgICB9LFxcbiAgICBsb2NhdGlvbjoge1xcbiAgICAgICAgaGFzaDogJycsXFxuICAgICAgICBob3N0OiAnJyxcXG4gICAgICAgIGhvc3RuYW1lOiAnJyxcXG4gICAgICAgIGhyZWY6ICcnLFxcbiAgICAgICAgb3JpZ2luOiAnJyxcXG4gICAgICAgIHBhdGhuYW1lOiAnJyxcXG4gICAgICAgIHByb3RvY29sOiAnJyxcXG4gICAgICAgIHNlYXJjaDogJycsXFxuICAgIH0sXFxuICAgIGhpc3Rvcnk6IHtcXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgICAgICBnbzogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICAgICAgYmFjazogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICB9LFxcbiAgICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIGdldENvbXB1dGVkU3R5bGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIEltYWdlOiBmdW5jdGlvbiAoKSB7IH0sXFxuICAgIERhdGU6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgc2NyZWVuOiB7fSxcXG4gICAgc2V0VGltZW91dDogZnVuY3Rpb24gKCkgeyB9LFxcbiAgICBjbGVhclRpbWVvdXQ6IGZ1bmN0aW9uICgpIHsgfSxcXG4gICAgbWF0Y2hNZWRpYTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICB9LFxcbn07XFxuZXh0ZW5kKHdpbiwgc3NyV2luZG93KTtcXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvc3dpcGVyL2pzL3N3aXBlci5lc20uYnVuZGxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc3dpcGVyL2pzL3N3aXBlci5lc20uYnVuZGxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU3dpcGVySnNTd2lwZXJFc21CdW5kbGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGRvbTcvZGlzdC9kb203Lm1vZHVsYXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2RvbTcvZGlzdC9kb203Lm1vZHVsYXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc3NyLXdpbmRvdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzXFxcIik7XFxuLyoqXFxuICogU3dpcGVyIDUuNC41XFxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcXG4gKiBodHRwOi8vc3dpcGVyanMuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDIwIFZsYWRpbWlyIEtoYXJsYW1waWRpXFxuICpcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcXG4gKlxcbiAqIFJlbGVhc2VkIG9uOiBKdW5lIDE2LCAyMDIwXFxuICovXFxuXFxuXFxuXFxuXFxuY29uc3QgTWV0aG9kcyA9IHtcXG4gIGFkZENsYXNzOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImFkZENsYXNzXFxcIl0sXFxuICByZW1vdmVDbGFzczogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZW1vdmVDbGFzc1xcXCJdLFxcbiAgaGFzQ2xhc3M6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiaGFzQ2xhc3NcXFwiXSxcXG4gIHRvZ2dsZUNsYXNzOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvZ2dsZUNsYXNzXFxcIl0sXFxuICBhdHRyOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImF0dHJcXFwiXSxcXG4gIHJlbW92ZUF0dHI6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVtb3ZlQXR0clxcXCJdLFxcbiAgZGF0YTogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkYXRhXFxcIl0sXFxuICB0cmFuc2Zvcm06IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidHJhbnNmb3JtXFxcIl0sXFxuICB0cmFuc2l0aW9uOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRyYW5zaXRpb25cXFwiXSxcXG4gIG9uOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm9uXFxcIl0sXFxuICBvZmY6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwib2ZmXFxcIl0sXFxuICB0cmlnZ2VyOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRyaWdnZXJcXFwiXSxcXG4gIHRyYW5zaXRpb25FbmQ6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidHJhbnNpdGlvbkVuZFxcXCJdLFxcbiAgb3V0ZXJXaWR0aDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJvdXRlcldpZHRoXFxcIl0sXFxuICBvdXRlckhlaWdodDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJvdXRlckhlaWdodFxcXCJdLFxcbiAgb2Zmc2V0OiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm9mZnNldFxcXCJdLFxcbiAgY3NzOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImNzc1xcXCJdLFxcbiAgZWFjaDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJlYWNoXFxcIl0sXFxuICBodG1sOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImh0bWxcXFwiXSxcXG4gIHRleHQ6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidGV4dFxcXCJdLFxcbiAgaXM6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiaXNcXFwiXSxcXG4gIGluZGV4OiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImluZGV4XFxcIl0sXFxuICBlcTogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJlcVxcXCJdLFxcbiAgYXBwZW5kOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImFwcGVuZFxcXCJdLFxcbiAgcHJlcGVuZDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwcmVwZW5kXFxcIl0sXFxuICBuZXh0OiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm5leHRcXFwiXSxcXG4gIG5leHRBbGw6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibmV4dEFsbFxcXCJdLFxcbiAgcHJldjogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwcmV2XFxcIl0sXFxuICBwcmV2QWxsOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInByZXZBbGxcXFwiXSxcXG4gIHBhcmVudDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwYXJlbnRcXFwiXSxcXG4gIHBhcmVudHM6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicGFyZW50c1xcXCJdLFxcbiAgY2xvc2VzdDogZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJjbG9zZXN0XFxcIl0sXFxuICBmaW5kOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImZpbmRcXFwiXSxcXG4gIGNoaWxkcmVuOiBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImNoaWxkcmVuXFxcIl0sXFxuICBmaWx0ZXI6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZmlsdGVyXFxcIl0sXFxuICByZW1vdmU6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVtb3ZlXFxcIl0sXFxuICBhZGQ6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYWRkXFxcIl0sXFxuICBzdHlsZXM6IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3R5bGVzXFxcIl0sXFxufTtcXG5cXG5PYmplY3Qua2V5cyhNZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XFxuICBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXS5mblttZXRob2ROYW1lXSA9IGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdLmZuW21ldGhvZE5hbWVdIHx8IE1ldGhvZHNbbWV0aG9kTmFtZV07XFxufSk7XFxuXFxuY29uc3QgVXRpbHMgPSB7XFxuICBkZWxldGVQcm9wcyhvYmopIHtcXG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBvYmplY3Rba2V5XSA9IG51bGw7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8gbm8gZ2V0dGVyIGZvciBvYmplY3RcXG4gICAgICB9XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAvLyBzb21ldGhpbmcgZ290IHdyb25nXFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0sXFxuICBuZXh0VGljayhjYWxsYmFjaywgZGVsYXkgPSAwKSB7XFxuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XFxuICB9LFxcbiAgbm93KCkge1xcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcXG4gIH0sXFxuICBnZXRUcmFuc2xhdGUoZWwsIGF4aXMgPSAneCcpIHtcXG4gICAgbGV0IG1hdHJpeDtcXG4gICAgbGV0IGN1clRyYW5zZm9ybTtcXG4gICAgbGV0IHRyYW5zZm9ybU1hdHJpeDtcXG5cXG4gICAgY29uc3QgY3VyU3R5bGUgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xcblxcbiAgICBpZiAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5XZWJLaXRDU1NNYXRyaXgpIHtcXG4gICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUud2Via2l0VHJhbnNmb3JtO1xcbiAgICAgIGlmIChjdXJUcmFuc2Zvcm0uc3BsaXQoJywnKS5sZW5ndGggPiA2KSB7XFxuICAgICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJUcmFuc2Zvcm0uc3BsaXQoJywgJykubWFwKChhKSA9PiBhLnJlcGxhY2UoJywnLCAnLicpKS5qb2luKCcsICcpO1xcbiAgICAgIH1cXG4gICAgICAvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBXZWJraXQgY2hva2Ugd2hlbiAnbm9uZScgaXMgcGFzc2VkOyBwYXNzXFxuICAgICAgLy8gZW1wdHkgc3RyaW5nIGluc3RlYWQgaW4gdGhpcyBjYXNlXFxuICAgICAgdHJhbnNmb3JtTWF0cml4ID0gbmV3IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uV2ViS2l0Q1NTTWF0cml4KGN1clRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBjdXJUcmFuc2Zvcm0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGN1clN0eWxlLk1velRyYW5zZm9ybSB8fCBjdXJTdHlsZS5PVHJhbnNmb3JtIHx8IGN1clN0eWxlLk1zVHJhbnNmb3JtIHx8IGN1clN0eWxlLm1zVHJhbnNmb3JtIHx8IGN1clN0eWxlLnRyYW5zZm9ybSB8fCBjdXJTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKCd0cmFuc2xhdGUoJywgJ21hdHJpeCgxLCAwLCAwLCAxLCcpO1xcbiAgICAgIG1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeC50b1N0cmluZygpLnNwbGl0KCcsJyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGF4aXMgPT09ICd4Jykge1xcbiAgICAgIC8vIExhdGVzdCBDaHJvbWUgYW5kIHdlYmtpdHMgRml4XFxuICAgICAgaWYgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQxO1xcbiAgICAgIC8vIENyYXp5IElFMTAgTWF0cml4XFxuICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7XFxuICAgICAgLy8gTm9ybWFsIEJyb3dzZXJzXFxuICAgICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs0XSk7XFxuICAgIH1cXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xcbiAgICAgIC8vIExhdGVzdCBDaHJvbWUgYW5kIHdlYmtpdHMgRml4XFxuICAgICAgaWYgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQyO1xcbiAgICAgIC8vIENyYXp5IElFMTAgTWF0cml4XFxuICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEzXSk7XFxuICAgICAgLy8gTm9ybWFsIEJyb3dzZXJzXFxuICAgICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs1XSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGN1clRyYW5zZm9ybSB8fCAwO1xcbiAgfSxcXG4gIHBhcnNlVXJsUXVlcnkodXJsKSB7XFxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XFxuICAgIGxldCB1cmxUb1BhcnNlID0gdXJsIHx8IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubG9jYXRpb24uaHJlZjtcXG4gICAgbGV0IGk7XFxuICAgIGxldCBwYXJhbXM7XFxuICAgIGxldCBwYXJhbTtcXG4gICAgbGV0IGxlbmd0aDtcXG4gICAgaWYgKHR5cGVvZiB1cmxUb1BhcnNlID09PSAnc3RyaW5nJyAmJiB1cmxUb1BhcnNlLmxlbmd0aCkge1xcbiAgICAgIHVybFRvUGFyc2UgPSB1cmxUb1BhcnNlLmluZGV4T2YoJz8nKSA+IC0xID8gdXJsVG9QYXJzZS5yZXBsYWNlKC9cXFxcUypcXFxcPy8sICcnKSA6ICcnO1xcbiAgICAgIHBhcmFtcyA9IHVybFRvUGFyc2Uuc3BsaXQoJyYnKS5maWx0ZXIoKHBhcmFtc1BhcnQpID0+IHBhcmFtc1BhcnQgIT09ICcnKTtcXG4gICAgICBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xcblxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV0ucmVwbGFjZSgvI1xcXFxTKy9nLCAnJykuc3BsaXQoJz0nKTtcXG4gICAgICAgIHF1ZXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYXJhbVswXSldID0gdHlwZW9mIHBhcmFtWzFdID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbVsxXSkgfHwgJyc7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBxdWVyeTtcXG4gIH0sXFxuICBpc09iamVjdChvKSB7XFxuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLmNvbnN0cnVjdG9yICYmIG8uY29uc3RydWN0b3IgPT09IE9iamVjdDtcXG4gIH0sXFxuICBleHRlbmQoLi4uYXJncykge1xcbiAgICBjb25zdCB0byA9IE9iamVjdChhcmdzWzBdKTtcXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3NbaV07XFxuICAgICAgaWYgKG5leHRTb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBuZXh0U291cmNlICE9PSBudWxsKSB7XFxuICAgICAgICBjb25zdCBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xcbiAgICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xcbiAgICAgICAgICBjb25zdCBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XFxuICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xcbiAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xcbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdCh0b1tuZXh0S2V5XSkgJiYgVXRpbHMuaXNPYmplY3QobmV4dFNvdXJjZVtuZXh0S2V5XSkpIHtcXG4gICAgICAgICAgICAgIFV0aWxzLmV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICghVXRpbHMuaXNPYmplY3QodG9bbmV4dEtleV0pICYmIFV0aWxzLmlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XFxuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IHt9O1xcbiAgICAgICAgICAgICAgVXRpbHMuZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdG87XFxuICB9LFxcbn07XFxuXFxuY29uc3QgU3VwcG9ydCA9IChmdW5jdGlvbiBTdXBwb3J0KCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdG91Y2g6ICEhKCgnb250b3VjaHN0YXJ0JyBpbiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdKSB8fCAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5Eb2N1bWVudFRvdWNoICYmIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXSBpbnN0YW5jZW9mIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uRG9jdW1lbnRUb3VjaCkpLFxcblxcbiAgICBwb2ludGVyRXZlbnRzOiAhIXNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uUG9pbnRlckV2ZW50ICYmICgnbWF4VG91Y2hQb2ludHMnIGluIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yKSAmJiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+PSAwLFxcblxcbiAgICBvYnNlcnZlcjogKGZ1bmN0aW9uIGNoZWNrT2JzZXJ2ZXIoKSB7XFxuICAgICAgcmV0dXJuICgnTXV0YXRpb25PYnNlcnZlcicgaW4gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXSB8fCAnV2Via2l0TXV0YXRpb25PYnNlcnZlcicgaW4gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXSk7XFxuICAgIH0oKSksXFxuXFxuICAgIHBhc3NpdmVMaXN0ZW5lcjogKGZ1bmN0aW9uIGNoZWNrUGFzc2l2ZUxpc3RlbmVyKCkge1xcbiAgICAgIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICAgICAgICBnZXQoKSB7XFxuICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUxpc3RlbmVyJywgbnVsbCwgb3B0cyk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8gTm8gc3VwcG9ydFxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xcbiAgICB9KCkpLFxcblxcbiAgICBnZXN0dXJlczogKGZ1bmN0aW9uIGNoZWNrR2VzdHVyZXMoKSB7XFxuICAgICAgcmV0dXJuICdvbmdlc3R1cmVzdGFydCcgaW4gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXTtcXG4gICAgfSgpKSxcXG4gIH07XFxufSgpKTtcXG5cXG5jbGFzcyBTd2lwZXJDbGFzcyB7XFxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xcbiAgICBjb25zdCBzZWxmID0gdGhpcztcXG4gICAgc2VsZi5wYXJhbXMgPSBwYXJhbXM7XFxuXFxuICAgIC8vIEV2ZW50c1xcbiAgICBzZWxmLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xcblxcbiAgICBpZiAoc2VsZi5wYXJhbXMgJiYgc2VsZi5wYXJhbXMub24pIHtcXG4gICAgICBPYmplY3Qua2V5cyhzZWxmLnBhcmFtcy5vbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XFxuICAgICAgICBzZWxmLm9uKGV2ZW50TmFtZSwgc2VsZi5wYXJhbXMub25bZXZlbnROYW1lXSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XFxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XFxuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKChldmVudCkgPT4ge1xcbiAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0gPSBbXTtcXG4gICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF1bbWV0aG9kXShoYW5kbGVyKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBzZWxmO1xcbiAgfVxcblxcbiAgb25jZShldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xcbiAgICBmdW5jdGlvbiBvbmNlSGFuZGxlciguLi5hcmdzKSB7XFxuICAgICAgc2VsZi5vZmYoZXZlbnRzLCBvbmNlSGFuZGxlcik7XFxuICAgICAgaWYgKG9uY2VIYW5kbGVyLmY3cHJveHkpIHtcXG4gICAgICAgIGRlbGV0ZSBvbmNlSGFuZGxlci5mN3Byb3h5O1xcbiAgICAgIH1cXG4gICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xcbiAgICB9XFxuICAgIG9uY2VIYW5kbGVyLmY3cHJveHkgPSBoYW5kbGVyO1xcbiAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XFxuICB9XFxuXFxuICBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcXG4gICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaCgoZXZlbnQpID0+IHtcXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0gPSBbXTtcXG4gICAgICB9IGVsc2UgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSAmJiBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0ubGVuZ3RoKSB7XFxuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xcbiAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyID09PSBoYW5kbGVyIHx8IChldmVudEhhbmRsZXIuZjdwcm94eSAmJiBldmVudEhhbmRsZXIuZjdwcm94eSA9PT0gaGFuZGxlcikpIHtcXG4gICAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9XFxuXFxuICBlbWl0KC4uLmFyZ3MpIHtcXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XFxuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xcbiAgICBsZXQgZXZlbnRzO1xcbiAgICBsZXQgZGF0YTtcXG4gICAgbGV0IGNvbnRleHQ7XFxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XFxuICAgICAgZGF0YSA9IGFyZ3Muc2xpY2UoMSwgYXJncy5sZW5ndGgpO1xcbiAgICAgIGNvbnRleHQgPSBzZWxmO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF0uZXZlbnRzO1xcbiAgICAgIGRhdGEgPSBhcmdzWzBdLmRhdGE7XFxuICAgICAgY29udGV4dCA9IGFyZ3NbMF0uY29udGV4dCB8fCBzZWxmO1xcbiAgICB9XFxuICAgIGNvbnN0IGV2ZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KCcgJyk7XFxuICAgIGV2ZW50c0FycmF5LmZvckVhY2goKGV2ZW50KSA9PiB7XFxuICAgICAgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzICYmIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcXG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKChldmVudEhhbmRsZXIpID0+IHtcXG4gICAgICAgICAgaGFuZGxlcnMucHVzaChldmVudEhhbmRsZXIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChldmVudEhhbmRsZXIpID0+IHtcXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIHNlbGY7XFxuICB9XFxuXFxuICB1c2VNb2R1bGVzUGFyYW1zKGluc3RhbmNlUGFyYW1zKSB7XFxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcXG4gICAgaWYgKCFpbnN0YW5jZS5tb2R1bGVzKSByZXR1cm47XFxuICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm1vZHVsZXMpLmZvckVhY2goKG1vZHVsZU5hbWUpID0+IHtcXG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0YW5jZS5tb2R1bGVzW21vZHVsZU5hbWVdO1xcbiAgICAgIC8vIEV4dGVuZCBwYXJhbXNcXG4gICAgICBpZiAobW9kdWxlLnBhcmFtcykge1xcbiAgICAgICAgVXRpbHMuZXh0ZW5kKGluc3RhbmNlUGFyYW1zLCBtb2R1bGUucGFyYW1zKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgdXNlTW9kdWxlcyhtb2R1bGVzUGFyYW1zID0ge30pIHtcXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xcbiAgICBpZiAoIWluc3RhbmNlLm1vZHVsZXMpIHJldHVybjtcXG4gICAgT2JqZWN0LmtleXMoaW5zdGFuY2UubW9kdWxlcykuZm9yRWFjaCgobW9kdWxlTmFtZSkgPT4ge1xcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RhbmNlLm1vZHVsZXNbbW9kdWxlTmFtZV07XFxuICAgICAgY29uc3QgbW9kdWxlUGFyYW1zID0gbW9kdWxlc1BhcmFtc1ttb2R1bGVOYW1lXSB8fCB7fTtcXG4gICAgICAvLyBFeHRlbmQgaW5zdGFuY2UgbWV0aG9kcyBhbmQgcHJvcHNcXG4gICAgICBpZiAobW9kdWxlLmluc3RhbmNlKSB7XFxuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGUuaW5zdGFuY2UpLmZvckVhY2goKG1vZHVsZVByb3BOYW1lKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IG1vZHVsZVByb3AgPSBtb2R1bGUuaW5zdGFuY2VbbW9kdWxlUHJvcE5hbWVdO1xcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVByb3AgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBpbnN0YW5jZVttb2R1bGVQcm9wTmFtZV0gPSBtb2R1bGVQcm9wLmJpbmQoaW5zdGFuY2UpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGluc3RhbmNlW21vZHVsZVByb3BOYW1lXSA9IG1vZHVsZVByb3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXFxuICAgICAgaWYgKG1vZHVsZS5vbiAmJiBpbnN0YW5jZS5vbikge1xcbiAgICAgICAgT2JqZWN0LmtleXMobW9kdWxlLm9uKS5mb3JFYWNoKChtb2R1bGVFdmVudE5hbWUpID0+IHtcXG4gICAgICAgICAgaW5zdGFuY2Uub24obW9kdWxlRXZlbnROYW1lLCBtb2R1bGUub25bbW9kdWxlRXZlbnROYW1lXSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gTW9kdWxlIGNyZWF0ZSBjYWxsYmFja1xcbiAgICAgIGlmIChtb2R1bGUuY3JlYXRlKSB7XFxuICAgICAgICBtb2R1bGUuY3JlYXRlLmJpbmQoaW5zdGFuY2UpKG1vZHVsZVBhcmFtcyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBzZXQgY29tcG9uZW50cyhjb21wb25lbnRzKSB7XFxuICAgIGNvbnN0IENsYXNzID0gdGhpcztcXG4gICAgaWYgKCFDbGFzcy51c2UpIHJldHVybjtcXG4gICAgQ2xhc3MudXNlKGNvbXBvbmVudHMpO1xcbiAgfVxcblxcbiAgc3RhdGljIGluc3RhbGxNb2R1bGUobW9kdWxlLCAuLi5wYXJhbXMpIHtcXG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzO1xcbiAgICBpZiAoIUNsYXNzLnByb3RvdHlwZS5tb2R1bGVzKSBDbGFzcy5wcm90b3R5cGUubW9kdWxlcyA9IHt9O1xcbiAgICBjb25zdCBuYW1lID0gbW9kdWxlLm5hbWUgfHwgKGAke09iamVjdC5rZXlzKENsYXNzLnByb3RvdHlwZS5tb2R1bGVzKS5sZW5ndGh9XyR7VXRpbHMubm93KCl9YCk7XFxuICAgIENsYXNzLnByb3RvdHlwZS5tb2R1bGVzW25hbWVdID0gbW9kdWxlO1xcbiAgICAvLyBQcm90b3R5cGVcXG4gICAgaWYgKG1vZHVsZS5wcm90bykge1xcbiAgICAgIE9iamVjdC5rZXlzKG1vZHVsZS5wcm90bykuZm9yRWFjaCgoa2V5KSA9PiB7XFxuICAgICAgICBDbGFzcy5wcm90b3R5cGVba2V5XSA9IG1vZHVsZS5wcm90b1trZXldO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8vIENsYXNzXFxuICAgIGlmIChtb2R1bGUuc3RhdGljKSB7XFxuICAgICAgT2JqZWN0LmtleXMobW9kdWxlLnN0YXRpYykuZm9yRWFjaCgoa2V5KSA9PiB7XFxuICAgICAgICBDbGFzc1trZXldID0gbW9kdWxlLnN0YXRpY1trZXldO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8vIENhbGxiYWNrXFxuICAgIGlmIChtb2R1bGUuaW5zdGFsbCkge1xcbiAgICAgIG1vZHVsZS5pbnN0YWxsLmFwcGx5KENsYXNzLCBwYXJhbXMpO1xcbiAgICB9XFxuICAgIHJldHVybiBDbGFzcztcXG4gIH1cXG5cXG4gIHN0YXRpYyB1c2UobW9kdWxlLCAuLi5wYXJhbXMpIHtcXG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XFxuICAgICAgbW9kdWxlLmZvckVhY2goKG0pID0+IENsYXNzLmluc3RhbGxNb2R1bGUobSkpO1xcbiAgICAgIHJldHVybiBDbGFzcztcXG4gICAgfVxcbiAgICByZXR1cm4gQ2xhc3MuaW5zdGFsbE1vZHVsZShtb2R1bGUsIC4uLnBhcmFtcyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZVNpemUgKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGxldCB3aWR0aDtcXG4gIGxldCBoZWlnaHQ7XFxuICBjb25zdCAkZWwgPSBzd2lwZXIuJGVsO1xcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJykge1xcbiAgICB3aWR0aCA9IHN3aXBlci5wYXJhbXMud2lkdGg7XFxuICB9IGVsc2Uge1xcbiAgICB3aWR0aCA9ICRlbFswXS5jbGllbnRXaWR0aDtcXG4gIH1cXG4gIGlmICh0eXBlb2Ygc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGhlaWdodCA9IHN3aXBlci5wYXJhbXMuaGVpZ2h0O1xcbiAgfSBlbHNlIHtcXG4gICAgaGVpZ2h0ID0gJGVsWzBdLmNsaWVudEhlaWdodDtcXG4gIH1cXG4gIGlmICgod2lkdGggPT09IDAgJiYgc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB8fCAoaGVpZ2h0ID09PSAwICYmIHN3aXBlci5pc1ZlcnRpY2FsKCkpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIFN1YnRyYWN0IHBhZGRpbmdzXFxuICB3aWR0aCA9IHdpZHRoIC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy1sZWZ0JyksIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xcbiAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy10b3AnKSwgMTApIC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy1ib3R0b20nKSwgMTApO1xcblxcbiAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICB3aWR0aCxcXG4gICAgaGVpZ2h0LFxcbiAgICBzaXplOiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB3aWR0aCA6IGhlaWdodCxcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXMgKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XFxuXFxuICBjb25zdCB7XFxuICAgICR3cmFwcGVyRWwsIHNpemU6IHN3aXBlclNpemUsIHJ0bFRyYW5zbGF0ZTogcnRsLCB3cm9uZ1JUTCxcXG4gIH0gPSBzd2lwZXI7XFxuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xcbiAgY29uc3QgcHJldmlvdXNTbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XFxuICBjb25zdCBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCk7XFxuICBjb25zdCBzbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc2xpZGVzLmxlbmd0aDtcXG4gIGxldCBzbmFwR3JpZCA9IFtdO1xcbiAgY29uc3Qgc2xpZGVzR3JpZCA9IFtdO1xcbiAgY29uc3Qgc2xpZGVzU2l6ZXNHcmlkID0gW107XFxuXFxuICBmdW5jdGlvbiBzbGlkZXNGb3JNYXJnaW4oc2xpZGVJbmRleCkge1xcbiAgICBpZiAoIXBhcmFtcy5jc3NNb2RlKSByZXR1cm4gdHJ1ZTtcXG4gICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgbGV0IG9mZnNldEJlZm9yZSA9IHBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmU7XFxuICBpZiAodHlwZW9mIG9mZnNldEJlZm9yZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoc3dpcGVyKTtcXG4gIH1cXG5cXG4gIGxldCBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlcjtcXG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXIuY2FsbChzd2lwZXIpO1xcbiAgfVxcblxcbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XFxuICBjb25zdCBwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGggPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xcblxcbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XFxuICBsZXQgc2xpZGVQb3NpdGlvbiA9IC1vZmZzZXRCZWZvcmU7XFxuICBsZXQgcHJldlNsaWRlU2l6ZSA9IDA7XFxuICBsZXQgaW5kZXggPSAwO1xcbiAgaWYgKHR5cGVvZiBzd2lwZXJTaXplID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycgJiYgc3BhY2VCZXR3ZWVuLmluZGV4T2YoJyUnKSA+PSAwKSB7XFxuICAgIHNwYWNlQmV0d2VlbiA9IChwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCkgKiBzd2lwZXJTaXplO1xcbiAgfVxcblxcbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjtcXG5cXG4gIC8vIHJlc2V0IG1hcmdpbnNcXG4gIGlmIChydGwpIHNsaWRlcy5jc3MoeyBtYXJnaW5MZWZ0OiAnJywgbWFyZ2luVG9wOiAnJyB9KTtcXG4gIGVsc2Ugc2xpZGVzLmNzcyh7IG1hcmdpblJpZ2h0OiAnJywgbWFyZ2luQm90dG9tOiAnJyB9KTtcXG5cXG4gIGxldCBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzO1xcbiAgaWYgKHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxKSB7XFxuICAgIGlmIChNYXRoLmZsb29yKHNsaWRlc0xlbmd0aCAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pID09PSBzbGlkZXNMZW5ndGggLyBzd2lwZXIucGFyYW1zLnNsaWRlc1BlckNvbHVtbikge1xcbiAgICAgIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgPSBzbGlkZXNMZW5ndGg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IE1hdGguY2VpbChzbGlkZXNMZW5ndGggLyBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSAqIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW47XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgcGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdyb3cnKSB7XFxuICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IE1hdGgubWF4KHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MsIHBhcmFtcy5zbGlkZXNQZXJWaWV3ICogcGFyYW1zLnNsaWRlc1BlckNvbHVtbik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIENhbGMgc2xpZGVzXFxuICBsZXQgc2xpZGVTaXplO1xcbiAgY29uc3Qgc2xpZGVzUGVyQ29sdW1uID0gcGFyYW1zLnNsaWRlc1BlckNvbHVtbjtcXG4gIGNvbnN0IHNsaWRlc1BlclJvdyA9IHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgLyBzbGlkZXNQZXJDb2x1bW47XFxuICBjb25zdCBudW1GdWxsQ29sdW1ucyA9IE1hdGguZmxvb3Ioc2xpZGVzTGVuZ3RoIC8gcGFyYW1zLnNsaWRlc1BlckNvbHVtbik7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0xlbmd0aDsgaSArPSAxKSB7XFxuICAgIHNsaWRlU2l6ZSA9IDA7XFxuICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzLmVxKGkpO1xcbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcXG4gICAgICAvLyBTZXQgc2xpZGVzIG9yZGVyXFxuICAgICAgbGV0IG5ld1NsaWRlT3JkZXJJbmRleDtcXG4gICAgICBsZXQgY29sdW1uO1xcbiAgICAgIGxldCByb3c7XFxuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJDb2x1bW5GaWxsID09PSAncm93JyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPiAxKSB7XFxuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gTWF0aC5mbG9vcihpIC8gKHBhcmFtcy5zbGlkZXNQZXJHcm91cCAqIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pKTtcXG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXhJbkdyb3VwID0gaSAtIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gKiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgKiBncm91cEluZGV4O1xcbiAgICAgICAgY29uc3QgY29sdW1uc0luR3JvdXAgPSBncm91cEluZGV4ID09PSAwXFxuICAgICAgICAgID8gcGFyYW1zLnNsaWRlc1Blckdyb3VwXFxuICAgICAgICAgIDogTWF0aC5taW4oTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSBncm91cEluZGV4ICogc2xpZGVzUGVyQ29sdW1uICogcGFyYW1zLnNsaWRlc1Blckdyb3VwKSAvIHNsaWRlc1BlckNvbHVtbiksIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuICAgICAgICByb3cgPSBNYXRoLmZsb29yKHNsaWRlSW5kZXhJbkdyb3VwIC8gY29sdW1uc0luR3JvdXApO1xcbiAgICAgICAgY29sdW1uID0gKHNsaWRlSW5kZXhJbkdyb3VwIC0gcm93ICogY29sdW1uc0luR3JvdXApICsgZ3JvdXBJbmRleCAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcXG5cXG4gICAgICAgIG5ld1NsaWRlT3JkZXJJbmRleCA9IGNvbHVtbiArICgocm93ICogc2xpZGVzTnVtYmVyRXZlblRvUm93cykgLyBzbGlkZXNQZXJDb2x1bW4pO1xcbiAgICAgICAgc2xpZGVcXG4gICAgICAgICAgLmNzcyh7XFxuICAgICAgICAgICAgJy13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXAnOiBuZXdTbGlkZU9yZGVySW5kZXgsXFxuICAgICAgICAgICAgJy1tb3otYm94LW9yZGluYWwtZ3JvdXAnOiBuZXdTbGlkZU9yZGVySW5kZXgsXFxuICAgICAgICAgICAgJy1tcy1mbGV4LW9yZGVyJzogbmV3U2xpZGVPcmRlckluZGV4LFxcbiAgICAgICAgICAgICctd2Via2l0LW9yZGVyJzogbmV3U2xpZGVPcmRlckluZGV4LFxcbiAgICAgICAgICAgIG9yZGVyOiBuZXdTbGlkZU9yZGVySW5kZXgsXFxuICAgICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nKSB7XFxuICAgICAgICBjb2x1bW4gPSBNYXRoLmZsb29yKGkgLyBzbGlkZXNQZXJDb2x1bW4pO1xcbiAgICAgICAgcm93ID0gaSAtIChjb2x1bW4gKiBzbGlkZXNQZXJDb2x1bW4pO1xcbiAgICAgICAgaWYgKGNvbHVtbiA+IG51bUZ1bGxDb2x1bW5zIHx8IChjb2x1bW4gPT09IG51bUZ1bGxDb2x1bW5zICYmIHJvdyA9PT0gc2xpZGVzUGVyQ29sdW1uIC0gMSkpIHtcXG4gICAgICAgICAgcm93ICs9IDE7XFxuICAgICAgICAgIGlmIChyb3cgPj0gc2xpZGVzUGVyQ29sdW1uKSB7XFxuICAgICAgICAgICAgcm93ID0gMDtcXG4gICAgICAgICAgICBjb2x1bW4gKz0gMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByb3cgPSBNYXRoLmZsb29yKGkgLyBzbGlkZXNQZXJSb3cpO1xcbiAgICAgICAgY29sdW1uID0gaSAtIChyb3cgKiBzbGlkZXNQZXJSb3cpO1xcbiAgICAgIH1cXG4gICAgICBzbGlkZS5jc3MoXFxuICAgICAgICBgbWFyZ2luLSR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3RvcCcgOiAnbGVmdCd9YCxcXG4gICAgICAgIChyb3cgIT09IDAgJiYgcGFyYW1zLnNwYWNlQmV0d2VlbikgJiYgKGAke3BhcmFtcy5zcGFjZUJldHdlZW59cHhgKVxcbiAgICAgICk7XFxuICAgIH1cXG4gICAgaWYgKHNsaWRlLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXFxuXFxuICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XFxuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmdldENvbXB1dGVkU3R5bGUoc2xpZGVbMF0sIG51bGwpO1xcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZVswXS5zdHlsZS50cmFuc2Zvcm07XFxuICAgICAgY29uc3QgY3VycmVudFdlYktpdFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybTtcXG4gICAgICBpZiAoY3VycmVudFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xcbiAgICAgIH1cXG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpXFxuICAgICAgICAgID8gc2xpZGUub3V0ZXJXaWR0aCh0cnVlKVxcbiAgICAgICAgICA6IHNsaWRlLm91dGVySGVpZ2h0KHRydWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpO1xcbiAgICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JykpO1xcbiAgICAgICAgICBjb25zdCBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSk7XFxuICAgICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1sZWZ0JykpO1xcbiAgICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpO1xcbiAgICAgICAgICBjb25zdCBib3hTaXppbmcgPSBzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdib3gtc2l6aW5nJyk7XFxuICAgICAgICAgIGlmIChib3hTaXppbmcgJiYgYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcXG4gICAgICAgICAgICBzbGlkZVNpemUgPSB3aWR0aCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodDtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzbGlkZVNpemUgPSB3aWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0ICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKTtcXG4gICAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSk7XFxuICAgICAgICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpO1xcbiAgICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi10b3AnKSk7XFxuICAgICAgICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcXG4gICAgICAgICAgY29uc3QgYm94U2l6aW5nID0gc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnYm94LXNpemluZycpO1xcbiAgICAgICAgICBpZiAoYm94U2l6aW5nICYmIGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XFxuICAgICAgICAgICAgc2xpZGVTaXplID0gaGVpZ2h0ICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNsaWRlU2l6ZSA9IGhlaWdodCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtKSB7XFxuICAgICAgICBzbGlkZVswXS5zdHlsZS50cmFuc2Zvcm0gPSBjdXJyZW50VHJhbnNmb3JtO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gY3VycmVudFdlYktpdFRyYW5zZm9ybTtcXG4gICAgICB9XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtICgocGFyYW1zLnNsaWRlc1BlclZpZXcgLSAxKSAqIHNwYWNlQmV0d2VlbikpIC8gcGFyYW1zLnNsaWRlc1BlclZpZXc7XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcXG5cXG4gICAgICBpZiAoc2xpZGVzW2ldKSB7XFxuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgICAgIHNsaWRlc1tpXS5zdHlsZS53aWR0aCA9IGAke3NsaWRlU2l6ZX1weGA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzbGlkZXNbaV0uc3R5bGUuaGVpZ2h0ID0gYCR7c2xpZGVTaXplfXB4YDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHNsaWRlc1tpXSkge1xcbiAgICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemUgPSBzbGlkZVNpemU7XFxuICAgIH1cXG4gICAgc2xpZGVzU2l6ZXNHcmlkLnB1c2goc2xpZGVTaXplKTtcXG5cXG5cXG4gICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgKHNsaWRlU2l6ZSAvIDIpICsgKHByZXZTbGlkZVNpemUgLyAyKSArIHNwYWNlQmV0d2VlbjtcXG4gICAgICBpZiAocHJldlNsaWRlU2l6ZSA9PT0gMCAmJiBpICE9PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIChzd2lwZXJTaXplIC8gMikgLSBzcGFjZUJldHdlZW47XFxuICAgICAgaWYgKGkgPT09IDApIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uIC0gKHN3aXBlclNpemUgLyAyKSAtIHNwYWNlQmV0d2VlbjtcXG4gICAgICBpZiAoTWF0aC5hYnMoc2xpZGVQb3NpdGlvbikgPCAxIC8gMTAwMCkgc2xpZGVQb3NpdGlvbiA9IDA7XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xcbiAgICAgIGlmICgoaW5kZXgpICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xcbiAgICAgIHNsaWRlc0dyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVQb3NpdGlvbiA9IE1hdGguZmxvb3Ioc2xpZGVQb3NpdGlvbik7XFxuICAgICAgaWYgKChpbmRleCAtIE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBpbmRleCkpICUgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMCkgc25hcEdyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcXG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XFxuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplICs9IHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbjtcXG5cXG4gICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcXG5cXG4gICAgaW5kZXggKz0gMTtcXG4gIH1cXG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcXG4gIGxldCBuZXdTbGlkZXNHcmlkO1xcblxcbiAgaWYgKFxcbiAgICBydGwgJiYgd3JvbmdSVEwgJiYgKHBhcmFtcy5lZmZlY3QgPT09ICdzbGlkZScgfHwgcGFyYW1zLmVmZmVjdCA9PT0gJ2NvdmVyZmxvdycpKSB7XFxuICAgICR3cmFwcGVyRWwuY3NzKHsgd2lkdGg6IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW59cHhgIH0pO1xcbiAgfVxcbiAgaWYgKHBhcmFtcy5zZXRXcmFwcGVyU2l6ZSkge1xcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSAkd3JhcHBlckVsLmNzcyh7IHdpZHRoOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YCB9KTtcXG4gICAgZWxzZSAkd3JhcHBlckVsLmNzcyh7IGhlaWdodDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gKHNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pICogc2xpZGVzTnVtYmVyRXZlblRvUm93cztcXG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gTWF0aC5jZWlsKHN3aXBlci52aXJ0dWFsU2l6ZSAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pIC0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkgJHdyYXBwZXJFbC5jc3MoeyB3aWR0aDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XFxuICAgIGVsc2UgJHdyYXBwZXJFbC5jc3MoeyBoZWlnaHQ6IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW59cHhgIH0pO1xcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgbmV3U2xpZGVzR3JpZCA9IFtdO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc25hcEdyaWQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGxldCBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW2ldO1xcbiAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlc0dyaWRJdGVtID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkSXRlbSk7XFxuICAgICAgICBpZiAoc25hcEdyaWRbaV0gPCBzd2lwZXIudmlydHVhbFNpemUgKyBzbmFwR3JpZFswXSkgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcXG4gICAgICB9XFxuICAgICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxcbiAgaWYgKCFwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcXG4gICAgbmV3U2xpZGVzR3JpZCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgbGV0IHNsaWRlc0dyaWRJdGVtID0gc25hcEdyaWRbaV07XFxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlc0dyaWRJdGVtID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkSXRlbSk7XFxuICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcXG4gICAgICAgIG5ld1NsaWRlc0dyaWQucHVzaChzbGlkZXNHcmlkSXRlbSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHNuYXBHcmlkID0gbmV3U2xpZGVzR3JpZDtcXG4gICAgaWYgKE1hdGguZmxvb3Ioc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSkgLSBNYXRoLmZsb29yKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdKSA+IDEpIHtcXG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoc25hcEdyaWQubGVuZ3RoID09PSAwKSBzbmFwR3JpZCA9IFswXTtcXG5cXG4gIGlmIChwYXJhbXMuc3BhY2VCZXR3ZWVuICE9PSAwKSB7XFxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgICBpZiAocnRsKSBzbGlkZXMuZmlsdGVyKHNsaWRlc0Zvck1hcmdpbikuY3NzKHsgbWFyZ2luTGVmdDogYCR7c3BhY2VCZXR3ZWVufXB4YCB9KTtcXG4gICAgICBlbHNlIHNsaWRlcy5maWx0ZXIoc2xpZGVzRm9yTWFyZ2luKS5jc3MoeyBtYXJnaW5SaWdodDogYCR7c3BhY2VCZXR3ZWVufXB4YCB9KTtcXG4gICAgfSBlbHNlIHNsaWRlcy5maWx0ZXIoc2xpZGVzRm9yTWFyZ2luKS5jc3MoeyBtYXJnaW5Cb3R0b206IGAke3NwYWNlQmV0d2Vlbn1weGAgfSk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlc0JvdW5kcykge1xcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XFxuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKChzbGlkZVNpemVWYWx1ZSkgPT4ge1xcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAocGFyYW1zLnNwYWNlQmV0d2VlbiA/IHBhcmFtcy5zcGFjZUJldHdlZW4gOiAwKTtcXG4gICAgfSk7XFxuICAgIGFsbFNsaWRlc1NpemUgLT0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcXG4gICAgY29uc3QgbWF4U25hcCA9IGFsbFNsaWRlc1NpemUgLSBzd2lwZXJTaXplO1xcbiAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcCgoc25hcCkgPT4ge1xcbiAgICAgIGlmIChzbmFwIDwgMCkgcmV0dXJuIC1vZmZzZXRCZWZvcmU7XFxuICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xcbiAgICAgIHJldHVybiBzbmFwO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuY2VudGVySW5zdWZmaWNpZW50U2xpZGVzKSB7XFxuICAgIGxldCBhbGxTbGlkZXNTaXplID0gMDtcXG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goKHNsaWRlU2l6ZVZhbHVlKSA9PiB7XFxuICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xcbiAgICB9KTtcXG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xcbiAgICBpZiAoYWxsU2xpZGVzU2l6ZSA8IHN3aXBlclNpemUpIHtcXG4gICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUpIC8gMjtcXG4gICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcXG4gICAgICAgIHNuYXBHcmlkW3NuYXBJbmRleF0gPSBzbmFwIC0gYWxsU2xpZGVzT2Zmc2V0O1xcbiAgICAgIH0pO1xcbiAgICAgIHNsaWRlc0dyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XFxuICAgICAgICBzbGlkZXNHcmlkW3NuYXBJbmRleF0gPSBzbmFwICsgYWxsU2xpZGVzT2Zmc2V0O1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgIHNsaWRlcyxcXG4gICAgc25hcEdyaWQsXFxuICAgIHNsaWRlc0dyaWQsXFxuICAgIHNsaWRlc1NpemVzR3JpZCxcXG4gIH0pO1xcblxcbiAgaWYgKHNsaWRlc0xlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNMZW5ndGgpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlc0xlbmd0aENoYW5nZScpO1xcbiAgfVxcbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbmFwR3JpZExlbmd0aCkge1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93KSBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xcbiAgICBzd2lwZXIuZW1pdCgnc25hcEdyaWRMZW5ndGhDaGFuZ2UnKTtcXG4gIH1cXG4gIGlmIChzbGlkZXNHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoKSB7XFxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQgKHNwZWVkKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgYWN0aXZlU2xpZGVzID0gW107XFxuICBsZXQgbmV3SGVpZ2h0ID0gMDtcXG4gIGxldCBpO1xcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcXG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xcbiAgfSBlbHNlIGlmIChzcGVlZCA9PT0gdHJ1ZSkge1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcXG4gIH1cXG4gIC8vIEZpbmQgc2xpZGVzIGN1cnJlbnRseSBpbiB2aWV3XFxuICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkge1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzLmVhY2goKGluZGV4LCBzbGlkZSkgPT4ge1xcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goc2xpZGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTsgaSArPSAxKSB7XFxuICAgICAgICBjb25zdCBpbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCArIGk7XFxuICAgICAgICBpZiAoaW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCkgYnJlYWs7XFxuICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChzd2lwZXIuc2xpZGVzLmVxKGluZGV4KVswXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBhY3RpdmVTbGlkZXMucHVzaChzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleClbMF0pO1xcbiAgfVxcblxcbiAgLy8gRmluZCBuZXcgaGVpZ2h0IGZyb20gaGlnaGVzdCBzbGlkZSBpbiB2aWV3XFxuICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVzW2ldICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGNvbnN0IGhlaWdodCA9IGFjdGl2ZVNsaWRlc1tpXS5vZmZzZXRIZWlnaHQ7XFxuICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ID4gbmV3SGVpZ2h0ID8gaGVpZ2h0IDogbmV3SGVpZ2h0O1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBVcGRhdGUgSGVpZ2h0XFxuICBpZiAobmV3SGVpZ2h0KSBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ2hlaWdodCcsIGAke25ld0hlaWdodH1weGApO1xcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNPZmZzZXQgKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHNsaWRlcyA9IHN3aXBlci5zbGlkZXM7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVPZmZzZXQgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZXNbaV0ub2Zmc2V0TGVmdCA6IHNsaWRlc1tpXS5vZmZzZXRUb3A7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc1Byb2dyZXNzICh0cmFuc2xhdGUgPSAodGhpcyAmJiB0aGlzLnRyYW5zbGF0ZSkgfHwgMCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XFxuXFxuICBjb25zdCB7IHNsaWRlcywgcnRsVHJhbnNsYXRlOiBydGwgfSA9IHN3aXBlcjtcXG5cXG4gIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcXG5cXG4gIGxldCBvZmZzZXRDZW50ZXIgPSAtdHJhbnNsYXRlO1xcbiAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlO1xcblxcbiAgLy8gVmlzaWJsZSBTbGlkZXNcXG4gIHNsaWRlcy5yZW1vdmVDbGFzcyhwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpO1xcblxcbiAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzID0gW107XFxuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9IFtdO1xcblxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3Qgc2xpZGUgPSBzbGlkZXNbaV07XFxuICAgIGNvbnN0IHNsaWRlUHJvZ3Jlc3MgPSAoXFxuICAgICAgKG9mZnNldENlbnRlciArIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiAwKSkgLSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldFxcbiAgICApIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pO1xcbiAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSB8fCAocGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5hdXRvSGVpZ2h0KSkge1xcbiAgICAgIGNvbnN0IHNsaWRlQmVmb3JlID0gLShvZmZzZXRDZW50ZXIgLSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldCk7XFxuICAgICAgY29uc3Qgc2xpZGVBZnRlciA9IHNsaWRlQmVmb3JlICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtpXTtcXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSAoc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8IHN3aXBlci5zaXplIC0gMSlcXG4gICAgICAgICAgICAgICAgfHwgKHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUpXFxuICAgICAgICAgICAgICAgIHx8IChzbGlkZUJlZm9yZSA8PSAwICYmIHNsaWRlQWZ0ZXIgPj0gc3dpcGVyLnNpemUpO1xcbiAgICAgIGlmIChpc1Zpc2libGUpIHtcXG4gICAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzLnB1c2goc2xpZGUpO1xcbiAgICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2goaSk7XFxuICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgc2xpZGUucHJvZ3Jlc3MgPSBydGwgPyAtc2xpZGVQcm9ncmVzcyA6IHNsaWRlUHJvZ3Jlc3M7XFxuICB9XFxuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc3dpcGVyLnZpc2libGVTbGlkZXMpO1xcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyAodHJhbnNsYXRlKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgaWYgKHR5cGVvZiB0cmFuc2xhdGUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgdHJhbnNsYXRlID0gKHN3aXBlciAmJiBzd2lwZXIudHJhbnNsYXRlICYmIChzd2lwZXIudHJhbnNsYXRlICogbXVsdGlwbGllcikpIHx8IDA7XFxuICB9XFxuICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICBsZXQgeyBwcm9ncmVzcywgaXNCZWdpbm5pbmcsIGlzRW5kIH0gPSBzd2lwZXI7XFxuICBjb25zdCB3YXNCZWdpbm5pbmcgPSBpc0JlZ2lubmluZztcXG4gIGNvbnN0IHdhc0VuZCA9IGlzRW5kO1xcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XFxuICAgIHByb2dyZXNzID0gMDtcXG4gICAgaXNCZWdpbm5pbmcgPSB0cnVlO1xcbiAgICBpc0VuZCA9IHRydWU7XFxuICB9IGVsc2Uge1xcbiAgICBwcm9ncmVzcyA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gKHRyYW5zbGF0ZXNEaWZmKTtcXG4gICAgaXNCZWdpbm5pbmcgPSBwcm9ncmVzcyA8PSAwO1xcbiAgICBpc0VuZCA9IHByb2dyZXNzID49IDE7XFxuICB9XFxuICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgIHByb2dyZXNzLFxcbiAgICBpc0JlZ2lubmluZyxcXG4gICAgaXNFbmQsXFxuICB9KTtcXG5cXG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBwYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5IHx8IChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmF1dG9IZWlnaHQpKSBzd2lwZXIudXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKTtcXG5cXG4gIGlmIChpc0JlZ2lubmluZyAmJiAhd2FzQmVnaW5uaW5nKSB7XFxuICAgIHN3aXBlci5lbWl0KCdyZWFjaEJlZ2lubmluZyB0b0VkZ2UnKTtcXG4gIH1cXG4gIGlmIChpc0VuZCAmJiAhd2FzRW5kKSB7XFxuICAgIHN3aXBlci5lbWl0KCdyZWFjaEVuZCB0b0VkZ2UnKTtcXG4gIH1cXG4gIGlmICgod2FzQmVnaW5uaW5nICYmICFpc0JlZ2lubmluZykgfHwgKHdhc0VuZCAmJiAhaXNFbmQpKSB7XFxuICAgIHN3aXBlci5lbWl0KCdmcm9tRWRnZScpO1xcbiAgfVxcblxcbiAgc3dpcGVyLmVtaXQoJ3Byb2dyZXNzJywgcHJvZ3Jlc3MpO1xcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBjb25zdCB7XFxuICAgIHNsaWRlcywgcGFyYW1zLCAkd3JhcHBlckVsLCBhY3RpdmVJbmRleCwgcmVhbEluZGV4LFxcbiAgfSA9IHN3aXBlcjtcXG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XFxuXFxuICBzbGlkZXMucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlTmV4dENsYXNzfSAke3BhcmFtcy5zbGlkZVByZXZDbGFzc30gJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzc30gJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzfWApO1xcblxcbiAgbGV0IGFjdGl2ZVNsaWRlO1xcbiAgaWYgKGlzVmlydHVhbCkge1xcbiAgICBhY3RpdmVTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFwiJHthY3RpdmVJbmRleH1cXFwiXWApO1xcbiAgfSBlbHNlIHtcXG4gICAgYWN0aXZlU2xpZGUgPSBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpO1xcbiAgfVxcblxcbiAgLy8gQWN0aXZlIGNsYXNzZXNcXG4gIGFjdGl2ZVNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKTtcXG5cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICAvLyBEdXBsaWNhdGUgdG8gYWxsIGxvb3BlZCBzbGlkZXNcXG4gICAgaWYgKGFjdGl2ZVNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICR3cmFwcGVyRWxcXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9Om5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke3JlYWxJbmRleH1cXFwiXWApXFxuICAgICAgICAuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICR3cmFwcGVyRWxcXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke3JlYWxJbmRleH1cXFwiXWApXFxuICAgICAgICAuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xcbiAgICB9XFxuICB9XFxuICAvLyBOZXh0IFNsaWRlXFxuICBsZXQgbmV4dFNsaWRlID0gYWN0aXZlU2xpZGUubmV4dEFsbChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcXG4gIGlmIChwYXJhbXMubG9vcCAmJiBuZXh0U2xpZGUubGVuZ3RoID09PSAwKSB7XFxuICAgIG5leHRTbGlkZSA9IHNsaWRlcy5lcSgwKTtcXG4gICAgbmV4dFNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZU5leHRDbGFzcyk7XFxuICB9XFxuICAvLyBQcmV2IFNsaWRlXFxuICBsZXQgcHJldlNsaWRlID0gYWN0aXZlU2xpZGUucHJldkFsbChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcXG4gIGlmIChwYXJhbXMubG9vcCAmJiBwcmV2U2xpZGUubGVuZ3RoID09PSAwKSB7XFxuICAgIHByZXZTbGlkZSA9IHNsaWRlcy5lcSgtMSk7XFxuICAgIHByZXZTbGlkZS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xcbiAgfVxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIC8vIER1cGxpY2F0ZSB0byBhbGwgbG9vcGVkIHNsaWRlc1xcbiAgICBpZiAobmV4dFNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICR3cmFwcGVyRWxcXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9Om5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVxcXCJdYClcXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICR3cmFwcGVyRWxcXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVxcXCJdYClcXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpO1xcbiAgICB9XFxuICAgIGlmIChwcmV2U2xpZGUuaGFzQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgJHdyYXBwZXJFbFxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XFxcIl1gKVxcbiAgICAgICAgLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJHdyYXBwZXJFbFxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XFxcIl1gKVxcbiAgICAgICAgLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXggKG5ld0FjdGl2ZUluZGV4KSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcXG4gIGNvbnN0IHtcXG4gICAgc2xpZGVzR3JpZCwgc25hcEdyaWQsIHBhcmFtcywgYWN0aXZlSW5kZXg6IHByZXZpb3VzSW5kZXgsIHJlYWxJbmRleDogcHJldmlvdXNSZWFsSW5kZXgsIHNuYXBJbmRleDogcHJldmlvdXNTbmFwSW5kZXgsXFxuICB9ID0gc3dpcGVyO1xcbiAgbGV0IGFjdGl2ZUluZGV4ID0gbmV3QWN0aXZlSW5kZXg7XFxuICBsZXQgc25hcEluZGV4O1xcbiAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtICgoc2xpZGVzR3JpZFtpICsgMV0gLSBzbGlkZXNHcmlkW2ldKSAvIDIpKSB7XFxuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0gJiYgdHJhbnNsYXRlIDwgc2xpZGVzR3JpZFtpICsgMV0pIHtcXG4gICAgICAgICAgYWN0aXZlSW5kZXggPSBpICsgMTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldKSB7XFxuICAgICAgICBhY3RpdmVJbmRleCA9IGk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XFxuICAgIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xcbiAgICAgIGlmIChhY3RpdmVJbmRleCA8IDAgfHwgdHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykgYWN0aXZlSW5kZXggPSAwO1xcbiAgICB9XFxuICB9XFxuICBpZiAoc25hcEdyaWQuaW5kZXhPZih0cmFuc2xhdGUpID49IDApIHtcXG4gICAgc25hcEluZGV4ID0gc25hcEdyaWQuaW5kZXhPZih0cmFuc2xhdGUpO1xcbiAgfSBlbHNlIHtcXG4gICAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGFjdGl2ZUluZGV4KTtcXG4gICAgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKGFjdGl2ZUluZGV4IC0gc2tpcCkgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xcbiAgfVxcbiAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XFxuICBpZiAoYWN0aXZlSW5kZXggPT09IHByZXZpb3VzSW5kZXgpIHtcXG4gICAgaWYgKHNuYXBJbmRleCAhPT0gcHJldmlvdXNTbmFwSW5kZXgpIHtcXG4gICAgICBzd2lwZXIuc25hcEluZGV4ID0gc25hcEluZGV4O1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBHZXQgcmVhbCBpbmRleFxcbiAgY29uc3QgcmVhbEluZGV4ID0gcGFyc2VJbnQoc3dpcGVyLnNsaWRlcy5lcShhY3RpdmVJbmRleCkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSB8fCBhY3RpdmVJbmRleCwgMTApO1xcblxcbiAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICBzbmFwSW5kZXgsXFxuICAgIHJlYWxJbmRleCxcXG4gICAgcHJldmlvdXNJbmRleCxcXG4gICAgYWN0aXZlSW5kZXgsXFxuICB9KTtcXG4gIHN3aXBlci5lbWl0KCdhY3RpdmVJbmRleENoYW5nZScpO1xcbiAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xcbiAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcXG4gICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xcbiAgfVxcbiAgaWYgKHN3aXBlci5pbml0aWFsaXplZCB8fCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCkge1xcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2UnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlQ2xpY2tlZFNsaWRlIChlKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIGNvbnN0IHNsaWRlID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShlLnRhcmdldCkuY2xvc2VzdChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YClbMF07XFxuICBsZXQgc2xpZGVGb3VuZCA9IGZhbHNlO1xcbiAgaWYgKHNsaWRlKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2ldID09PSBzbGlkZSkgc2xpZGVGb3VuZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChzbGlkZSAmJiBzbGlkZUZvdW5kKSB7XFxuICAgIHN3aXBlci5jbGlja2VkU2xpZGUgPSBzbGlkZTtcXG4gICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XFxuICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHBhcnNlSW50KE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzbGlkZSkuaW5kZXgoKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcXG4gICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKHBhcmFtcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHVuZGVmaW5lZCAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcXG4gICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcXG4gIH1cXG59XFxuXFxudmFyIHVwZGF0ZSA9IHtcXG4gIHVwZGF0ZVNpemUsXFxuICB1cGRhdGVTbGlkZXMsXFxuICB1cGRhdGVBdXRvSGVpZ2h0LFxcbiAgdXBkYXRlU2xpZGVzT2Zmc2V0LFxcbiAgdXBkYXRlU2xpZGVzUHJvZ3Jlc3MsXFxuICB1cGRhdGVQcm9ncmVzcyxcXG4gIHVwZGF0ZVNsaWRlc0NsYXNzZXMsXFxuICB1cGRhdGVBY3RpdmVJbmRleCxcXG4gIHVwZGF0ZUNsaWNrZWRTbGlkZSxcXG59O1xcblxcbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZSAoYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneScpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBjb25zdCB7XFxuICAgIHBhcmFtcywgcnRsVHJhbnNsYXRlOiBydGwsIHRyYW5zbGF0ZSwgJHdyYXBwZXJFbCxcXG4gIH0gPSBzd2lwZXI7XFxuXFxuICBpZiAocGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcXG4gICAgcmV0dXJuIHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XFxuICB9XFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgcmV0dXJuIHRyYW5zbGF0ZTtcXG4gIH1cXG5cXG4gIGxldCBjdXJyZW50VHJhbnNsYXRlID0gVXRpbHMuZ2V0VHJhbnNsYXRlKCR3cmFwcGVyRWxbMF0sIGF4aXMpO1xcbiAgaWYgKHJ0bCkgY3VycmVudFRyYW5zbGF0ZSA9IC1jdXJyZW50VHJhbnNsYXRlO1xcblxcbiAgcmV0dXJuIGN1cnJlbnRUcmFuc2xhdGUgfHwgMDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0VHJhbnNsYXRlICh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHtcXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsIHBhcmFtcywgJHdyYXBwZXJFbCwgd3JhcHBlckVsLCBwcm9ncmVzcyxcXG4gIH0gPSBzd2lwZXI7XFxuICBsZXQgeCA9IDA7XFxuICBsZXQgeSA9IDA7XFxuICBjb25zdCB6ID0gMDtcXG5cXG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgeCA9IHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XFxuICB9IGVsc2Uge1xcbiAgICB5ID0gdHJhbnNsYXRlO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcXG4gICAgeCA9IE1hdGguZmxvb3IoeCk7XFxuICAgIHkgPSBNYXRoLmZsb29yKHkpO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHdyYXBwZXJFbFtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAteCA6IC15O1xcbiAgfSBlbHNlIGlmICghcGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcXG4gICAgJHdyYXBwZXJFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAke3p9cHgpYCk7XFxuICB9XFxuICBzd2lwZXIucHJldmlvdXNUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xcbiAgc3dpcGVyLnRyYW5zbGF0ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHggOiB5O1xcblxcbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1cGRhdGUgcHJvZ3Jlc3NcXG4gIGxldCBuZXdQcm9ncmVzcztcXG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XFxuICAgIG5ld1Byb2dyZXNzID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIG5ld1Byb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyAodHJhbnNsYXRlc0RpZmYpO1xcbiAgfVxcbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcXG4gIH1cXG5cXG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xcbn1cXG5cXG5mdW5jdGlvbiBtaW5UcmFuc2xhdGUgKCkge1xcbiAgcmV0dXJuICgtdGhpcy5zbmFwR3JpZFswXSk7XFxufVxcblxcbmZ1bmN0aW9uIG1heFRyYW5zbGF0ZSAoKSB7XFxuICByZXR1cm4gKC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV0pO1xcbn1cXG5cXG5mdW5jdGlvbiB0cmFuc2xhdGVUbyAodHJhbnNsYXRlID0gMCwgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgdHJhbnNsYXRlQm91bmRzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBjb25zdCB7XFxuICAgIHBhcmFtcyxcXG4gICAgd3JhcHBlckVsLFxcbiAgfSA9IHN3aXBlcjtcXG5cXG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgY29uc3QgbWluVHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xcbiAgY29uc3QgbWF4VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xcbiAgbGV0IG5ld1RyYW5zbGF0ZTtcXG4gIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlID4gbWluVHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtaW5UcmFuc2xhdGU7XFxuICBlbHNlIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlIDwgbWF4VHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtYXhUcmFuc2xhdGU7XFxuICBlbHNlIG5ld1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcXG5cXG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1RyYW5zbGF0ZSk7XFxuXFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xcbiAgICBpZiAoc3BlZWQgPT09IDApIHtcXG4gICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gLW5ld1RyYW5zbGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBpZiAod3JhcHBlckVsLnNjcm9sbFRvKSB7XFxuICAgICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xcbiAgICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiAtbmV3VHJhbnNsYXRlLFxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCcsXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IC1uZXdUcmFuc2xhdGU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKHNwZWVkID09PSAwKSB7XFxuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XFxuICAgIGlmIChydW5DYWxsYmFja3MpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcXG4gICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XFxuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcXG4gICAgaWYgKHJ1bkNhbGxiYWNrcykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xcbiAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uU3RhcnQnKTtcXG4gICAgfVxcbiAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcXG4gICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcXG4gICAgICBpZiAoIXN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpIHtcXG4gICAgICAgIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcXG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XFxuICAgICAgICAgIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsO1xcbiAgICAgICAgICBkZWxldGUgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZDtcXG4gICAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xcbiAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn1cXG5cXG52YXIgdHJhbnNsYXRlID0ge1xcbiAgZ2V0VHJhbnNsYXRlLFxcbiAgc2V0VHJhbnNsYXRlLFxcbiAgbWluVHJhbnNsYXRlLFxcbiAgbWF4VHJhbnNsYXRlLFxcbiAgdHJhbnNsYXRlVG8sXFxufTtcXG5cXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uIChkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcblxcbiAgaWYgKCFzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcXG4gICAgc3dpcGVyLiR3cmFwcGVyRWwudHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICB9XFxuXFxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNpdGlvbicsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xcbn1cXG5cXG5mdW5jdGlvbiB0cmFuc2l0aW9uU3RhcnQgKHJ1bkNhbGxiYWNrcyA9IHRydWUsIGRpcmVjdGlvbikge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHsgYWN0aXZlSW5kZXgsIHBhcmFtcywgcHJldmlvdXNJbmRleCB9ID0gc3dpcGVyO1xcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XFxuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcXG4gIH1cXG5cXG4gIGxldCBkaXIgPSBkaXJlY3Rpb247XFxuICBpZiAoIWRpcikge1xcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7XFxuICAgIGVsc2UgaWYgKGFjdGl2ZUluZGV4IDwgcHJldmlvdXNJbmRleCkgZGlyID0gJ3ByZXYnO1xcbiAgICBlbHNlIGRpciA9ICdyZXNldCc7XFxuICB9XFxuXFxuICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvblN0YXJ0Jyk7XFxuXFxuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XFxuICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVSZXNldFRyYW5zaXRpb25TdGFydCcpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2VUcmFuc2l0aW9uU3RhcnQnKTtcXG4gICAgaWYgKGRpciA9PT0gJ25leHQnKSB7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlTmV4dFRyYW5zaXRpb25TdGFydCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVByZXZUcmFuc2l0aW9uU3RhcnQnKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kIChydW5DYWxsYmFja3MgPSB0cnVlLCBkaXJlY3Rpb24pIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBjb25zdCB7IGFjdGl2ZUluZGV4LCBwcmV2aW91c0luZGV4LCBwYXJhbXMgfSA9IHN3aXBlcjtcXG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xcbiAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XFxuXFxuICBsZXQgZGlyID0gZGlyZWN0aW9uO1xcbiAgaWYgKCFkaXIpIHtcXG4gICAgaWYgKGFjdGl2ZUluZGV4ID4gcHJldmlvdXNJbmRleCkgZGlyID0gJ25leHQnO1xcbiAgICBlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztcXG4gICAgZWxzZSBkaXIgPSAncmVzZXQnO1xcbiAgfVxcblxcbiAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcXG5cXG4gIGlmIChydW5DYWxsYmFja3MgJiYgYWN0aXZlSW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcXG4gICAgaWYgKGRpciA9PT0gJ3Jlc2V0Jykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVJlc2V0VHJhbnNpdGlvbkVuZCcpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2VUcmFuc2l0aW9uRW5kJyk7XFxuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZU5leHRUcmFuc2l0aW9uRW5kJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlUHJldlRyYW5zaXRpb25FbmQnKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgdHJhbnNpdGlvbiA9IHtcXG4gIHNldFRyYW5zaXRpb24sXFxuICB0cmFuc2l0aW9uU3RhcnQsXFxuICB0cmFuc2l0aW9uRW5kLFxcbn07XFxuXFxuZnVuY3Rpb24gc2xpZGVUbyAoaW5kZXggPSAwLCBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkLCBydW5DYWxsYmFja3MgPSB0cnVlLCBpbnRlcm5hbCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XFxuICBpZiAoc2xpZGVJbmRleCA8IDApIHNsaWRlSW5kZXggPSAwO1xcblxcbiAgY29uc3Qge1xcbiAgICBwYXJhbXMsIHNuYXBHcmlkLCBzbGlkZXNHcmlkLCBwcmV2aW91c0luZGV4LCBhY3RpdmVJbmRleCwgcnRsVHJhbnNsYXRlOiBydGwsIHdyYXBwZXJFbCxcXG4gIH0gPSBzd2lwZXI7XFxuICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGNvbnN0IHNraXAgPSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgc2xpZGVJbmRleCk7XFxuICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xcbiAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XFxuXFxuICBpZiAoKGFjdGl2ZUluZGV4IHx8IHBhcmFtcy5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChwcmV2aW91c0luZGV4IHx8IDApICYmIHJ1bkNhbGxiYWNrcykge1xcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlU2xpZGVDaGFuZ2VTdGFydCcpO1xcbiAgfVxcblxcbiAgY29uc3QgdHJhbnNsYXRlID0gLXNuYXBHcmlkW3NuYXBJbmRleF07XFxuXFxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcXG4gIHN3aXBlci51cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpO1xcblxcbiAgLy8gTm9ybWFsaXplIHNsaWRlSW5kZXhcXG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAoLU1hdGguZmxvb3IodHJhbnNsYXRlICogMTAwKSA+PSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaV0gKiAxMDApKSB7XFxuICAgICAgICBzbGlkZUluZGV4ID0gaTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIERpcmVjdGlvbnMgbG9ja3NcXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcXG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZU5leHQgJiYgdHJhbnNsYXRlIDwgc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPCBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcXG4gICAgICBpZiAoKGFjdGl2ZUluZGV4IHx8IDApICE9PSBzbGlkZUluZGV4KSByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGxldCBkaXJlY3Rpb247XFxuICBpZiAoc2xpZGVJbmRleCA+IGFjdGl2ZUluZGV4KSBkaXJlY3Rpb24gPSAnbmV4dCc7XFxuICBlbHNlIGlmIChzbGlkZUluZGV4IDwgYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICdwcmV2JztcXG4gIGVsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcXG5cXG5cXG4gIC8vIFVwZGF0ZSBJbmRleFxcbiAgaWYgKChydGwgJiYgLXRyYW5zbGF0ZSA9PT0gc3dpcGVyLnRyYW5zbGF0ZSkgfHwgKCFydGwgJiYgdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSkge1xcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoc2xpZGVJbmRleCk7XFxuICAgIC8vIFVwZGF0ZSBIZWlnaHRcXG4gICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XFxuICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcXG4gICAgfVxcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICBpZiAocGFyYW1zLmVmZmVjdCAhPT0gJ3NsaWRlJykge1xcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcXG4gICAgfVxcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAncmVzZXQnKSB7XFxuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XFxuICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xcbiAgICB9XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XFxuICAgIGxldCB0ID0gLXRyYW5zbGF0ZTtcXG4gICAgaWYgKHJ0bCkge1xcbiAgICAgIHQgPSB3cmFwcGVyRWwuc2Nyb2xsV2lkdGggLSB3cmFwcGVyRWwub2Zmc2V0V2lkdGggLSB0O1xcbiAgICB9XFxuICAgIGlmIChzcGVlZCA9PT0gMCkge1xcbiAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSB0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgICAgIGlmICh3cmFwcGVyRWwuc2Nyb2xsVG8pIHtcXG4gICAgICAgIHdyYXBwZXJFbC5zY3JvbGxUbyh7XFxuICAgICAgICAgIFtpc0ggPyAnbGVmdCcgOiAndG9wJ106IHQsXFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gdDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBpZiAoc3BlZWQgPT09IDApIHtcXG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XFxuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcXG4gICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XFxuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcXG4gIH0gZWxzZSB7XFxuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcXG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoc2xpZGVJbmRleCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xcbiAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcXG4gICAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nKSB7XFxuICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XFxuICAgICAgaWYgKCFzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpIHtcXG4gICAgICAgIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XFxuICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XFxuICAgICAgICAgIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XFxuICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XFxuICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gc2xpZGVUb0xvb3AgKGluZGV4ID0gMCwgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcXG4gIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgbmV3SW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcXG4gIH1cXG5cXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xcbn1cXG5cXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFxcXCJvZmZcXFwiICovXFxuZnVuY3Rpb24gc2xpZGVOZXh0IChzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkLCBydW5DYWxsYmFja3MgPSB0cnVlLCBpbnRlcm5hbCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHsgcGFyYW1zLCBhbmltYXRpbmcgfSA9IHN3aXBlcjtcXG4gIGNvbnN0IGluY3JlbWVudCA9IHN3aXBlci5hY3RpdmVJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIGlmIChhbmltYXRpbmcpIHJldHVybiBmYWxzZTtcXG4gICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XFxuICB9XFxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4ICsgaW5jcmVtZW50LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XFxufVxcblxcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXFxcIm9mZlxcXCIgKi9cXG5mdW5jdGlvbiBzbGlkZVByZXYgKHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3Qge1xcbiAgICBwYXJhbXMsIGFuaW1hdGluZywgc25hcEdyaWQsIHNsaWRlc0dyaWQsIHJ0bFRyYW5zbGF0ZSxcXG4gIH0gPSBzd2lwZXI7XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgaWYgKGFuaW1hdGluZykgcmV0dXJuIGZhbHNlO1xcbiAgICBzd2lwZXIubG9vcEZpeCgpO1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcXG4gIH1cXG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWwpIHtcXG4gICAgaWYgKHZhbCA8IDApIHJldHVybiAtTWF0aC5mbG9vcihNYXRoLmFicyh2YWwpKTtcXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsKTtcXG4gIH1cXG4gIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2xhdGUgPSBub3JtYWxpemUodHJhbnNsYXRlKTtcXG4gIGNvbnN0IG5vcm1hbGl6ZWRTbmFwR3JpZCA9IHNuYXBHcmlkLm1hcCgodmFsKSA9PiBub3JtYWxpemUodmFsKSk7XFxuICBjb25zdCBub3JtYWxpemVkU2xpZGVzR3JpZCA9IHNsaWRlc0dyaWQubWFwKCh2YWwpID0+IG5vcm1hbGl6ZSh2YWwpKTtcXG5cXG4gIGNvbnN0IGN1cnJlbnRTbmFwID0gc25hcEdyaWRbbm9ybWFsaXplZFNuYXBHcmlkLmluZGV4T2Yobm9ybWFsaXplZFRyYW5zbGF0ZSldO1xcbiAgbGV0IHByZXZTbmFwID0gc25hcEdyaWRbbm9ybWFsaXplZFNuYXBHcmlkLmluZGV4T2Yobm9ybWFsaXplZFRyYW5zbGF0ZSkgLSAxXTtcXG4gIGlmICh0eXBlb2YgcHJldlNuYXAgPT09ICd1bmRlZmluZWQnICYmIHBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXApID0+IHtcXG4gICAgICBpZiAoIXByZXZTbmFwICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gc25hcCkgcHJldlNuYXAgPSBzbmFwO1xcbiAgICB9KTtcXG4gIH1cXG4gIGxldCBwcmV2SW5kZXg7XFxuICBpZiAodHlwZW9mIHByZXZTbmFwICE9PSAndW5kZWZpbmVkJykge1xcbiAgICBwcmV2SW5kZXggPSBzbGlkZXNHcmlkLmluZGV4T2YocHJldlNuYXApO1xcbiAgICBpZiAocHJldkluZGV4IDwgMCkgcHJldkluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMTtcXG4gIH1cXG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhwcmV2SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcXG59XFxuXFxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcXFwib2ZmXFxcIiAqL1xcbmZ1bmN0aW9uIHNsaWRlUmVzZXQgKHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xcbn1cXG5cXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFxcXCJvZmZcXFwiICovXFxuZnVuY3Rpb24gc2xpZGVUb0Nsb3Nlc3QgKHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsLCB0aHJlc2hvbGQgPSAwLjUpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBsZXQgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KTtcXG4gIGNvbnN0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChpbmRleCAtIHNraXApIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuXFxuICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xcblxcbiAgaWYgKHRyYW5zbGF0ZSA+PSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XSkge1xcbiAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgb24gb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxcbiAgICAvLyBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IGluZGV4IGFuZCB0aGUgb25lIGFmdGVyIGl0LlxcbiAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xcbiAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcXG4gICAgaWYgKCh0cmFuc2xhdGUgLSBjdXJyZW50U25hcCkgPiAobmV4dFNuYXAgLSBjdXJyZW50U25hcCkgKiB0aHJlc2hvbGQpIHtcXG4gICAgICBpbmRleCArPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgYmVmb3JlIHRoZSBjdXJyZW50IHNuYXAgaW5kZXgsIHNvIHRoZSBjaG9pY2VcXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBiZWZvcmUgaXQuXFxuICAgIGNvbnN0IHByZXZTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCAtIDFdO1xcbiAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xcbiAgICBpZiAoKHRyYW5zbGF0ZSAtIHByZXZTbmFwKSA8PSAoY3VycmVudFNuYXAgLSBwcmV2U25hcCkgKiB0aHJlc2hvbGQpIHtcXG4gICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xcbiAgICB9XFxuICB9XFxuICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcXG4gIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpO1xcblxcbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKGluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XFxufVxcblxcbmZ1bmN0aW9uIHNsaWRlVG9DbGlja2VkU2xpZGUgKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHsgcGFyYW1zLCAkd3JhcHBlckVsIH0gPSBzd2lwZXI7XFxuXFxuICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcGFyYW1zLnNsaWRlc1BlclZpZXc7XFxuICBsZXQgc2xpZGVUb0luZGV4ID0gc3dpcGVyLmNsaWNrZWRJbmRleDtcXG4gIGxldCByZWFsSW5kZXg7XFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcXG4gICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzd2lwZXIuY2xpY2tlZFNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XFxuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcXG4gICAgICBpZiAoXFxuICAgICAgICAoc2xpZGVUb0luZGV4IDwgc3dpcGVyLmxvb3BlZFNsaWRlcyAtIChzbGlkZXNQZXJWaWV3IC8gMikpXFxuICAgICAgICB8fCAoc2xpZGVUb0luZGV4ID4gKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcykgKyAoc2xpZGVzUGVyVmlldyAvIDIpKVxcbiAgICAgICkge1xcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgICAgIHNsaWRlVG9JbmRleCA9ICR3cmFwcGVyRWxcXG4gICAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7cmVhbEluZGV4fVxcXCJdOm5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYClcXG4gICAgICAgICAgLmVxKDApXFxuICAgICAgICAgIC5pbmRleCgpO1xcblxcbiAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xcbiAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgc2xpZGVUb0luZGV4ID0gJHdyYXBwZXJFbFxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7cmVhbEluZGV4fVxcXCJdOm5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYClcXG4gICAgICAgIC5lcSgwKVxcbiAgICAgICAgLmluZGV4KCk7XFxuXFxuICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xcbiAgfVxcbn1cXG5cXG52YXIgc2xpZGUgPSB7XFxuICBzbGlkZVRvLFxcbiAgc2xpZGVUb0xvb3AsXFxuICBzbGlkZU5leHQsXFxuICBzbGlkZVByZXYsXFxuICBzbGlkZVJlc2V0LFxcbiAgc2xpZGVUb0Nsb3Nlc3QsXFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlLFxcbn07XFxuXFxuZnVuY3Rpb24gbG9vcENyZWF0ZSAoKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgeyBwYXJhbXMsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVkIHNsaWRlc1xcbiAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7XFxuXFxuICBsZXQgc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XFxuXFxuICBpZiAocGFyYW1zLmxvb3BGaWxsR3JvdXBXaXRoQmxhbmspIHtcXG4gICAgY29uc3QgYmxhbmtTbGlkZXNOdW0gPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgLSAoc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuICAgIGlmIChibGFua1NsaWRlc051bSAhPT0gcGFyYW1zLnNsaWRlc1Blckdyb3VwKSB7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibGFua1NsaWRlc051bTsgaSArPSAxKSB7XFxuICAgICAgICBjb25zdCBibGFua05vZGUgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnKSkuYWRkQ2xhc3MoYCR7cGFyYW1zLnNsaWRlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKTtcXG4gICAgICAgICR3cmFwcGVyRWwuYXBwZW5kKGJsYW5rTm9kZSk7XFxuICAgICAgfVxcbiAgICAgIHNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiAhcGFyYW1zLmxvb3BlZFNsaWRlcykgcGFyYW1zLmxvb3BlZFNsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XFxuXFxuICBzd2lwZXIubG9vcGVkU2xpZGVzID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQocGFyYW1zLmxvb3BlZFNsaWRlcyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcXG4gIHN3aXBlci5sb29wZWRTbGlkZXMgKz0gcGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzO1xcbiAgaWYgKHN3aXBlci5sb29wZWRTbGlkZXMgPiBzbGlkZXMubGVuZ3RoKSB7XFxuICAgIHN3aXBlci5sb29wZWRTbGlkZXMgPSBzbGlkZXMubGVuZ3RoO1xcbiAgfVxcblxcbiAgY29uc3QgcHJlcGVuZFNsaWRlcyA9IFtdO1xcbiAgY29uc3QgYXBwZW5kU2xpZGVzID0gW107XFxuICBzbGlkZXMuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XFxuICAgIGNvbnN0IHNsaWRlID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShlbCk7XFxuICAgIGlmIChpbmRleCA8IHN3aXBlci5sb29wZWRTbGlkZXMpIGFwcGVuZFNsaWRlcy5wdXNoKGVsKTtcXG4gICAgaWYgKGluZGV4IDwgc2xpZGVzLmxlbmd0aCAmJiBpbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcykgcHJlcGVuZFNsaWRlcy5wdXNoKGVsKTtcXG4gICAgc2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBpbmRleCk7XFxuICB9KTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXBwZW5kU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYXBwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcXG4gIH1cXG4gIGZvciAobGV0IGkgPSBwcmVwZW5kU2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XFxuICAgICR3cmFwcGVyRWwucHJlcGVuZChPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHByZXBlbmRTbGlkZXNbaV0uY2xvbmVOb2RlKHRydWUpKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBsb29wRml4ICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBzd2lwZXIuZW1pdCgnYmVmb3JlTG9vcEZpeCcpO1xcblxcbiAgY29uc3Qge1xcbiAgICBhY3RpdmVJbmRleCwgc2xpZGVzLCBsb29wZWRTbGlkZXMsIGFsbG93U2xpZGVQcmV2LCBhbGxvd1NsaWRlTmV4dCwgc25hcEdyaWQsIHJ0bFRyYW5zbGF0ZTogcnRsLFxcbiAgfSA9IHN3aXBlcjtcXG4gIGxldCBuZXdJbmRleDtcXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XFxuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSB0cnVlO1xcblxcbiAgY29uc3Qgc25hcFRyYW5zbGF0ZSA9IC1zbmFwR3JpZFthY3RpdmVJbmRleF07XFxuICBjb25zdCBkaWZmID0gc25hcFRyYW5zbGF0ZSAtIHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcXG5cXG4gIC8vIEZpeCBGb3IgTmVnYXRpdmUgT3ZlcnNsaWRpbmdcXG4gIGlmIChhY3RpdmVJbmRleCA8IGxvb3BlZFNsaWRlcykge1xcbiAgICBuZXdJbmRleCA9IChzbGlkZXMubGVuZ3RoIC0gKGxvb3BlZFNsaWRlcyAqIDMpKSArIGFjdGl2ZUluZGV4O1xcbiAgICBuZXdJbmRleCArPSBsb29wZWRTbGlkZXM7XFxuICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XFxuICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChhY3RpdmVJbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gbG9vcGVkU2xpZGVzKSB7XFxuICAgIC8vIEZpeCBGb3IgUG9zaXRpdmUgT3ZlcnNsaWRpbmdcXG4gICAgbmV3SW5kZXggPSAtc2xpZGVzLmxlbmd0aCArIGFjdGl2ZUluZGV4ICsgbG9vcGVkU2xpZGVzO1xcbiAgICBuZXdJbmRleCArPSBsb29wZWRTbGlkZXM7XFxuICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XFxuICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcXG4gICAgfVxcbiAgfVxcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gYWxsb3dTbGlkZVByZXY7XFxuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcXG5cXG4gIHN3aXBlci5lbWl0KCdsb29wRml4Jyk7XFxufVxcblxcbmZ1bmN0aW9uIGxvb3BEZXN0cm95ICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBjb25zdCB7ICR3cmFwcGVyRWwsIHBhcmFtcywgc2xpZGVzIH0gPSBzd2lwZXI7XFxuICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30sLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKS5yZW1vdmUoKTtcXG4gIHNsaWRlcy5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xcbn1cXG5cXG52YXIgbG9vcCA9IHtcXG4gIGxvb3BDcmVhdGUsXFxuICBsb29wRml4LFxcbiAgbG9vcERlc3Ryb3ksXFxufTtcXG5cXG5mdW5jdGlvbiBzZXRHcmFiQ3Vyc29yIChtb3ZpbmcpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBpZiAoU3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkKSB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHJldHVybjtcXG4gIGNvbnN0IGVsID0gc3dpcGVyLmVsO1xcbiAgZWwuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xcbiAgZWwuc3R5bGUuY3Vyc29yID0gbW92aW5nID8gJy13ZWJraXQtZ3JhYmJpbmcnIDogJy13ZWJraXQtZ3JhYic7XFxuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnLW1vei1ncmFiYmluJyA6ICctbW96LWdyYWInO1xcbiAgZWwuc3R5bGUuY3Vyc29yID0gbW92aW5nID8gJ2dyYWJiaW5nJyA6ICdncmFiJztcXG59XFxuXFxuZnVuY3Rpb24gdW5zZXRHcmFiQ3Vyc29yICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBpZiAoU3VwcG9ydC50b3VjaCB8fCAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCkgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XFxuICBzd2lwZXIuZWwuc3R5bGUuY3Vyc29yID0gJyc7XFxufVxcblxcbnZhciBncmFiQ3Vyc29yID0ge1xcbiAgc2V0R3JhYkN1cnNvcixcXG4gIHVuc2V0R3JhYkN1cnNvcixcXG59O1xcblxcbmZ1bmN0aW9uIGFwcGVuZFNsaWRlIChzbGlkZXMpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBjb25zdCB7ICR3cmFwcGVyRWwsIHBhcmFtcyB9ID0gc3dpcGVyO1xcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBzbGlkZXMgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHNsaWRlcykge1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGlmIChzbGlkZXNbaV0pICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlc1tpXSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlcyk7XFxuICB9XFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcXG4gIH1cXG4gIGlmICghKHBhcmFtcy5vYnNlcnZlciAmJiBTdXBwb3J0Lm9ic2VydmVyKSkge1xcbiAgICBzd2lwZXIudXBkYXRlKCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHByZXBlbmRTbGlkZSAoc2xpZGVzKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgeyBwYXJhbXMsICR3cmFwcGVyRWwsIGFjdGl2ZUluZGV4IH0gPSBzd2lwZXI7XFxuXFxuICBpZiAocGFyYW1zLmxvb3ApIHtcXG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XFxuICB9XFxuICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIDE7XFxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5wcmVwZW5kKHNsaWRlc1tpXSk7XFxuICAgIH1cXG4gICAgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIHNsaWRlcy5sZW5ndGg7XFxuICB9IGVsc2Uge1xcbiAgICAkd3JhcHBlckVsLnByZXBlbmQoc2xpZGVzKTtcXG4gIH1cXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgfVxcbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIFN1cHBvcnQub2JzZXJ2ZXIpKSB7XFxuICAgIHN3aXBlci51cGRhdGUoKTtcXG4gIH1cXG4gIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4LCAwLCBmYWxzZSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZFNsaWRlIChpbmRleCwgc2xpZGVzKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgeyAkd3JhcHBlckVsLCBwYXJhbXMsIGFjdGl2ZUluZGV4IH0gPSBzd2lwZXI7XFxuICBsZXQgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcXG4gIGlmIChwYXJhbXMubG9vcCkge1xcbiAgICBhY3RpdmVJbmRleEJ1ZmZlciAtPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcXG4gICAgc3dpcGVyLnNsaWRlcyA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xcbiAgfVxcbiAgY29uc3QgYmFzZUxlbmd0aCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xcbiAgaWYgKGluZGV4IDw9IDApIHtcXG4gICAgc3dpcGVyLnByZXBlbmRTbGlkZShzbGlkZXMpO1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAoaW5kZXggPj0gYmFzZUxlbmd0aCkge1xcbiAgICBzd2lwZXIuYXBwZW5kU2xpZGUoc2xpZGVzKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXhCdWZmZXIgPiBpbmRleCA/IGFjdGl2ZUluZGV4QnVmZmVyICsgMSA6IGFjdGl2ZUluZGV4QnVmZmVyO1xcblxcbiAgY29uc3Qgc2xpZGVzQnVmZmVyID0gW107XFxuICBmb3IgKGxldCBpID0gYmFzZUxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGkgLT0gMSkge1xcbiAgICBjb25zdCBjdXJyZW50U2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xcbiAgICBjdXJyZW50U2xpZGUucmVtb3ZlKCk7XFxuICAgIHNsaWRlc0J1ZmZlci51bnNoaWZ0KGN1cnJlbnRTbGlkZSk7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVzW2ldKTtcXG4gICAgfVxcbiAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIHNsaWRlcy5sZW5ndGggOiBhY3RpdmVJbmRleEJ1ZmZlcjtcXG4gIH0gZWxzZSB7XFxuICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlcyk7XFxuICB9XFxuXFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0J1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNCdWZmZXJbaV0pO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XFxuICB9XFxuICBpZiAoIShwYXJhbXMub2JzZXJ2ZXIgJiYgU3VwcG9ydC5vYnNlcnZlcikpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xcbiAgfVxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4ICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDAsIGZhbHNlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlU2xpZGUgKHNsaWRlc0luZGV4ZXMpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCwgYWN0aXZlSW5kZXggfSA9IHN3aXBlcjtcXG5cXG4gIGxldCBhY3RpdmVJbmRleEJ1ZmZlciA9IGFjdGl2ZUluZGV4O1xcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIGFjdGl2ZUluZGV4QnVmZmVyIC09IHN3aXBlci5sb29wZWRTbGlkZXM7XFxuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xcbiAgICBzd2lwZXIuc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XFxuICB9XFxuICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleEJ1ZmZlcjtcXG4gIGxldCBpbmRleFRvUmVtb3ZlO1xcblxcbiAgaWYgKHR5cGVvZiBzbGlkZXNJbmRleGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXNJbmRleGVzKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzSW5kZXhlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGluZGV4VG9SZW1vdmUgPSBzbGlkZXNJbmRleGVzW2ldO1xcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdKSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4VG9SZW1vdmUpLnJlbW92ZSgpO1xcbiAgICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgbmV3QWN0aXZlSW5kZXgpIG5ld0FjdGl2ZUluZGV4IC09IDE7XFxuICAgIH1cXG4gICAgbmV3QWN0aXZlSW5kZXggPSBNYXRoLm1heChuZXdBY3RpdmVJbmRleCwgMCk7XFxuICB9IGVsc2Uge1xcbiAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlcztcXG4gICAgaWYgKHN3aXBlci5zbGlkZXNbaW5kZXhUb1JlbW92ZV0pIHN3aXBlci5zbGlkZXMuZXEoaW5kZXhUb1JlbW92ZSkucmVtb3ZlKCk7XFxuICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgbmV3QWN0aXZlSW5kZXgpIG5ld0FjdGl2ZUluZGV4IC09IDE7XFxuICAgIG5ld0FjdGl2ZUluZGV4ID0gTWF0aC5tYXgobmV3QWN0aXZlSW5kZXgsIDApO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XFxuICB9XFxuXFxuICBpZiAoIShwYXJhbXMub2JzZXJ2ZXIgJiYgU3VwcG9ydC5vYnNlcnZlcikpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xcbiAgfVxcbiAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4ICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDAsIGZhbHNlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQWxsU2xpZGVzICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBjb25zdCBzbGlkZXNJbmRleGVzID0gW107XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgc2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xcbiAgfVxcbiAgc3dpcGVyLnJlbW92ZVNsaWRlKHNsaWRlc0luZGV4ZXMpO1xcbn1cXG5cXG52YXIgbWFuaXB1bGF0aW9uID0ge1xcbiAgYXBwZW5kU2xpZGUsXFxuICBwcmVwZW5kU2xpZGUsXFxuICBhZGRTbGlkZSxcXG4gIHJlbW92ZVNsaWRlLFxcbiAgcmVtb3ZlQWxsU2xpZGVzLFxcbn07XFxuXFxuY29uc3QgRGV2aWNlID0gKGZ1bmN0aW9uIERldmljZSgpIHtcXG4gIGNvbnN0IHBsYXRmb3JtID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5uYXZpZ2F0b3IucGxhdGZvcm07XFxuICBjb25zdCB1YSA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yLnVzZXJBZ2VudDtcXG5cXG4gIGNvbnN0IGRldmljZSA9IHtcXG4gICAgaW9zOiBmYWxzZSxcXG4gICAgYW5kcm9pZDogZmFsc2UsXFxuICAgIGFuZHJvaWRDaHJvbWU6IGZhbHNlLFxcbiAgICBkZXNrdG9wOiBmYWxzZSxcXG4gICAgaXBob25lOiBmYWxzZSxcXG4gICAgaXBvZDogZmFsc2UsXFxuICAgIGlwYWQ6IGZhbHNlLFxcbiAgICBlZGdlOiBmYWxzZSxcXG4gICAgaWU6IGZhbHNlLFxcbiAgICBmaXJlZm94OiBmYWxzZSxcXG4gICAgbWFjb3M6IGZhbHNlLFxcbiAgICB3aW5kb3dzOiBmYWxzZSxcXG4gICAgY29yZG92YTogISEoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5jb3Jkb3ZhIHx8IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ucGhvbmVnYXApLFxcbiAgICBwaG9uZWdhcDogISEoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5jb3Jkb3ZhIHx8IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ucGhvbmVnYXApLFxcbiAgICBlbGVjdHJvbjogZmFsc2UsXFxuICB9O1xcblxcbiAgY29uc3Qgc2NyZWVuV2lkdGggPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLnNjcmVlbi53aWR0aDtcXG4gIGNvbnN0IHNjcmVlbkhlaWdodCA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uc2NyZWVuLmhlaWdodDtcXG5cXG4gIGNvbnN0IGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxcXHNcXFxcL10rKFtcXFxcZC5dKyk/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG4gIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXFxccyhbXFxcXGRfXSspLyk7XFxuICBjb25zdCBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxcXHMoW1xcXFxkX10rKSk/Lyk7XFxuICBjb25zdCBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcXFxzT1N8aU9TKVxcXFxzKFtcXFxcZF9dKykvKTtcXG4gIGNvbnN0IGllID0gdWEuaW5kZXhPZignTVNJRSAnKSA+PSAwIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPj0gMDtcXG4gIGNvbnN0IGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpID49IDA7XFxuICBjb25zdCBmaXJlZm94ID0gdWEuaW5kZXhPZignR2Vja28vJykgPj0gMCAmJiB1YS5pbmRleE9mKCdGaXJlZm94LycpID49IDA7XFxuICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XFxuICBjb25zdCBlbGVjdHJvbiA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZWxlY3Ryb24nKSA+PSAwO1xcbiAgbGV0IG1hY29zID0gcGxhdGZvcm0gPT09ICdNYWNJbnRlbCc7XFxuXFxuICAvLyBpUGFkT3MgMTMgZml4XFxuICBpZiAoIWlwYWRcXG4gICAgJiYgbWFjb3NcXG4gICAgJiYgU3VwcG9ydC50b3VjaFxcbiAgICAmJiAoXFxuICAgICAgKHNjcmVlbldpZHRoID09PSAxMDI0ICYmIHNjcmVlbkhlaWdodCA9PT0gMTM2NikgLy8gUHJvIDEyLjlcXG4gICAgICB8fCAoc2NyZWVuV2lkdGggPT09IDgzNCAmJiBzY3JlZW5IZWlnaHQgPT09IDExOTQpIC8vIFBybyAxMVxcbiAgICAgIHx8IChzY3JlZW5XaWR0aCA9PT0gODM0ICYmIHNjcmVlbkhlaWdodCA9PT0gMTExMikgLy8gUHJvIDEwLjVcXG4gICAgICB8fCAoc2NyZWVuV2lkdGggPT09IDc2OCAmJiBzY3JlZW5IZWlnaHQgPT09IDEwMjQpIC8vIG90aGVyXFxuICAgIClcXG4gICkge1xcbiAgICBpcGFkID0gdWEubWF0Y2goLyhWZXJzaW9uKVxcXFwvKFtcXFxcZC5dKykvKTtcXG4gICAgbWFjb3MgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGRldmljZS5pZSA9IGllO1xcbiAgZGV2aWNlLmVkZ2UgPSBlZGdlO1xcbiAgZGV2aWNlLmZpcmVmb3ggPSBmaXJlZm94O1xcblxcbiAgLy8gQW5kcm9pZFxcbiAgaWYgKGFuZHJvaWQgJiYgIXdpbmRvd3MpIHtcXG4gICAgZGV2aWNlLm9zID0gJ2FuZHJvaWQnO1xcbiAgICBkZXZpY2Uub3NWZXJzaW9uID0gYW5kcm9pZFsyXTtcXG4gICAgZGV2aWNlLmFuZHJvaWQgPSB0cnVlO1xcbiAgICBkZXZpY2UuYW5kcm9pZENocm9tZSA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPj0gMDtcXG4gIH1cXG4gIGlmIChpcGFkIHx8IGlwaG9uZSB8fCBpcG9kKSB7XFxuICAgIGRldmljZS5vcyA9ICdpb3MnO1xcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcXG4gIH1cXG4gIC8vIGlPU1xcbiAgaWYgKGlwaG9uZSAmJiAhaXBvZCkge1xcbiAgICBkZXZpY2Uub3NWZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcXG4gICAgZGV2aWNlLmlwaG9uZSA9IHRydWU7XFxuICB9XFxuICBpZiAoaXBhZCkge1xcbiAgICBkZXZpY2Uub3NWZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XFxuICAgIGRldmljZS5pcGFkID0gdHJ1ZTtcXG4gIH1cXG4gIGlmIChpcG9kKSB7XFxuICAgIGRldmljZS5vc1ZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xcbiAgICBkZXZpY2UuaXBvZCA9IHRydWU7XFxuICB9XFxuICAvLyBpT1MgOCsgY2hhbmdlZCBVQVxcbiAgaWYgKGRldmljZS5pb3MgJiYgZGV2aWNlLm9zVmVyc2lvbiAmJiB1YS5pbmRleE9mKCdWZXJzaW9uLycpID49IDApIHtcXG4gICAgaWYgKGRldmljZS5vc1ZlcnNpb24uc3BsaXQoJy4nKVswXSA9PT0gJzEwJykge1xcbiAgICAgIGRldmljZS5vc1ZlcnNpb24gPSB1YS50b0xvd2VyQ2FzZSgpLnNwbGl0KCd2ZXJzaW9uLycpWzFdLnNwbGl0KCcgJylbMF07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFdlYnZpZXdcXG4gIGRldmljZS53ZWJWaWV3ID0gISEoKGlwaG9uZSB8fCBpcGFkIHx8IGlwb2QpICYmICh1YS5tYXRjaCgvLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pKSB8fCBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLm5hdmlnYXRvci5zdGFuZGFsb25lKSlcXG4gICAgfHwgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubWF0Y2hNZWRpYSAmJiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLm1hdGNoTWVkaWEoJyhkaXNwbGF5LW1vZGU6IHN0YW5kYWxvbmUpJykubWF0Y2hlcyk7XFxuICBkZXZpY2Uud2VidmlldyA9IGRldmljZS53ZWJWaWV3O1xcbiAgZGV2aWNlLnN0YW5kYWxvbmUgPSBkZXZpY2Uud2ViVmlldztcXG5cXG4gIC8vIERlc2t0b3BcXG4gIGRldmljZS5kZXNrdG9wID0gIShkZXZpY2UuaW9zIHx8IGRldmljZS5hbmRyb2lkKSB8fCBlbGVjdHJvbjtcXG4gIGlmIChkZXZpY2UuZGVza3RvcCkge1xcbiAgICBkZXZpY2UuZWxlY3Ryb24gPSBlbGVjdHJvbjtcXG4gICAgZGV2aWNlLm1hY29zID0gbWFjb3M7XFxuICAgIGRldmljZS53aW5kb3dzID0gd2luZG93cztcXG4gICAgaWYgKGRldmljZS5tYWNvcykge1xcbiAgICAgIGRldmljZS5vcyA9ICdtYWNvcyc7XFxuICAgIH1cXG4gICAgaWYgKGRldmljZS53aW5kb3dzKSB7XFxuICAgICAgZGV2aWNlLm9zID0gJ3dpbmRvd3MnO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBQaXhlbCBSYXRpb1xcbiAgZGV2aWNlLnBpeGVsUmF0aW8gPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcXG5cXG4gIC8vIEV4cG9ydCBvYmplY3RcXG4gIHJldHVybiBkZXZpY2U7XFxufSgpKTtcXG5cXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQgKGV2ZW50KSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XFxuICBjb25zdCB7IHBhcmFtcywgdG91Y2hlcyB9ID0gc3dpcGVyO1xcblxcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBsZXQgZSA9IGV2ZW50O1xcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcXG4gIGNvbnN0ICR0YXJnZXRFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoZS50YXJnZXQpO1xcblxcbiAgaWYgKHBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ3dyYXBwZXInKSB7XFxuICAgIGlmICghJHRhcmdldEVsLmNsb3Nlc3Qoc3dpcGVyLndyYXBwZXJFbCkubGVuZ3RoKSByZXR1cm47XFxuICB9XFxuICBkYXRhLmlzVG91Y2hFdmVudCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xcbiAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xcbiAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uID4gMCkgcmV0dXJuO1xcbiAgaWYgKGRhdGEuaXNUb3VjaGVkICYmIGRhdGEuaXNNb3ZlZCkgcmV0dXJuO1xcbiAgaWYgKHBhcmFtcy5ub1N3aXBpbmcgJiYgJHRhcmdldEVsLmNsb3Nlc3QocGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yID8gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke3BhcmFtcy5ub1N3aXBpbmdDbGFzc31gKVswXSkge1xcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmIChwYXJhbXMuc3dpcGVIYW5kbGVyKSB7XFxuICAgIGlmICghJHRhcmdldEVsLmNsb3Nlc3QocGFyYW1zLnN3aXBlSGFuZGxlcilbMF0pIHJldHVybjtcXG4gIH1cXG5cXG4gIHRvdWNoZXMuY3VycmVudFggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XFxuICB0b3VjaGVzLmN1cnJlbnRZID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xcbiAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcXG4gIGNvbnN0IHN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7XFxuXFxuICAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcXG5cXG4gIGNvbnN0IGVkZ2VTd2lwZURldGVjdGlvbiA9IHBhcmFtcy5lZGdlU3dpcGVEZXRlY3Rpb24gfHwgcGFyYW1zLmlPU0VkZ2VTd2lwZURldGVjdGlvbjtcXG4gIGNvbnN0IGVkZ2VTd2lwZVRocmVzaG9sZCA9IHBhcmFtcy5lZGdlU3dpcGVUaHJlc2hvbGQgfHwgcGFyYW1zLmlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcXG4gIGlmIChcXG4gICAgZWRnZVN3aXBlRGV0ZWN0aW9uXFxuICAgICYmICgoc3RhcnRYIDw9IGVkZ2VTd2lwZVRocmVzaG9sZClcXG4gICAgfHwgKHN0YXJ0WCA+PSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLnNjcmVlbi53aWR0aCAtIGVkZ2VTd2lwZVRocmVzaG9sZCkpXFxuICApIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgVXRpbHMuZXh0ZW5kKGRhdGEsIHtcXG4gICAgaXNUb3VjaGVkOiB0cnVlLFxcbiAgICBpc01vdmVkOiBmYWxzZSxcXG4gICAgYWxsb3dUb3VjaENhbGxiYWNrczogdHJ1ZSxcXG4gICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZCxcXG4gIH0pO1xcblxcbiAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XFxuICB0b3VjaGVzLnN0YXJ0WSA9IHN0YXJ0WTtcXG4gIGRhdGEudG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcXG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcXG4gIHN3aXBlci51cGRhdGVTaXplKCk7XFxuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XFxuICBpZiAoZS50eXBlICE9PSAndG91Y2hzdGFydCcpIHtcXG4gICAgbGV0IHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcXG4gICAgaWYgKCR0YXJnZXRFbC5pcyhkYXRhLmZvcm1FbGVtZW50cykpIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XFxuICAgIGlmIChcXG4gICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uYWN0aXZlRWxlbWVudFxcbiAgICAgICYmIE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKVxcbiAgICAgICYmIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hY3RpdmVFbGVtZW50ICE9PSAkdGFyZ2V0RWxbMF1cXG4gICAgKSB7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNob3VsZFByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQgJiYgc3dpcGVyLmFsbG93VG91Y2hNb3ZlICYmIHBhcmFtcy50b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ7XFxuICAgIGlmIChwYXJhbXMudG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQgfHwgc2hvdWxkUHJldmVudERlZmF1bHQpIHtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG4gIH1cXG4gIHN3aXBlci5lbWl0KCd0b3VjaFN0YXJ0JywgZSk7XFxufVxcblxcbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlIChldmVudCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xcbiAgY29uc3QgeyBwYXJhbXMsIHRvdWNoZXMsIHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XFxuICBsZXQgZSA9IGV2ZW50O1xcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcXG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcXG4gICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xcbiAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBlLnR5cGUgIT09ICd0b3VjaG1vdmUnKSByZXR1cm47XFxuICBjb25zdCB0YXJnZXRUb3VjaCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzICYmIChlLnRhcmdldFRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXSk7XFxuICBjb25zdCBwYWdlWCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWCA6IGUucGFnZVg7XFxuICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWSA6IGUucGFnZVk7XFxuICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xcbiAgICB0b3VjaGVzLnN0YXJ0WCA9IHBhZ2VYO1xcbiAgICB0b3VjaGVzLnN0YXJ0WSA9IHBhZ2VZO1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAoIXN3aXBlci5hbGxvd1RvdWNoTW92ZSkge1xcbiAgICAvLyBpc01vdmVkID0gdHJ1ZTtcXG4gICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcXG4gICAgaWYgKGRhdGEuaXNUb3VjaGVkKSB7XFxuICAgICAgVXRpbHMuZXh0ZW5kKHRvdWNoZXMsIHtcXG4gICAgICAgIHN0YXJ0WDogcGFnZVgsXFxuICAgICAgICBzdGFydFk6IHBhZ2VZLFxcbiAgICAgICAgY3VycmVudFg6IHBhZ2VYLFxcbiAgICAgICAgY3VycmVudFk6IHBhZ2VZLFxcbiAgICAgIH0pO1xcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgcGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXBhcmFtcy5sb29wKSB7XFxuICAgIGlmIChzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XFxuICAgICAgLy8gVmVydGljYWxcXG4gICAgICBpZiAoXFxuICAgICAgICAocGFnZVkgPCB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSlcXG4gICAgICAgIHx8IChwYWdlWSA+IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKVxcbiAgICAgICkge1xcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChcXG4gICAgICAocGFnZVggPCB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSlcXG4gICAgICB8fCAocGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSlcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgaWYgKGUudGFyZ2V0ID09PSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uYWN0aXZlRWxlbWVudCAmJiBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGUudGFyZ2V0KS5pcyhkYXRhLmZvcm1FbGVtZW50cykpIHtcXG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuICBpZiAoZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzKSB7XFxuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmUnLCBlKTtcXG4gIH1cXG4gIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcXG5cXG4gIHRvdWNoZXMuY3VycmVudFggPSBwYWdlWDtcXG4gIHRvdWNoZXMuY3VycmVudFkgPSBwYWdlWTtcXG5cXG4gIGNvbnN0IGRpZmZYID0gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYO1xcbiAgY29uc3QgZGlmZlkgPSB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XFxuICBpZiAoc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQgJiYgTWF0aC5zcXJ0KChkaWZmWCAqKiAyKSArIChkaWZmWSAqKiAyKSkgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xcblxcbiAgaWYgKHR5cGVvZiBkYXRhLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xcbiAgICBsZXQgdG91Y2hBbmdsZTtcXG4gICAgaWYgKChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgdG91Y2hlcy5jdXJyZW50WSA9PT0gdG91Y2hlcy5zdGFydFkpIHx8IChzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSkge1xcbiAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBmYWxzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBpZiAoKGRpZmZYICogZGlmZlgpICsgKGRpZmZZICogZGlmZlkpID49IDI1KSB7XFxuICAgICAgICB0b3VjaEFuZ2xlID0gKE1hdGguYXRhbjIoTWF0aC5hYnMoZGlmZlkpLCBNYXRoLmFicyhkaWZmWCkpICogMTgwKSAvIE1hdGguUEk7XFxuICAgICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlIDogKDkwIC0gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XFxuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBkYXRhLnN0YXJ0TW92aW5nID09PSAndW5kZWZpbmVkJykge1xcbiAgICBpZiAodG91Y2hlcy5jdXJyZW50WCAhPT0gdG91Y2hlcy5zdGFydFggfHwgdG91Y2hlcy5jdXJyZW50WSAhPT0gdG91Y2hlcy5zdGFydFkpIHtcXG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcXG4gICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKCFkYXRhLnN0YXJ0TW92aW5nKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XFxuICBpZiAoIXBhcmFtcy5jc3NNb2RlICYmIGUuY2FuY2VsYWJsZSkge1xcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICB9XFxuICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgfVxcblxcbiAgaWYgKCFkYXRhLmlzTW92ZWQpIHtcXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcXG4gICAgfVxcbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcXG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC50cmlnZ2VyKCd3ZWJraXRUcmFuc2l0aW9uRW5kIHRyYW5zaXRpb25lbmQnKTtcXG4gICAgfVxcbiAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTtcXG4gICAgLy8gR3JhYiBDdXJzb3JcXG4gICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKHRydWUpO1xcbiAgICB9XFxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcXG4gIH1cXG4gIHN3aXBlci5lbWl0KCdzbGlkZXJNb3ZlJywgZSk7XFxuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xcblxcbiAgbGV0IGRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBkaWZmWCA6IGRpZmZZO1xcbiAgdG91Y2hlcy5kaWZmID0gZGlmZjtcXG5cXG4gIGRpZmYgKj0gcGFyYW1zLnRvdWNoUmF0aW87XFxuICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XFxuXFxuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcXG4gIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xcblxcbiAgbGV0IGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xcbiAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XFxuICBpZiAocGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMpIHtcXG4gICAgcmVzaXN0YW5jZVJhdGlvID0gMDtcXG4gIH1cXG4gIGlmICgoZGlmZiA+IDAgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSkge1xcbiAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XFxuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEpICsgKCgtc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgZGF0YS5zdGFydFRyYW5zbGF0ZSArIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbyk7XFxuICB9IGVsc2UgaWYgKGRpZmYgPCAwICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xcbiAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XFxuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEpIC0gKChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvKTtcXG4gIH1cXG5cXG4gIGlmIChkaXNhYmxlUGFyZW50U3dpcGVyKSB7XFxuICAgIGUucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIgPSB0cnVlO1xcbiAgfVxcblxcbiAgLy8gRGlyZWN0aW9ucyBsb2Nrc1xcbiAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZU5leHQgJiYgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xcbiAgfVxcbiAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xcbiAgfVxcblxcblxcbiAgLy8gVGhyZXNob2xkXFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcXG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xcbiAgICAgIGlmICghZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcXG4gICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcXG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcXG4gICAgICAgIHRvdWNoZXMuc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcXG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XFxuICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIgfHwgcGFyYW1zLmNzc01vZGUpIHJldHVybjtcXG5cXG4gIC8vIFVwZGF0ZSBhY3RpdmUgaW5kZXggaW4gZnJlZSBtb2RlXFxuICBpZiAocGFyYW1zLmZyZWVNb2RlIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICB9XFxuICBpZiAocGFyYW1zLmZyZWVNb2RlKSB7XFxuICAgIC8vIFZlbG9jaXR5XFxuICAgIGlmIChkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgZGF0YS52ZWxvY2l0aWVzLnB1c2goe1xcbiAgICAgICAgcG9zaXRpb246IHRvdWNoZXNbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3N0YXJ0WCcgOiAnc3RhcnRZJ10sXFxuICAgICAgICB0aW1lOiBkYXRhLnRvdWNoU3RhcnRUaW1lLFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcXG4gICAgICBwb3NpdGlvbjogdG91Y2hlc1tzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnY3VycmVudFgnIDogJ2N1cnJlbnRZJ10sXFxuICAgICAgdGltZTogVXRpbHMubm93KCksXFxuICAgIH0pO1xcbiAgfVxcbiAgLy8gVXBkYXRlIHByb2dyZXNzXFxuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcXG4gIC8vIFVwZGF0ZSB0cmFuc2xhdGVcXG4gIHN3aXBlci5zZXRUcmFuc2xhdGUoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcXG59XFxuXFxuZnVuY3Rpb24gb25Ub3VjaEVuZCAoZXZlbnQpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcXG5cXG4gIGNvbnN0IHtcXG4gICAgcGFyYW1zLCB0b3VjaGVzLCBydGxUcmFuc2xhdGU6IHJ0bCwgJHdyYXBwZXJFbCwgc2xpZGVzR3JpZCwgc25hcEdyaWQsXFxuICB9ID0gc3dpcGVyO1xcbiAgbGV0IGUgPSBldmVudDtcXG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XFxuICBpZiAoZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzKSB7XFxuICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xcbiAgfVxcbiAgZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzID0gZmFsc2U7XFxuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XFxuICAgIGlmIChkYXRhLmlzTW92ZWQgJiYgcGFyYW1zLmdyYWJDdXJzb3IpIHtcXG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcihmYWxzZSk7XFxuICAgIH1cXG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XFxuICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgLy8gUmV0dXJuIEdyYWIgQ3Vyc29yXFxuICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgZGF0YS5pc01vdmVkICYmIGRhdGEuaXNUb3VjaGVkICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xcbiAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcihmYWxzZSk7XFxuICB9XFxuXFxuICAvLyBUaW1lIGRpZmZcXG4gIGNvbnN0IHRvdWNoRW5kVGltZSA9IFV0aWxzLm5vdygpO1xcbiAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lO1xcblxcbiAgLy8gVGFwLCBkb3VibGVUYXAsIENsaWNrXFxuICBpZiAoc3dpcGVyLmFsbG93Q2xpY2spIHtcXG4gICAgc3dpcGVyLnVwZGF0ZUNsaWNrZWRTbGlkZShlKTtcXG4gICAgc3dpcGVyLmVtaXQoJ3RhcCBjbGljaycsIGUpO1xcbiAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgKHRvdWNoRW5kVGltZSAtIGRhdGEubGFzdENsaWNrVGltZSkgPCAzMDApIHtcXG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRhdGEubGFzdENsaWNrVGltZSA9IFV0aWxzLm5vdygpO1xcbiAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xcbiAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcXG4gIH0pO1xcblxcbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCB8fCAhZGF0YS5pc01vdmVkIHx8ICFzd2lwZXIuc3dpcGVEaXJlY3Rpb24gfHwgdG91Y2hlcy5kaWZmID09PSAwIHx8IGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9PT0gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xcbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcXG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xcbiAgICByZXR1cm47XFxuICB9XFxuICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xcbiAgZGF0YS5pc01vdmVkID0gZmFsc2U7XFxuICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XFxuXFxuICBsZXQgY3VycmVudFBvcztcXG4gIGlmIChwYXJhbXMuZm9sbG93RmluZ2VyKSB7XFxuICAgIGN1cnJlbnRQb3MgPSBydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XFxuICB9IGVsc2Uge1xcbiAgICBjdXJyZW50UG9zID0gLWRhdGEuY3VycmVudFRyYW5zbGF0ZTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLmZyZWVNb2RlKSB7XFxuICAgIGlmIChjdXJyZW50UG9zIDwgLXN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChjdXJyZW50UG9zID4gLXN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzLmxlbmd0aCA8IHNuYXBHcmlkLmxlbmd0aCkge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc25hcEdyaWQubGVuZ3RoIC0gMSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW0pIHtcXG4gICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGNvbnN0IGxhc3RNb3ZlRXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XFxuICAgICAgICBjb25zdCB2ZWxvY2l0eUV2ZW50ID0gZGF0YS52ZWxvY2l0aWVzLnBvcCgpO1xcblxcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBsYXN0TW92ZUV2ZW50LnBvc2l0aW9uIC0gdmVsb2NpdHlFdmVudC5wb3NpdGlvbjtcXG4gICAgICAgIGNvbnN0IHRpbWUgPSBsYXN0TW92ZUV2ZW50LnRpbWUgLSB2ZWxvY2l0eUV2ZW50LnRpbWU7XFxuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XFxuICAgICAgICBzd2lwZXIudmVsb2NpdHkgLz0gMjtcXG4gICAgICAgIGlmIChNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpIDwgcGFyYW1zLmZyZWVNb2RlTWluaW11bVZlbG9jaXR5KSB7XFxuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgICAvLyB0aGlzIGltcGxpZXMgdGhhdCB0aGUgdXNlciBzdG9wcGVkIG1vdmluZyBhIGZpbmdlciB0aGVuIHJlbGVhc2VkLlxcbiAgICAgICAgLy8gVGhlcmUgd291bGQgYmUgbm8gZXZlbnRzIHdpdGggZGlzdGFuY2UgemVybywgc28gdGhlIGxhc3QgZXZlbnQgaXMgc3RhbGUuXFxuICAgICAgICBpZiAodGltZSA+IDE1MCB8fCAoVXRpbHMubm93KCkgLSBsYXN0TW92ZUV2ZW50LnRpbWUpID4gMzAwKSB7XFxuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XFxuICAgICAgfVxcbiAgICAgIHN3aXBlci52ZWxvY2l0eSAqPSBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bVZlbG9jaXR5UmF0aW87XFxuXFxuICAgICAgZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XFxuICAgICAgbGV0IG1vbWVudHVtRHVyYXRpb24gPSAxMDAwICogcGFyYW1zLmZyZWVNb2RlTW9tZW50dW1SYXRpbztcXG4gICAgICBjb25zdCBtb21lbnR1bURpc3RhbmNlID0gc3dpcGVyLnZlbG9jaXR5ICogbW9tZW50dW1EdXJhdGlvbjtcXG5cXG4gICAgICBsZXQgbmV3UG9zaXRpb24gPSBzd2lwZXIudHJhbnNsYXRlICsgbW9tZW50dW1EaXN0YW5jZTtcXG4gICAgICBpZiAocnRsKSBuZXdQb3NpdGlvbiA9IC1uZXdQb3NpdGlvbjtcXG5cXG4gICAgICBsZXQgZG9Cb3VuY2UgPSBmYWxzZTtcXG4gICAgICBsZXQgYWZ0ZXJCb3VuY2VQb3NpdGlvbjtcXG4gICAgICBjb25zdCBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xcbiAgICAgIGxldCBuZWVkc0xvb3BGaXg7XFxuICAgICAgaWYgKG5ld1Bvc2l0aW9uIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XFxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICsgc3dpcGVyLm1heFRyYW5zbGF0ZSgpIDwgLWJvdW5jZUFtb3VudCkge1xcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gYm91bmNlQW1vdW50O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGFmdGVyQm91bmNlUG9zaXRpb24gPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XFxuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcXG4gICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBhcmFtcy5sb29wICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlcykgbmVlZHNMb29wRml4ID0gdHJ1ZTtcXG4gICAgICB9IGVsc2UgaWYgKG5ld1Bvc2l0aW9uID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XFxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpID4gYm91bmNlQW1vdW50KSB7XFxuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgKyBib3VuY2VBbW91bnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcXG4gICAgICAgICAgZG9Cb3VuY2UgPSB0cnVlO1xcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICBsZXQgbmV4dFNsaWRlO1xcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbmFwR3JpZC5sZW5ndGg7IGogKz0gMSkge1xcbiAgICAgICAgICBpZiAoc25hcEdyaWRbal0gPiAtbmV3UG9zaXRpb24pIHtcXG4gICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlXSAtIG5ld1Bvc2l0aW9uKSA8IE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZSAtIDFdIC0gbmV3UG9zaXRpb24pIHx8IHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlIC0gMV07XFxuICAgICAgICB9XFxuICAgICAgICBuZXdQb3NpdGlvbiA9IC1uZXdQb3NpdGlvbjtcXG4gICAgICB9XFxuICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xcbiAgICAgICAgc3dpcGVyLm9uY2UoJ3RyYW5zaXRpb25FbmQnLCAoKSA9PiB7XFxuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgLy8gRml4IGR1cmF0aW9uXFxuICAgICAgaWYgKHN3aXBlci52ZWxvY2l0eSAhPT0gMCkge1xcbiAgICAgICAgaWYgKHJ0bCkge1xcbiAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5hYnMoKC1uZXdQb3NpdGlvbiAtIHN3aXBlci50cmFuc2xhdGUpIC8gc3dpcGVyLnZlbG9jaXR5KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBNYXRoLmFicygobmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICAgIC8vIElmIGZyZWVNb2RlU3RpY2t5IGlzIGFjdGl2ZSBhbmQgdGhlIHVzZXIgZW5kcyBhIHN3aXBlIHdpdGggYSBzbG93LXZlbG9jaXR5XFxuICAgICAgICAgIC8vIGV2ZW50LCB0aGVuIGR1cmF0aW9ucyBjYW4gYmUgMjArIHNlY29uZHMgdG8gc2xpZGUgb25lIChvciB6ZXJvISkgc2xpZGVzLlxcbiAgICAgICAgICAvLyBJdCdzIGVhc3kgdG8gc2VlIHRoaXMgd2hlbiBzaW11bGF0aW5nIHRvdWNoIHdpdGggbW91c2UgZXZlbnRzLiBUbyBmaXggdGhpcyxcXG4gICAgICAgICAgLy8gbGltaXQgc2luZ2xlLXNsaWRlIHN3aXBlcyB0byB0aGUgZGVmYXVsdCBzbGlkZSBkdXJhdGlvbi4gVGhpcyBhbHNvIGhhcyB0aGVcXG4gICAgICAgICAgLy8gbmljZSBzaWRlIGVmZmVjdCBvZiBtYXRjaGluZyBzbGlkZSBzcGVlZCBpZiB0aGUgdXNlciBzdG9wcGVkIG1vdmluZyBiZWZvcmVcXG4gICAgICAgICAgLy8gbGlmdGluZyBmaW5nZXIgb3IgbW91c2UgdnMuIG1vdmluZyBzbG93bHkgYmVmb3JlIGxpZnRpbmcgdGhlIGZpbmdlci9tb3VzZS5cXG4gICAgICAgICAgLy8gRm9yIGZhc3RlciBzd2lwZXMsIGFsc28gYXBwbHkgbGltaXRzIChhbGJlaXQgaGlnaGVyIG9uZXMpLlxcbiAgICAgICAgICBjb25zdCBtb3ZlRGlzdGFuY2UgPSBNYXRoLmFicygocnRsID8gLW5ld1Bvc2l0aW9uIDogbmV3UG9zaXRpb24pIC0gc3dpcGVyLnRyYW5zbGF0ZSk7XFxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleF07XFxuICAgICAgICAgIGlmIChtb3ZlRGlzdGFuY2UgPCBjdXJyZW50U2xpZGVTaXplKSB7XFxuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChtb3ZlRGlzdGFuY2UgPCAyICogY3VycmVudFNsaWRlU2l6ZSkge1xcbiAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQgKiAxLjU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZCAqIDIuNTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIGRvQm91bmNlKSB7XFxuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XFxuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcXG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xcbiAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XFxuICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ21vbWVudHVtQm91bmNlJyk7XFxuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHBhcmFtcy5zcGVlZCk7XFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XFxuICAgICAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcXG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0sIDApO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmIChzd2lwZXIudmVsb2NpdHkpIHtcXG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XFxuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcXG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xcbiAgICAgICAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nKSB7XFxuICAgICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1Bvc2l0aW9uKTtcXG4gICAgICB9XFxuXFxuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGVTdGlja3kpIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKCFwYXJhbXMuZnJlZU1vZGVNb21lbnR1bSB8fCB0aW1lRGlmZiA+PSBwYXJhbXMubG9uZ1N3aXBlc01zKSB7XFxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XFxuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcXG4gIGxldCBzdG9wSW5kZXggPSAwO1xcbiAgbGV0IGdyb3VwU2l6ZSA9IHN3aXBlci5zbGlkZXNTaXplc0dyaWRbMF07XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IChpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApKSB7XFxuICAgIGNvbnN0IGluY3JlbWVudCA9IChpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcXG4gICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0gJiYgY3VycmVudFBvcyA8IHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0pIHtcXG4gICAgICAgIHN0b3BJbmRleCA9IGk7XFxuICAgICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdIC0gc2xpZGVzR3JpZFtpXTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldKSB7XFxuICAgICAgc3RvcEluZGV4ID0gaTtcXG4gICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMV0gLSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMl07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEZpbmQgY3VycmVudCBzbGlkZSBzaXplXFxuICBjb25zdCByYXRpbyA9IChjdXJyZW50UG9zIC0gc2xpZGVzR3JpZFtzdG9wSW5kZXhdKSAvIGdyb3VwU2l6ZTtcXG4gIGNvbnN0IGluY3JlbWVudCA9IChzdG9wSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xcblxcbiAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xcbiAgICAvLyBMb25nIHRvdWNoZXNcXG4gICAgaWYgKCFwYXJhbXMubG9uZ1N3aXBlcykge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xcbiAgICAgIGlmIChyYXRpbyA+PSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xcbiAgICAgIGVsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicpIHtcXG4gICAgICBpZiAocmF0aW8gPiAoMSAtIHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pKSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xcbiAgICAgIGVsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gU2hvcnQgc3dpcGVzXFxuICAgIGlmICghcGFyYW1zLnNob3J0U3dpcGVzKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgY29uc3QgaXNOYXZCdXR0b25UYXJnZXQgPSBzd2lwZXIubmF2aWdhdGlvbiAmJiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsKTtcXG4gICAgaWYgKCFpc05hdkJ1dHRvblRhcmdldCkge1xcbiAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG9uUmVzaXplICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuXFxuICBjb25zdCB7IHBhcmFtcywgZWwgfSA9IHN3aXBlcjtcXG5cXG4gIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuO1xcblxcbiAgLy8gQnJlYWtwb2ludHNcXG4gIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcXG4gICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcXG4gIH1cXG5cXG4gIC8vIFNhdmUgbG9ja3NcXG4gIGNvbnN0IHsgYWxsb3dTbGlkZU5leHQsIGFsbG93U2xpZGVQcmV2LCBzbmFwR3JpZCB9ID0gc3dpcGVyO1xcblxcbiAgLy8gRGlzYWJsZSBsb2NrcyBvbiByZXNpemVcXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XFxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xcblxcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcXG4gIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG5cXG4gIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICBpZiAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xcbiAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDEsIDAsIGZhbHNlLCB0cnVlKTtcXG4gIH0gZWxzZSB7XFxuICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xcbiAgfVxcblxcbiAgaWYgKHN3aXBlci5hdXRvcGxheSAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZyAmJiBzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSB7XFxuICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gIH1cXG4gIC8vIFJldHVybiBsb2NrcyBhZnRlciByZXNpemVcXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gYWxsb3dTbGlkZU5leHQ7XFxuXFxuICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcXG4gICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25DbGljayAoZSkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGlmICghc3dpcGVyLmFsbG93Q2xpY2spIHtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgc3dpcGVyLmFuaW1hdGluZykge1xcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvblNjcm9sbCAoKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgeyB3cmFwcGVyRWwsIHJ0bFRyYW5zbGF0ZSB9ID0gc3dpcGVyO1xcbiAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcXG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgaWYgKHJ0bFRyYW5zbGF0ZSkge1xcbiAgICAgIHN3aXBlci50cmFuc2xhdGUgPSAoKHdyYXBwZXJFbC5zY3JvbGxXaWR0aCAtIHdyYXBwZXJFbC5vZmZzZXRXaWR0aCkgLSB3cmFwcGVyRWwuc2Nyb2xsTGVmdCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsTGVmdDtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsVG9wO1xcbiAgfVxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICBpZiAoc3dpcGVyLnRyYW5zbGF0ZSA9PT0gLTApIHN3aXBlci50cmFuc2xhdGUgPSAwO1xcblxcbiAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcblxcbiAgbGV0IG5ld1Byb2dyZXNzO1xcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcXG4gICAgbmV3UHJvZ3Jlc3MgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgbmV3UHJvZ3Jlc3MgPSAoc3dpcGVyLnRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyAodHJhbnNsYXRlc0RpZmYpO1xcbiAgfVxcbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBzd2lwZXIucHJvZ3Jlc3MpIHtcXG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHJ0bFRyYW5zbGF0ZSA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSk7XFxuICB9XFxuXFxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xcbn1cXG5cXG5sZXQgZHVtbXlFdmVudEF0dGFjaGVkID0gZmFsc2U7XFxuZnVuY3Rpb24gZHVtbXlFdmVudExpc3RlbmVyKCkge31cXG5cXG5mdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3Qge1xcbiAgICBwYXJhbXMsIHRvdWNoRXZlbnRzLCBlbCwgd3JhcHBlckVsLFxcbiAgfSA9IHN3aXBlcjtcXG5cXG4gIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xcbiAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gb25Ub3VjaE1vdmUuYmluZChzd2lwZXIpO1xcbiAgc3dpcGVyLm9uVG91Y2hFbmQgPSBvblRvdWNoRW5kLmJpbmQoc3dpcGVyKTtcXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xcbiAgICBzd2lwZXIub25TY3JvbGwgPSBvblNjcm9sbC5iaW5kKHN3aXBlcik7XFxuICB9XFxuXFxuICBzd2lwZXIub25DbGljayA9IG9uQ2xpY2suYmluZChzd2lwZXIpO1xcblxcbiAgY29uc3QgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDtcXG5cXG4gIC8vIFRvdWNoIEV2ZW50c1xcbiAgaWYgKCFTdXBwb3J0LnRvdWNoICYmIFN1cHBvcnQucG9pbnRlckV2ZW50cykge1xcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XFxuICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XFxuICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChTdXBwb3J0LnRvdWNoKSB7XFxuICAgICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gdG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0JyAmJiBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuc3RhcnQsIHN3aXBlci5vblRvdWNoU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyID8geyBwYXNzaXZlOiBmYWxzZSwgY2FwdHVyZSB9IDogY2FwdHVyZSk7XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIGlmICh0b3VjaEV2ZW50cy5jYW5jZWwpIHtcXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuY2FuY2VsLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFkdW1teUV2ZW50QXR0YWNoZWQpIHtcXG4gICAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZHVtbXlFdmVudExpc3RlbmVyKTtcXG4gICAgICAgIGR1bW15RXZlbnRBdHRhY2hlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIURldmljZS5pb3MgJiYgIURldmljZS5hbmRyb2lkKSB8fCAocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIVN1cHBvcnQudG91Y2ggJiYgRGV2aWNlLmlvcykpIHtcXG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzd2lwZXIub25Ub3VjaEVuZCwgZmFsc2UpO1xcbiAgICB9XFxuICB9XFxuICAvLyBQcmV2ZW50IExpbmtzIENsaWNrc1xcbiAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzd2lwZXIub25DbGljaywgdHJ1ZSk7XFxuICB9XFxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcXG4gICAgd3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN3aXBlci5vblNjcm9sbCk7XFxuICB9XFxuXFxuICAvLyBSZXNpemUgaGFuZGxlclxcbiAgaWYgKHBhcmFtcy51cGRhdGVPbldpbmRvd1Jlc2l6ZSkge1xcbiAgICBzd2lwZXIub24oKERldmljZS5pb3MgfHwgRGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnKSwgb25SZXNpemUsIHRydWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3dpcGVyLm9uKCdvYnNlcnZlclVwZGF0ZScsIG9uUmVzaXplLCB0cnVlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG5cXG4gIGNvbnN0IHtcXG4gICAgcGFyYW1zLCB0b3VjaEV2ZW50cywgZWwsIHdyYXBwZXJFbCxcXG4gIH0gPSBzd2lwZXI7XFxuXFxuICBjb25zdCBjYXB0dXJlID0gISFwYXJhbXMubmVzdGVkO1xcblxcbiAgLy8gVG91Y2ggRXZlbnRzXFxuICBpZiAoIVN1cHBvcnQudG91Y2ggJiYgU3VwcG9ydC5wb2ludGVyRXZlbnRzKSB7XFxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuc3RhcnQsIHN3aXBlci5vblRvdWNoU3RhcnQsIGZhbHNlKTtcXG4gICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcXG4gICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuZW5kLCBzd2lwZXIub25Ub3VjaEVuZCwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKFN1cHBvcnQudG91Y2gpIHtcXG4gICAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSB0b3VjaEV2ZW50cy5zdGFydCA9PT0gJ29uVG91Y2hTdGFydCcgJiYgU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcXG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcXG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgICAgaWYgKHRvdWNoRXZlbnRzLmNhbmNlbCkge1xcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5jYW5jZWwsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoKHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFEZXZpY2UuaW9zICYmICFEZXZpY2UuYW5kcm9pZCkgfHwgKHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFTdXBwb3J0LnRvdWNoICYmIERldmljZS5pb3MpKSB7XFxuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcXG4gIGlmIChwYXJhbXMucHJldmVudENsaWNrcyB8fCBwYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSB7XFxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XFxuICAgIHdyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzd2lwZXIub25TY3JvbGwpO1xcbiAgfVxcblxcbiAgLy8gUmVzaXplIGhhbmRsZXJcXG4gIHN3aXBlci5vZmYoKERldmljZS5pb3MgfHwgRGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnKSwgb25SZXNpemUpO1xcbn1cXG5cXG52YXIgZXZlbnRzID0ge1xcbiAgYXR0YWNoRXZlbnRzLFxcbiAgZGV0YWNoRXZlbnRzLFxcbn07XFxuXFxuZnVuY3Rpb24gc2V0QnJlYWtwb2ludCAoKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3Qge1xcbiAgICBhY3RpdmVJbmRleCwgaW5pdGlhbGl6ZWQsIGxvb3BlZFNsaWRlcyA9IDAsIHBhcmFtcywgJGVsLFxcbiAgfSA9IHN3aXBlcjtcXG4gIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xcbiAgaWYgKCFicmVha3BvaW50cyB8fCAoYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLmxlbmd0aCA9PT0gMCkpIHJldHVybjtcXG5cXG4gIC8vIEdldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXFxuICBjb25zdCBicmVha3BvaW50ID0gc3dpcGVyLmdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMpO1xcblxcbiAgaWYgKGJyZWFrcG9pbnQgJiYgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ICE9PSBicmVha3BvaW50KSB7XFxuICAgIGNvbnN0IGJyZWFrcG9pbnRPbmx5UGFyYW1zID0gYnJlYWtwb2ludCBpbiBicmVha3BvaW50cyA/IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdIDogdW5kZWZpbmVkO1xcbiAgICBpZiAoYnJlYWtwb2ludE9ubHlQYXJhbXMpIHtcXG4gICAgICBbJ3NsaWRlc1BlclZpZXcnLCAnc3BhY2VCZXR3ZWVuJywgJ3NsaWRlc1Blckdyb3VwJywgJ3NsaWRlc1Blckdyb3VwU2tpcCcsICdzbGlkZXNQZXJDb2x1bW4nXS5mb3JFYWNoKChwYXJhbSkgPT4ge1xcbiAgICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IGJyZWFrcG9pbnRPbmx5UGFyYW1zW3BhcmFtXTtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1WYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcXG4gICAgICAgIGlmIChwYXJhbSA9PT0gJ3NsaWRlc1BlclZpZXcnICYmIChwYXJhbVZhbHVlID09PSAnQVVUTycgfHwgcGFyYW1WYWx1ZSA9PT0gJ2F1dG8nKSkge1xcbiAgICAgICAgICBicmVha3BvaW50T25seVBhcmFtc1twYXJhbV0gPSAnYXV0byc7XFxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09PSAnc2xpZGVzUGVyVmlldycpIHtcXG4gICAgICAgICAgYnJlYWtwb2ludE9ubHlQYXJhbXNbcGFyYW1dID0gcGFyc2VGbG9hdChwYXJhbVZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGJyZWFrcG9pbnRPbmx5UGFyYW1zW3BhcmFtXSA9IHBhcnNlSW50KHBhcmFtVmFsdWUsIDEwKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBicmVha3BvaW50UGFyYW1zID0gYnJlYWtwb2ludE9ubHlQYXJhbXMgfHwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xcbiAgICBjb25zdCB3YXNNdWx0aVJvdyA9IHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxO1xcbiAgICBjb25zdCBpc011bHRpUm93ID0gYnJlYWtwb2ludFBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxO1xcbiAgICBpZiAod2FzTXVsdGlSb3cgJiYgIWlzTXVsdGlSb3cpIHtcXG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9bXVsdGlyb3cgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31tdWx0aXJvdy1jb2x1bW5gKTtcXG4gICAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xcbiAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31tdWx0aXJvd2ApO1xcbiAgICAgIGlmIChicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nKSB7XFxuICAgICAgICAkZWwuYWRkQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9bXVsdGlyb3ctY29sdW1uYCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvbnN0IGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcXG4gICAgY29uc3QgbmVlZHNSZUxvb3AgPSBwYXJhbXMubG9vcCAmJiAoYnJlYWtwb2ludFBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSBwYXJhbXMuc2xpZGVzUGVyVmlldyB8fCBkaXJlY3Rpb25DaGFuZ2VkKTtcXG5cXG4gICAgaWYgKGRpcmVjdGlvbkNoYW5nZWQgJiYgaW5pdGlhbGl6ZWQpIHtcXG4gICAgICBzd2lwZXIuY2hhbmdlRGlyZWN0aW9uKCk7XFxuICAgIH1cXG5cXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIGJyZWFrcG9pbnRQYXJhbXMpO1xcblxcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgYWxsb3dUb3VjaE1vdmU6IHN3aXBlci5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXFxuICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXFxuICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXFxuICAgIH0pO1xcblxcbiAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xcblxcbiAgICBpZiAobmVlZHNSZUxvb3AgJiYgaW5pdGlhbGl6ZWQpIHtcXG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcXG4gICAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG4gICAgICBzd2lwZXIuc2xpZGVUbygoYWN0aXZlSW5kZXggLSBsb29wZWRTbGlkZXMpICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xcbiAgICB9XFxuXFxuICAgIHN3aXBlci5lbWl0KCdicmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGdldEJyZWFrcG9pbnQgKGJyZWFrcG9pbnRzKSB7XFxuICAvLyBHZXQgYnJlYWtwb2ludCBmb3Igd2luZG93IHdpZHRoXFxuICBpZiAoIWJyZWFrcG9pbnRzKSByZXR1cm4gdW5kZWZpbmVkO1xcbiAgbGV0IGJyZWFrcG9pbnQgPSBmYWxzZTtcXG5cXG4gIGNvbnN0IHBvaW50cyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5tYXAoKHBvaW50KSA9PiB7XFxuICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdzdHJpbmcnICYmIHBvaW50LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xcbiAgICAgIGNvbnN0IG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xcbiAgICAgIGNvbnN0IHZhbHVlID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5pbm5lckhlaWdodCAqIG1pblJhdGlvO1xcbiAgICAgIHJldHVybiB7IHZhbHVlLCBwb2ludCB9O1xcbiAgICB9XFxuICAgIHJldHVybiB7IHZhbHVlOiBwb2ludCwgcG9pbnQgfTtcXG4gIH0pO1xcblxcbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEudmFsdWUsIDEwKSAtIHBhcnNlSW50KGIudmFsdWUsIDEwKSk7XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICBjb25zdCB7IHBvaW50LCB2YWx1ZSB9ID0gcG9pbnRzW2ldO1xcbiAgICBpZiAodmFsdWUgPD0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5pbm5lcldpZHRoKSB7XFxuICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gYnJlYWtwb2ludCB8fCAnbWF4JztcXG59XFxuXFxudmFyIGJyZWFrcG9pbnRzID0geyBzZXRCcmVha3BvaW50LCBnZXRCcmVha3BvaW50IH07XFxuXFxuZnVuY3Rpb24gYWRkQ2xhc3NlcyAoKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3Qge1xcbiAgICBjbGFzc05hbWVzLCBwYXJhbXMsIHJ0bCwgJGVsLFxcbiAgfSA9IHN3aXBlcjtcXG4gIGNvbnN0IHN1ZmZpeGVzID0gW107XFxuXFxuICBzdWZmaXhlcy5wdXNoKCdpbml0aWFsaXplZCcpO1xcbiAgc3VmZml4ZXMucHVzaChwYXJhbXMuZGlyZWN0aW9uKTtcXG5cXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcXG4gICAgc3VmZml4ZXMucHVzaCgnZnJlZS1tb2RlJyk7XFxuICB9XFxuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgc3VmZml4ZXMucHVzaCgnYXV0b2hlaWdodCcpO1xcbiAgfVxcbiAgaWYgKHJ0bCkge1xcbiAgICBzdWZmaXhlcy5wdXNoKCdydGwnKTtcXG4gIH1cXG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xcbiAgICBzdWZmaXhlcy5wdXNoKCdtdWx0aXJvdycpO1xcbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdjb2x1bW4nKSB7XFxuICAgICAgc3VmZml4ZXMucHVzaCgnbXVsdGlyb3ctY29sdW1uJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChEZXZpY2UuYW5kcm9pZCkge1xcbiAgICBzdWZmaXhlcy5wdXNoKCdhbmRyb2lkJyk7XFxuICB9XFxuICBpZiAoRGV2aWNlLmlvcykge1xcbiAgICBzdWZmaXhlcy5wdXNoKCdpb3MnKTtcXG4gIH1cXG5cXG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xcbiAgICBzdWZmaXhlcy5wdXNoKCdjc3MtbW9kZScpO1xcbiAgfVxcblxcbiAgc3VmZml4ZXMuZm9yRWFjaCgoc3VmZml4KSA9PiB7XFxuICAgIGNsYXNzTmFtZXMucHVzaChwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIHN1ZmZpeCk7XFxuICB9KTtcXG5cXG4gICRlbC5hZGRDbGFzcyhjbGFzc05hbWVzLmpvaW4oJyAnKSk7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMgKCkge1xcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gIGNvbnN0IHsgJGVsLCBjbGFzc05hbWVzIH0gPSBzd2lwZXI7XFxuXFxuICAkZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xcbn1cXG5cXG52YXIgY2xhc3NlcyA9IHsgYWRkQ2xhc3NlcywgcmVtb3ZlQ2xhc3NlcyB9O1xcblxcbmZ1bmN0aW9uIGxvYWRJbWFnZSAoaW1hZ2VFbCwgc3JjLCBzcmNzZXQsIHNpemVzLCBjaGVja0ZvckNvbXBsZXRlLCBjYWxsYmFjaykge1xcbiAgbGV0IGltYWdlO1xcbiAgZnVuY3Rpb24gb25SZWFkeSgpIHtcXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xcbiAgfVxcbiAgY29uc3QgaXNQaWN0dXJlID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShpbWFnZUVsKS5wYXJlbnQoJ3BpY3R1cmUnKVswXTtcXG5cXG4gIGlmICghaXNQaWN0dXJlICYmICghaW1hZ2VFbC5jb21wbGV0ZSB8fCAhY2hlY2tGb3JDb21wbGV0ZSkpIHtcXG4gICAgaWYgKHNyYykge1xcbiAgICAgIGltYWdlID0gbmV3IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uSW1hZ2UoKTtcXG4gICAgICBpbWFnZS5vbmxvYWQgPSBvblJlYWR5O1xcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBvblJlYWR5O1xcbiAgICAgIGlmIChzaXplcykge1xcbiAgICAgICAgaW1hZ2Uuc2l6ZXMgPSBzaXplcztcXG4gICAgICB9XFxuICAgICAgaWYgKHNyY3NldCkge1xcbiAgICAgICAgaW1hZ2Uuc3Jjc2V0ID0gc3Jjc2V0O1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3JjKSB7XFxuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIG9uUmVhZHkoKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gaW1hZ2UgYWxyZWFkeSBsb2FkZWQuLi5cXG4gICAgb25SZWFkeSgpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcmVsb2FkSW1hZ2VzICgpIHtcXG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICBzd2lwZXIuaW1hZ2VzVG9Mb2FkID0gc3dpcGVyLiRlbC5maW5kKCdpbWcnKTtcXG4gIGZ1bmN0aW9uIG9uUmVhZHkoKSB7XFxuICAgIGlmICh0eXBlb2Ygc3dpcGVyID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIgPT09IG51bGwgfHwgIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XFxuICAgIGlmIChzd2lwZXIuaW1hZ2VzTG9hZGVkICE9PSB1bmRlZmluZWQpIHN3aXBlci5pbWFnZXNMb2FkZWQgKz0gMTtcXG4gICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgPT09IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoKSB7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudXBkYXRlT25JbWFnZXNSZWFkeSkgc3dpcGVyLnVwZGF0ZSgpO1xcbiAgICAgIHN3aXBlci5lbWl0KCdpbWFnZXNSZWFkeScpO1xcbiAgICB9XFxuICB9XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci5pbWFnZXNUb0xvYWRbaV07XFxuICAgIHN3aXBlci5sb2FkSW1hZ2UoXFxuICAgICAgaW1hZ2VFbCxcXG4gICAgICBpbWFnZUVsLmN1cnJlbnRTcmMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpLFxcbiAgICAgIGltYWdlRWwuc3Jjc2V0IHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzcmNzZXQnKSxcXG4gICAgICBpbWFnZUVsLnNpemVzIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzaXplcycpLFxcbiAgICAgIHRydWUsXFxuICAgICAgb25SZWFkeVxcbiAgICApO1xcbiAgfVxcbn1cXG5cXG52YXIgaW1hZ2VzID0ge1xcbiAgbG9hZEltYWdlLFxcbiAgcHJlbG9hZEltYWdlcyxcXG59O1xcblxcbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XFxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcXG4gIGNvbnN0IHdhc0xvY2tlZCA9IHN3aXBlci5pc0xvY2tlZDtcXG4gIGNvbnN0IGxhc3RTbGlkZVBvc2l0aW9uID0gc3dpcGVyLnNsaWRlcy5sZW5ndGggPiAwICYmIChwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlICsgKHBhcmFtcy5zcGFjZUJldHdlZW4gKiAoc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKSkgKyAoKHN3aXBlci5zbGlkZXNbMF0pLm9mZnNldFdpZHRoKSAqIHN3aXBlci5zbGlkZXMubGVuZ3RoKTtcXG5cXG4gIGlmIChwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlICYmIHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlciAmJiBsYXN0U2xpZGVQb3NpdGlvbikge1xcbiAgICBzd2lwZXIuaXNMb2NrZWQgPSBsYXN0U2xpZGVQb3NpdGlvbiA8PSBzd2lwZXIuc2l6ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggPT09IDE7XFxuICB9XFxuXFxuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSAhc3dpcGVyLmlzTG9ja2VkO1xcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDtcXG5cXG4gIC8vIGV2ZW50c1xcbiAgaWYgKHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSBzd2lwZXIuZW1pdChzd2lwZXIuaXNMb2NrZWQgPyAnbG9jaycgOiAndW5sb2NrJyk7XFxuXFxuICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XFxuICAgIHN3aXBlci5pc0VuZCA9IGZhbHNlO1xcbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24pIHN3aXBlci5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xcbiAgfVxcbn1cXG5cXG52YXIgY2hlY2tPdmVyZmxvdyQxID0geyBjaGVja092ZXJmbG93IH07XFxuXFxudmFyIGRlZmF1bHRzID0ge1xcbiAgaW5pdDogdHJ1ZSxcXG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxcbiAgdG91Y2hFdmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxcbiAgaW5pdGlhbFNsaWRlOiAwLFxcbiAgc3BlZWQ6IDMwMCxcXG4gIGNzc01vZGU6IGZhbHNlLFxcbiAgdXBkYXRlT25XaW5kb3dSZXNpemU6IHRydWUsXFxuICAvL1xcbiAgcHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiBmYWxzZSxcXG5cXG4gIC8vIFRvIHN1cHBvcnQgaU9TJ3Mgc3dpcGUtdG8tZ28tYmFjayBnZXN0dXJlICh3aGVuIGJlaW5nIHVzZWQgaW4tYXBwKS5cXG4gIGVkZ2VTd2lwZURldGVjdGlvbjogZmFsc2UsXFxuICBlZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLFxcblxcbiAgLy8gRnJlZSBtb2RlXFxuICBmcmVlTW9kZTogZmFsc2UsXFxuICBmcmVlTW9kZU1vbWVudHVtOiB0cnVlLFxcbiAgZnJlZU1vZGVNb21lbnR1bVJhdGlvOiAxLFxcbiAgZnJlZU1vZGVNb21lbnR1bUJvdW5jZTogdHJ1ZSxcXG4gIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcXG4gIGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOiAxLFxcbiAgZnJlZU1vZGVTdGlja3k6IGZhbHNlLFxcbiAgZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHk6IDAuMDIsXFxuXFxuICAvLyBBdXRvaGVpZ2h0XFxuICBhdXRvSGVpZ2h0OiBmYWxzZSxcXG5cXG4gIC8vIFNldCB3cmFwcGVyIHdpZHRoXFxuICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXFxuXFxuICAvLyBWaXJ0dWFsIFRyYW5zbGF0ZVxcbiAgdmlydHVhbFRyYW5zbGF0ZTogZmFsc2UsXFxuXFxuICAvLyBFZmZlY3RzXFxuICBlZmZlY3Q6ICdzbGlkZScsIC8vICdzbGlkZScgb3IgJ2ZhZGUnIG9yICdjdWJlJyBvciAnY292ZXJmbG93JyBvciAnZmxpcCdcXG5cXG4gIC8vIEJyZWFrcG9pbnRzXFxuICBicmVha3BvaW50czogdW5kZWZpbmVkLFxcblxcbiAgLy8gU2xpZGVzIGdyaWRcXG4gIHNwYWNlQmV0d2VlbjogMCxcXG4gIHNsaWRlc1BlclZpZXc6IDEsXFxuICBzbGlkZXNQZXJDb2x1bW46IDEsXFxuICBzbGlkZXNQZXJDb2x1bW5GaWxsOiAnY29sdW1uJyxcXG4gIHNsaWRlc1Blckdyb3VwOiAxLFxcbiAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxcbiAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxcbiAgY2VudGVyZWRTbGlkZXNCb3VuZHM6IGZhbHNlLFxcbiAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLCAvLyBpbiBweFxcbiAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsIC8vIGluIHB4XFxuICBub3JtYWxpemVTbGlkZUluZGV4OiB0cnVlLFxcbiAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiBmYWxzZSxcXG5cXG4gIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XFxuICB3YXRjaE92ZXJmbG93OiBmYWxzZSxcXG5cXG4gIC8vIFJvdW5kIGxlbmd0aFxcbiAgcm91bmRMZW5ndGhzOiBmYWxzZSxcXG5cXG4gIC8vIFRvdWNoZXNcXG4gIHRvdWNoUmF0aW86IDEsXFxuICB0b3VjaEFuZ2xlOiA0NSxcXG4gIHNpbXVsYXRlVG91Y2g6IHRydWUsXFxuICBzaG9ydFN3aXBlczogdHJ1ZSxcXG4gIGxvbmdTd2lwZXM6IHRydWUsXFxuICBsb25nU3dpcGVzUmF0aW86IDAuNSxcXG4gIGxvbmdTd2lwZXNNczogMzAwLFxcbiAgZm9sbG93RmluZ2VyOiB0cnVlLFxcbiAgYWxsb3dUb3VjaE1vdmU6IHRydWUsXFxuICB0aHJlc2hvbGQ6IDAsXFxuICB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246IGZhbHNlLFxcbiAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiB0cnVlLFxcbiAgdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6IGZhbHNlLFxcbiAgdG91Y2hSZWxlYXNlT25FZGdlczogZmFsc2UsXFxuXFxuICAvLyBVbmlxdWUgTmF2aWdhdGlvbiBFbGVtZW50c1xcbiAgdW5pcXVlTmF2RWxlbWVudHM6IHRydWUsXFxuXFxuICAvLyBSZXNpc3RhbmNlXFxuICByZXNpc3RhbmNlOiB0cnVlLFxcbiAgcmVzaXN0YW5jZVJhdGlvOiAwLjg1LFxcblxcbiAgLy8gUHJvZ3Jlc3NcXG4gIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IGZhbHNlLFxcbiAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiBmYWxzZSxcXG5cXG4gIC8vIEN1cnNvclxcbiAgZ3JhYkN1cnNvcjogZmFsc2UsXFxuXFxuICAvLyBDbGlja3NcXG4gIHByZXZlbnRDbGlja3M6IHRydWUsXFxuICBwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246IHRydWUsXFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcXG5cXG4gIC8vIEltYWdlc1xcbiAgcHJlbG9hZEltYWdlczogdHJ1ZSxcXG4gIHVwZGF0ZU9uSW1hZ2VzUmVhZHk6IHRydWUsXFxuXFxuICAvLyBsb29wXFxuICBsb29wOiBmYWxzZSxcXG4gIGxvb3BBZGRpdGlvbmFsU2xpZGVzOiAwLFxcbiAgbG9vcGVkU2xpZGVzOiBudWxsLFxcbiAgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogZmFsc2UsXFxuXFxuICAvLyBTd2lwaW5nL25vIHN3aXBpbmdcXG4gIGFsbG93U2xpZGVQcmV2OiB0cnVlLFxcbiAgYWxsb3dTbGlkZU5leHQ6IHRydWUsXFxuICBzd2lwZUhhbmRsZXI6IG51bGwsIC8vICcuc3dpcGUtaGFuZGxlcicsXFxuICBub1N3aXBpbmc6IHRydWUsXFxuICBub1N3aXBpbmdDbGFzczogJ3N3aXBlci1uby1zd2lwaW5nJyxcXG4gIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxcblxcbiAgLy8gUGFzc2l2ZSBMaXN0ZW5lcnNcXG4gIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXFxuXFxuICAvLyBOU1xcbiAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci1jb250YWluZXItJywgLy8gTkVXXFxuICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcXG4gIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmsnLFxcbiAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxcbiAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlJyxcXG4gIHNsaWRlVmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXZpc2libGUnLFxcbiAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUnLFxcbiAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXFxuICBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dCcsXFxuICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcXG4gIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2JyxcXG4gIHdyYXBwZXJDbGFzczogJ3N3aXBlci13cmFwcGVyJyxcXG5cXG4gIC8vIENhbGxiYWNrc1xcbiAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxcbn07XFxuXFxuLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiBcXFwib2ZmXFxcIiAqL1xcblxcbmNvbnN0IHByb3RvdHlwZXMgPSB7XFxuICB1cGRhdGUsXFxuICB0cmFuc2xhdGUsXFxuICB0cmFuc2l0aW9uLFxcbiAgc2xpZGUsXFxuICBsb29wLFxcbiAgZ3JhYkN1cnNvcixcXG4gIG1hbmlwdWxhdGlvbixcXG4gIGV2ZW50cyxcXG4gIGJyZWFrcG9pbnRzLFxcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvdyQxLFxcbiAgY2xhc3NlcyxcXG4gIGltYWdlcyxcXG59O1xcblxcbmNvbnN0IGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcXG5cXG5jbGFzcyBTd2lwZXIgZXh0ZW5kcyBTd2lwZXJDbGFzcyB7XFxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XFxuICAgIGxldCBlbDtcXG4gICAgbGV0IHBhcmFtcztcXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XFxuICAgICAgcGFyYW1zID0gYXJnc1swXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBbZWwsIHBhcmFtc10gPSBhcmdzO1xcbiAgICB9XFxuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcXG5cXG4gICAgcGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBwYXJhbXMpO1xcbiAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XFxuXFxuICAgIHN1cGVyKHBhcmFtcyk7XFxuXFxuICAgIE9iamVjdC5rZXlzKHByb3RvdHlwZXMpLmZvckVhY2goKHByb3RvdHlwZUdyb3VwKSA9PiB7XFxuICAgICAgT2JqZWN0LmtleXMocHJvdG90eXBlc1twcm90b3R5cGVHcm91cF0pLmZvckVhY2goKHByb3RvTWV0aG9kKSA9PiB7XFxuICAgICAgICBpZiAoIVN3aXBlci5wcm90b3R5cGVbcHJvdG9NZXRob2RdKSB7XFxuICAgICAgICAgIFN3aXBlci5wcm90b3R5cGVbcHJvdG9NZXRob2RdID0gcHJvdG90eXBlc1twcm90b3R5cGVHcm91cF1bcHJvdG9NZXRob2RdO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gU3dpcGVyIEluc3RhbmNlXFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICh0eXBlb2Ygc3dpcGVyLm1vZHVsZXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgc3dpcGVyLm1vZHVsZXMgPSB7fTtcXG4gICAgfVxcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIubW9kdWxlcykuZm9yRWFjaCgobW9kdWxlTmFtZSkgPT4ge1xcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHN3aXBlci5tb2R1bGVzW21vZHVsZU5hbWVdO1xcbiAgICAgIGlmIChtb2R1bGUucGFyYW1zKSB7XFxuICAgICAgICBjb25zdCBtb2R1bGVQYXJhbU5hbWUgPSBPYmplY3Qua2V5cyhtb2R1bGUucGFyYW1zKVswXTtcXG4gICAgICAgIGNvbnN0IG1vZHVsZVBhcmFtcyA9IG1vZHVsZS5wYXJhbXNbbW9kdWxlUGFyYW1OYW1lXTtcXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlUGFyYW1zICE9PSAnb2JqZWN0JyB8fCBtb2R1bGVQYXJhbXMgPT09IG51bGwpIHJldHVybjtcXG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHJldHVybjtcXG4gICAgICAgIGlmIChwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHsgZW5hYmxlZDogdHJ1ZSB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICB0eXBlb2YgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPT09ICdvYmplY3QnXFxuICAgICAgICAgICYmICEoJ2VuYWJsZWQnIGluIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKVxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVuYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7IGVuYWJsZWQ6IGZhbHNlIH07XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcXG4gICAgY29uc3Qgc3dpcGVyUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBkZWZhdWx0cyk7XFxuICAgIHN3aXBlci51c2VNb2R1bGVzUGFyYW1zKHN3aXBlclBhcmFtcyk7XFxuXFxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBwYXJhbXNcXG4gICAgc3dpcGVyLnBhcmFtcyA9IFV0aWxzLmV4dGVuZCh7fSwgc3dpcGVyUGFyYW1zLCBleHRlbmRlZERlZmF1bHRzLCBwYXJhbXMpO1xcbiAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMgPSBVdGlscy5leHRlbmQoe30sIHN3aXBlci5wYXJhbXMpO1xcbiAgICBzd2lwZXIucGFzc2VkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBwYXJhbXMpO1xcblxcbiAgICAvLyBTYXZlIERvbSBsaWJcXG4gICAgc3dpcGVyLiQgPSBkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXTtcXG5cXG4gICAgLy8gRmluZCBlbFxcbiAgICBjb25zdCAkZWwgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHN3aXBlci5wYXJhbXMuZWwpO1xcbiAgICBlbCA9ICRlbFswXTtcXG5cXG4gICAgaWYgKCFlbCkge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKCRlbC5sZW5ndGggPiAxKSB7XFxuICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xcbiAgICAgICRlbC5lYWNoKChpbmRleCwgY29udGFpbmVyRWwpID0+IHtcXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IFV0aWxzLmV4dGVuZCh7fSwgcGFyYW1zLCB7IGVsOiBjb250YWluZXJFbCB9KTtcXG4gICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBzd2lwZXJzO1xcbiAgICB9XFxuXFxuICAgIGVsLnN3aXBlciA9IHN3aXBlcjtcXG4gICAgJGVsLmRhdGEoJ3N3aXBlcicsIHN3aXBlcik7XFxuXFxuICAgIC8vIEZpbmQgV3JhcHBlclxcbiAgICBsZXQgJHdyYXBwZXJFbDtcXG4gICAgaWYgKGVsICYmIGVsLnNoYWRvd1Jvb3QgJiYgZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKSB7XFxuICAgICAgJHdyYXBwZXJFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGAuJHtzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzc31gKSk7XFxuICAgICAgLy8gQ2hpbGRyZW4gbmVlZHMgdG8gcmV0dXJuIHNsb3QgaXRlbXNcXG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuID0gKG9wdGlvbnMpID0+ICRlbC5jaGlsZHJlbihvcHRpb25zKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkd3JhcHBlckVsID0gJGVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzc31gKTtcXG4gICAgfVxcbiAgICAvLyBFeHRlbmQgU3dpcGVyXFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICAkZWwsXFxuICAgICAgZWwsXFxuICAgICAgJHdyYXBwZXJFbCxcXG4gICAgICB3cmFwcGVyRWw6ICR3cmFwcGVyRWxbMF0sXFxuXFxuICAgICAgLy8gQ2xhc3Nlc1xcbiAgICAgIGNsYXNzTmFtZXM6IFtdLFxcblxcbiAgICAgIC8vIFNsaWRlc1xcbiAgICAgIHNsaWRlczogT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKSgpLFxcbiAgICAgIHNsaWRlc0dyaWQ6IFtdLFxcbiAgICAgIHNuYXBHcmlkOiBbXSxcXG4gICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxcblxcbiAgICAgIC8vIGlzRGlyZWN0aW9uXFxuICAgICAgaXNIb3Jpem9udGFsKCkge1xcbiAgICAgICAgcmV0dXJuIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XFxuICAgICAgfSxcXG4gICAgICBpc1ZlcnRpY2FsKCkge1xcbiAgICAgICAgcmV0dXJuIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnO1xcbiAgICAgIH0sXFxuICAgICAgLy8gUlRMXFxuICAgICAgcnRsOiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8ICRlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyksXFxuICAgICAgcnRsVHJhbnNsYXRlOiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcXG4gICAgICB3cm9uZ1JUTDogJHdyYXBwZXJFbC5jc3MoJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94JyxcXG5cXG4gICAgICAvLyBJbmRleGVzXFxuICAgICAgYWN0aXZlSW5kZXg6IDAsXFxuICAgICAgcmVhbEluZGV4OiAwLFxcblxcbiAgICAgIC8vXFxuICAgICAgaXNCZWdpbm5pbmc6IHRydWUsXFxuICAgICAgaXNFbmQ6IGZhbHNlLFxcblxcbiAgICAgIC8vIFByb3BzXFxuICAgICAgdHJhbnNsYXRlOiAwLFxcbiAgICAgIHByZXZpb3VzVHJhbnNsYXRlOiAwLFxcbiAgICAgIHByb2dyZXNzOiAwLFxcbiAgICAgIHZlbG9jaXR5OiAwLFxcbiAgICAgIGFuaW1hdGluZzogZmFsc2UsXFxuXFxuICAgICAgLy8gTG9ja3NcXG4gICAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcXG4gICAgICBhbGxvd1NsaWRlUHJldjogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlUHJldixcXG5cXG4gICAgICAvLyBUb3VjaCBFdmVudHNcXG4gICAgICB0b3VjaEV2ZW50czogKGZ1bmN0aW9uIHRvdWNoRXZlbnRzKCkge1xcbiAgICAgICAgY29uc3QgdG91Y2ggPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XFxuICAgICAgICBsZXQgZGVza3RvcCA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJ107XFxuICAgICAgICBpZiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzKSB7XFxuICAgICAgICAgIGRlc2t0b3AgPSBbJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCddO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggPSB7XFxuICAgICAgICAgIHN0YXJ0OiB0b3VjaFswXSxcXG4gICAgICAgICAgbW92ZTogdG91Y2hbMV0sXFxuICAgICAgICAgIGVuZDogdG91Y2hbMl0sXFxuICAgICAgICAgIGNhbmNlbDogdG91Y2hbM10sXFxuICAgICAgICB9O1xcbiAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcXG4gICAgICAgICAgc3RhcnQ6IGRlc2t0b3BbMF0sXFxuICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXFxuICAgICAgICAgIGVuZDogZGVza3RvcFsyXSxcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gU3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xcbiAgICAgIH0oKSksXFxuICAgICAgdG91Y2hFdmVudHNEYXRhOiB7XFxuICAgICAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcXG4gICAgICAgIGlzTW92ZWQ6IHVuZGVmaW5lZCxcXG4gICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6IHVuZGVmaW5lZCxcXG4gICAgICAgIHRvdWNoU3RhcnRUaW1lOiB1bmRlZmluZWQsXFxuICAgICAgICBpc1Njcm9sbGluZzogdW5kZWZpbmVkLFxcbiAgICAgICAgY3VycmVudFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxcbiAgICAgICAgc3RhcnRUcmFuc2xhdGU6IHVuZGVmaW5lZCxcXG4gICAgICAgIGFsbG93VGhyZXNob2xkTW92ZTogdW5kZWZpbmVkLFxcbiAgICAgICAgLy8gRm9ybSBlbGVtZW50cyB0byBtYXRjaFxcbiAgICAgICAgZm9ybUVsZW1lbnRzOiAnaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbywgbGFiZWwnLFxcbiAgICAgICAgLy8gTGFzdCBjbGljayB0aW1lXFxuICAgICAgICBsYXN0Q2xpY2tUaW1lOiBVdGlscy5ub3coKSxcXG4gICAgICAgIGNsaWNrVGltZW91dDogdW5kZWZpbmVkLFxcbiAgICAgICAgLy8gVmVsb2NpdGllc1xcbiAgICAgICAgdmVsb2NpdGllczogW10sXFxuICAgICAgICBhbGxvd01vbWVudHVtQm91bmNlOiB1bmRlZmluZWQsXFxuICAgICAgICBpc1RvdWNoRXZlbnQ6IHVuZGVmaW5lZCxcXG4gICAgICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWQsXFxuICAgICAgfSxcXG5cXG4gICAgICAvLyBDbGlja3NcXG4gICAgICBhbGxvd0NsaWNrOiB0cnVlLFxcblxcbiAgICAgIC8vIFRvdWNoZXNcXG4gICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcXG5cXG4gICAgICB0b3VjaGVzOiB7XFxuICAgICAgICBzdGFydFg6IDAsXFxuICAgICAgICBzdGFydFk6IDAsXFxuICAgICAgICBjdXJyZW50WDogMCxcXG4gICAgICAgIGN1cnJlbnRZOiAwLFxcbiAgICAgICAgZGlmZjogMCxcXG4gICAgICB9LFxcblxcbiAgICAgIC8vIEltYWdlc1xcbiAgICAgIGltYWdlc1RvTG9hZDogW10sXFxuICAgICAgaW1hZ2VzTG9hZGVkOiAwLFxcblxcbiAgICB9KTtcXG5cXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXFxuICAgIHN3aXBlci51c2VNb2R1bGVzKCk7XFxuXFxuICAgIC8vIEluaXRcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaW5pdCkge1xcbiAgICAgIHN3aXBlci5pbml0KCk7XFxuICAgIH1cXG5cXG4gICAgLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxcbiAgICByZXR1cm4gc3dpcGVyO1xcbiAgfVxcblxcbiAgc2xpZGVzUGVyVmlld0R5bmFtaWMoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHtcXG4gICAgICBwYXJhbXMsIHNsaWRlcywgc2xpZGVzR3JpZCwgc2l6ZTogc3dpcGVyU2l6ZSwgYWN0aXZlSW5kZXgsXFxuICAgIH0gPSBzd2lwZXI7XFxuICAgIGxldCBzcHYgPSAxO1xcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgbGV0IHNsaWRlU2l6ZSA9IHNsaWRlc1thY3RpdmVJbmRleF0uc3dpcGVyU2xpZGVTaXplO1xcbiAgICAgIGxldCBicmVha0xvb3A7XFxuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XFxuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xcbiAgICAgICAgICBzcHYgKz0gMTtcXG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XFxuICAgICAgICBpZiAoc2xpZGVzW2ldICYmICFicmVha0xvb3ApIHtcXG4gICAgICAgICAgc2xpZGVTaXplICs9IHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemU7XFxuICAgICAgICAgIHNwdiArPSAxO1xcbiAgICAgICAgICBpZiAoc2xpZGVTaXplID4gc3dpcGVyU2l6ZSkgYnJlYWtMb29wID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHNsaWRlc0dyaWRbaV0gLSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSA8IHN3aXBlclNpemUpIHtcXG4gICAgICAgICAgc3B2ICs9IDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBzcHY7XFxuICB9XFxuXFxuICB1cGRhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgY29uc3QgeyBzbmFwR3JpZCwgcGFyYW1zIH0gPSBzd2lwZXI7XFxuICAgIC8vIEJyZWFrcG9pbnRzXFxuICAgIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcXG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xcbiAgICB9XFxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuXFxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlICogLTEgOiBzd2lwZXIudHJhbnNsYXRlO1xcbiAgICAgIGNvbnN0IG5ld1RyYW5zbGF0ZSA9IE1hdGgubWluKE1hdGgubWF4KHRyYW5zbGF0ZVZhbHVlLCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpLCBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcXG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICB9XFxuICAgIGxldCB0cmFuc2xhdGVkO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSkge1xcbiAgICAgIHNldFRyYW5zbGF0ZSgpO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICgoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCF0cmFuc2xhdGVkKSB7XFxuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcXG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xcbiAgICB9XFxuICAgIHN3aXBlci5lbWl0KCd1cGRhdGUnKTtcXG4gIH1cXG5cXG4gIGNoYW5nZURpcmVjdGlvbihuZXdEaXJlY3Rpb24sIG5lZWRVcGRhdGUgPSB0cnVlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IGN1cnJlbnREaXJlY3Rpb24gPSBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbjtcXG4gICAgaWYgKCFuZXdEaXJlY3Rpb24pIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xcbiAgICB9XFxuICAgIGlmICgobmV3RGlyZWN0aW9uID09PSBjdXJyZW50RGlyZWN0aW9uKSB8fCAobmV3RGlyZWN0aW9uICE9PSAnaG9yaXpvbnRhbCcgJiYgbmV3RGlyZWN0aW9uICE9PSAndmVydGljYWwnKSkge1xcbiAgICAgIHJldHVybiBzd2lwZXI7XFxuICAgIH1cXG5cXG4gICAgc3dpcGVyLiRlbFxcbiAgICAgIC5yZW1vdmVDbGFzcyhgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtjdXJyZW50RGlyZWN0aW9ufWApXFxuICAgICAgLmFkZENsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke25ld0RpcmVjdGlvbn1gKTtcXG5cXG4gICAgc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPSBuZXdEaXJlY3Rpb247XFxuXFxuICAgIHN3aXBlci5zbGlkZXMuZWFjaCgoc2xpZGVJbmRleCwgc2xpZGVFbCkgPT4ge1xcbiAgICAgIGlmIChuZXdEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcXG4gICAgICAgIHNsaWRlRWwuc3R5bGUud2lkdGggPSAnJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2xpZGVFbC5zdHlsZS5oZWlnaHQgPSAnJztcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBzd2lwZXIuZW1pdCgnY2hhbmdlRGlyZWN0aW9uJyk7XFxuICAgIGlmIChuZWVkVXBkYXRlKSBzd2lwZXIudXBkYXRlKCk7XFxuXFxuICAgIHJldHVybiBzd2lwZXI7XFxuICB9XFxuXFxuICBpbml0KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XFxuXFxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7XFxuXFxuICAgIC8vIFNldCBicmVha3BvaW50XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmJyZWFrcG9pbnRzKSB7XFxuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcXG4gICAgfVxcblxcbiAgICAvLyBBZGQgQ2xhc3Nlc1xcbiAgICBzd2lwZXIuYWRkQ2xhc3NlcygpO1xcblxcbiAgICAvLyBDcmVhdGUgbG9vcFxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcXG4gICAgfVxcblxcbiAgICAvLyBVcGRhdGUgc2l6ZVxcbiAgICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xcblxcbiAgICAvLyBVcGRhdGUgc2xpZGVzXFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykge1xcbiAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XFxuICAgIH1cXG5cXG4gICAgLy8gU2V0IEdyYWIgQ3Vyc29yXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3IpIHtcXG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMpIHtcXG4gICAgICBzd2lwZXIucHJlbG9hZEltYWdlcygpO1xcbiAgICB9XFxuXFxuICAgIC8vIFNsaWRlIFRvIEluaXRpYWwgU2xpZGVcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCk7XFxuICAgIH1cXG5cXG4gICAgLy8gQXR0YWNoIGV2ZW50c1xcbiAgICBzd2lwZXIuYXR0YWNoRXZlbnRzKCk7XFxuXFxuICAgIC8vIEluaXQgRmxhZ1xcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xcblxcbiAgICAvLyBFbWl0XFxuICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XFxuICB9XFxuXFxuICBkZXN0cm95KGRlbGV0ZUluc3RhbmNlID0gdHJ1ZSwgY2xlYW5TdHlsZXMgPSB0cnVlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHtcXG4gICAgICBwYXJhbXMsICRlbCwgJHdyYXBwZXJFbCwgc2xpZGVzLFxcbiAgICB9ID0gc3dpcGVyO1xcblxcbiAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlci5kZXN0cm95ZWQpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpO1xcblxcbiAgICAvLyBJbml0IEZsYWdcXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gZmFsc2U7XFxuXFxuICAgIC8vIERldGFjaCBldmVudHNcXG4gICAgc3dpcGVyLmRldGFjaEV2ZW50cygpO1xcblxcbiAgICAvLyBEZXN0cm95IGxvb3BcXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XFxuICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XFxuICAgIH1cXG5cXG4gICAgLy8gQ2xlYW51cCBzdHlsZXNcXG4gICAgaWYgKGNsZWFuU3R5bGVzKSB7XFxuICAgICAgc3dpcGVyLnJlbW92ZUNsYXNzZXMoKTtcXG4gICAgICAkZWwucmVtb3ZlQXR0cignc3R5bGUnKTtcXG4gICAgICAkd3JhcHBlckVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XFxuICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XFxuICAgICAgICBzbGlkZXNcXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFtcXG4gICAgICAgICAgICBwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsXFxuICAgICAgICAgICAgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsXFxuICAgICAgICAgICAgcGFyYW1zLnNsaWRlTmV4dENsYXNzLFxcbiAgICAgICAgICAgIHBhcmFtcy5zbGlkZVByZXZDbGFzcyxcXG4gICAgICAgICAgXS5qb2luKCcgJykpXFxuICAgICAgICAgIC5yZW1vdmVBdHRyKCdzdHlsZScpXFxuICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBzd2lwZXIuZW1pdCgnZGVzdHJveScpO1xcblxcbiAgICAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcXG4gICAgT2JqZWN0LmtleXMoc3dpcGVyLmV2ZW50c0xpc3RlbmVycykuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XFxuICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xcbiAgICB9KTtcXG5cXG4gICAgaWYgKGRlbGV0ZUluc3RhbmNlICE9PSBmYWxzZSkge1xcbiAgICAgIHN3aXBlci4kZWxbMF0uc3dpcGVyID0gbnVsbDtcXG4gICAgICBzd2lwZXIuJGVsLmRhdGEoJ3N3aXBlcicsIG51bGwpO1xcbiAgICAgIFV0aWxzLmRlbGV0ZVByb3BzKHN3aXBlcik7XFxuICAgIH1cXG4gICAgc3dpcGVyLmRlc3Ryb3llZCA9IHRydWU7XFxuXFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgc3RhdGljIGV4dGVuZERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XFxuICAgIFV0aWxzLmV4dGVuZChleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IGV4dGVuZGVkRGVmYXVsdHMoKSB7XFxuICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBDbGFzcygpIHtcXG4gICAgcmV0dXJuIFN3aXBlckNsYXNzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCAkKCkge1xcbiAgICByZXR1cm4gZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl07XFxuICB9XFxufVxcblxcbnZhciBEZXZpY2UkMSA9IHtcXG4gIG5hbWU6ICdkZXZpY2UnLFxcbiAgcHJvdG86IHtcXG4gICAgZGV2aWNlOiBEZXZpY2UsXFxuICB9LFxcbiAgc3RhdGljOiB7XFxuICAgIGRldmljZTogRGV2aWNlLFxcbiAgfSxcXG59O1xcblxcbnZhciBTdXBwb3J0JDEgPSB7XFxuICBuYW1lOiAnc3VwcG9ydCcsXFxuICBwcm90bzoge1xcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxcbiAgfSxcXG4gIHN0YXRpYzoge1xcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxcbiAgfSxcXG59O1xcblxcbmNvbnN0IEJyb3dzZXIgPSAoZnVuY3Rpb24gQnJvd3NlcigpIHtcXG4gIGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xcbiAgICBjb25zdCB1YSA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xcbiAgICByZXR1cm4gKHVhLmluZGV4T2YoJ3NhZmFyaScpID49IDAgJiYgdWEuaW5kZXhPZignY2hyb21lJykgPCAwICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSA8IDApO1xcbiAgfVxcbiAgcmV0dXJuIHtcXG4gICAgaXNFZGdlOiAhIXNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZS9nKSxcXG4gICAgaXNTYWZhcmk6IGlzU2FmYXJpKCksXFxuICAgIGlzV2ViVmlldzogLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaS50ZXN0KHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yLnVzZXJBZ2VudCksXFxuICB9O1xcbn0oKSk7XFxuXFxudmFyIEJyb3dzZXIkMSA9IHtcXG4gIG5hbWU6ICdicm93c2VyJyxcXG4gIHByb3RvOiB7XFxuICAgIGJyb3dzZXI6IEJyb3dzZXIsXFxuICB9LFxcbiAgc3RhdGljOiB7XFxuICAgIGJyb3dzZXI6IEJyb3dzZXIsXFxuICB9LFxcbn07XFxuXFxudmFyIFJlc2l6ZSA9IHtcXG4gIG5hbWU6ICdyZXNpemUnLFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgcmVzaXplOiB7XFxuICAgICAgICByZXNpemVIYW5kbGVyKCkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVJlc2l6ZScpO1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgncmVzaXplJyk7XFxuICAgICAgICB9LFxcbiAgICAgICAgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKCkge1xcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ29yaWVudGF0aW9uY2hhbmdlJyk7XFxuICAgICAgICB9LFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICAvLyBFbWl0IHJlc2l6ZVxcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3dpcGVyLnJlc2l6ZS5yZXNpemVIYW5kbGVyKTtcXG5cXG4gICAgICAvLyBFbWl0IG9yaWVudGF0aW9uY2hhbmdlXFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHN3aXBlci5yZXNpemUub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcXG4gICAgfSxcXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3dpcGVyLnJlc2l6ZS5yZXNpemVIYW5kbGVyKTtcXG4gICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgc3dpcGVyLnJlc2l6ZS5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xcbiAgICB9LFxcbiAgfSxcXG59O1xcblxcbmNvbnN0IE9ic2VydmVyID0ge1xcbiAgZnVuYzogc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5NdXRhdGlvbk9ic2VydmVyIHx8IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uV2Via2l0TXV0YXRpb25PYnNlcnZlcixcXG4gIGF0dGFjaCh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBjb25zdCBPYnNlcnZlckZ1bmMgPSBPYnNlcnZlci5mdW5jO1xcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlckZ1bmMoKG11dGF0aW9ucykgPT4ge1xcbiAgICAgIC8vIFRoZSBvYnNlcnZlclVwZGF0ZSBldmVudCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWRcXG4gICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXFxuICAgICAgLy8gdHJpZ2dlcnMgYXJlIHJlZHVuZGFudCBhbmQgYXJlIHZlcnkgY29zdGx5XFxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IG9ic2VydmVyVXBkYXRlID0gZnVuY3Rpb24gb2JzZXJ2ZXJVcGRhdGUoKSB7XFxuICAgICAgICBzd2lwZXIuZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XFxuICAgICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcXG4gICAgICBhdHRyaWJ1dGVzOiB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmF0dHJpYnV0ZXMsXFxuICAgICAgY2hpbGRMaXN0OiB0eXBlb2Ygb3B0aW9ucy5jaGlsZExpc3QgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hpbGRMaXN0LFxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHR5cGVvZiBvcHRpb25zLmNoYXJhY3RlckRhdGEgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hhcmFjdGVyRGF0YSxcXG4gICAgfSk7XFxuXFxuICAgIHN3aXBlci5vYnNlcnZlci5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XFxuICB9LFxcbiAgaW5pdCgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKCFTdXBwb3J0Lm9ic2VydmVyIHx8ICFzd2lwZXIucGFyYW1zLm9ic2VydmVyKSByZXR1cm47XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLm9ic2VydmVQYXJlbnRzKSB7XFxuICAgICAgY29uc3QgY29udGFpbmVyUGFyZW50cyA9IHN3aXBlci4kZWwucGFyZW50cygpO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyUGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgc3dpcGVyLm9ic2VydmVyLmF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcXG4gICAgc3dpcGVyLm9ic2VydmVyLmF0dGFjaChzd2lwZXIuJGVsWzBdLCB7IGNoaWxkTGlzdDogc3dpcGVyLnBhcmFtcy5vYnNlcnZlU2xpZGVDaGlsZHJlbiB9KTtcXG5cXG4gICAgLy8gT2JzZXJ2ZSB3cmFwcGVyXFxuICAgIHN3aXBlci5vYnNlcnZlci5hdHRhY2goc3dpcGVyLiR3cmFwcGVyRWxbMF0sIHsgYXR0cmlidXRlczogZmFsc2UgfSk7XFxuICB9LFxcbiAgZGVzdHJveSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgc3dpcGVyLm9ic2VydmVyLm9ic2VydmVycy5mb3JFYWNoKChvYnNlcnZlcikgPT4ge1xcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcXG4gICAgfSk7XFxuICAgIHN3aXBlci5vYnNlcnZlci5vYnNlcnZlcnMgPSBbXTtcXG4gIH0sXFxufTtcXG5cXG52YXIgT2JzZXJ2ZXIkMSA9IHtcXG4gIG5hbWU6ICdvYnNlcnZlcicsXFxuICBwYXJhbXM6IHtcXG4gICAgb2JzZXJ2ZXI6IGZhbHNlLFxcbiAgICBvYnNlcnZlUGFyZW50czogZmFsc2UsXFxuICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiBmYWxzZSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBvYnNlcnZlcjoge1xcbiAgICAgICAgaW5pdDogT2JzZXJ2ZXIuaW5pdC5iaW5kKHN3aXBlciksXFxuICAgICAgICBhdHRhY2g6IE9ic2VydmVyLmF0dGFjaC5iaW5kKHN3aXBlciksXFxuICAgICAgICBkZXN0cm95OiBPYnNlcnZlci5kZXN0cm95LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9ic2VydmVyczogW10sXFxuICAgICAgfSxcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgaW5pdCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHN3aXBlci5vYnNlcnZlci5pbml0KCk7XFxuICAgIH0sXFxuICAgIGRlc3Ryb3koKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIub2JzZXJ2ZXIuZGVzdHJveSgpO1xcbiAgICB9LFxcbiAgfSxcXG59O1xcblxcbmNvbnN0IFZpcnR1YWwgPSB7XFxuICB1cGRhdGUoZm9yY2UpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyBzbGlkZXNQZXJWaWV3LCBzbGlkZXNQZXJHcm91cCwgY2VudGVyZWRTbGlkZXMgfSA9IHN3aXBlci5wYXJhbXM7XFxuICAgIGNvbnN0IHsgYWRkU2xpZGVzQmVmb3JlLCBhZGRTbGlkZXNBZnRlciB9ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsO1xcbiAgICBjb25zdCB7XFxuICAgICAgZnJvbTogcHJldmlvdXNGcm9tLFxcbiAgICAgIHRvOiBwcmV2aW91c1RvLFxcbiAgICAgIHNsaWRlcyxcXG4gICAgICBzbGlkZXNHcmlkOiBwcmV2aW91c1NsaWRlc0dyaWQsXFxuICAgICAgcmVuZGVyU2xpZGUsXFxuICAgICAgb2Zmc2V0OiBwcmV2aW91c09mZnNldCxcXG4gICAgfSA9IHN3aXBlci52aXJ0dWFsO1xcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcXG5cXG4gICAgbGV0IG9mZnNldFByb3A7XFxuICAgIGlmIChzd2lwZXIucnRsVHJhbnNsYXRlKSBvZmZzZXRQcm9wID0gJ3JpZ2h0JztcXG4gICAgZWxzZSBvZmZzZXRQcm9wID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCc7XFxuXFxuICAgIGxldCBzbGlkZXNBZnRlcjtcXG4gICAgbGV0IHNsaWRlc0JlZm9yZTtcXG4gICAgaWYgKGNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgc2xpZGVzQWZ0ZXIgPSBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSArIHNsaWRlc1Blckdyb3VwICsgYWRkU2xpZGVzQmVmb3JlO1xcbiAgICAgIHNsaWRlc0JlZm9yZSA9IE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpICsgc2xpZGVzUGVyR3JvdXAgKyBhZGRTbGlkZXNBZnRlcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzbGlkZXNBZnRlciA9IHNsaWRlc1BlclZpZXcgKyAoc2xpZGVzUGVyR3JvdXAgLSAxKSArIGFkZFNsaWRlc0JlZm9yZTtcXG4gICAgICBzbGlkZXNCZWZvcmUgPSBzbGlkZXNQZXJHcm91cCArIGFkZFNsaWRlc0FmdGVyO1xcbiAgICB9XFxuICAgIGNvbnN0IGZyb20gPSBNYXRoLm1heCgoYWN0aXZlSW5kZXggfHwgMCkgLSBzbGlkZXNCZWZvcmUsIDApO1xcbiAgICBjb25zdCB0byA9IE1hdGgubWluKChhY3RpdmVJbmRleCB8fCAwKSArIHNsaWRlc0FmdGVyLCBzbGlkZXMubGVuZ3RoIC0gMSk7XFxuICAgIGNvbnN0IG9mZnNldCA9IChzd2lwZXIuc2xpZGVzR3JpZFtmcm9tXSB8fCAwKSAtIChzd2lwZXIuc2xpZGVzR3JpZFswXSB8fCAwKTtcXG5cXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlci52aXJ0dWFsLCB7XFxuICAgICAgZnJvbSxcXG4gICAgICB0byxcXG4gICAgICBvZmZzZXQsXFxuICAgICAgc2xpZGVzR3JpZDogc3dpcGVyLnNsaWRlc0dyaWQsXFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBvblJlbmRlcmVkKCkge1xcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcXG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xcbiAgICAgIGlmIChzd2lwZXIubGF6eSAmJiBzd2lwZXIucGFyYW1zLmxhenkuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocHJldmlvdXNGcm9tID09PSBmcm9tICYmIHByZXZpb3VzVG8gPT09IHRvICYmICFmb3JjZSkge1xcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzR3JpZCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkICYmIG9mZnNldCAhPT0gcHJldmlvdXNPZmZzZXQpIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZXMuY3NzKG9mZnNldFByb3AsIGAke29mZnNldH1weGApO1xcbiAgICAgIH1cXG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbCkge1xcbiAgICAgIHN3aXBlci5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbC5jYWxsKHN3aXBlciwge1xcbiAgICAgICAgb2Zmc2V0LFxcbiAgICAgICAgZnJvbSxcXG4gICAgICAgIHRvLFxcbiAgICAgICAgc2xpZGVzOiAoZnVuY3Rpb24gZ2V0U2xpZGVzKCkge1xcbiAgICAgICAgICBjb25zdCBzbGlkZXNUb1JlbmRlciA9IFtdO1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSArPSAxKSB7XFxuICAgICAgICAgICAgc2xpZGVzVG9SZW5kZXIucHVzaChzbGlkZXNbaV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBzbGlkZXNUb1JlbmRlcjtcXG4gICAgICAgIH0oKSksXFxuICAgICAgfSk7XFxuICAgICAgb25SZW5kZXJlZCgpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25zdCBwcmVwZW5kSW5kZXhlcyA9IFtdO1xcbiAgICBjb25zdCBhcHBlbmRJbmRleGVzID0gW107XFxuICAgIGlmIChmb3JjZSkge1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKS5yZW1vdmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNGcm9tOyBpIDw9IHByZXZpb3VzVG87IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKGkgPCBmcm9tIHx8IGkgPiB0bykge1xcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke2l9XFxcIl1gKS5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNUbyA9PT0gJ3VuZGVmaW5lZCcgfHwgZm9yY2UpIHtcXG4gICAgICAgICAgYXBwZW5kSW5kZXhlcy5wdXNoKGkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKGkgPiBwcmV2aW91c1RvKSBhcHBlbmRJbmRleGVzLnB1c2goaSk7XFxuICAgICAgICAgIGlmIChpIDwgcHJldmlvdXNGcm9tKSBwcmVwZW5kSW5kZXhlcy5wdXNoKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBhcHBlbmRJbmRleGVzLmZvckVhY2goKGluZGV4KSA9PiB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuYXBwZW5kKHJlbmRlclNsaWRlKHNsaWRlc1tpbmRleF0sIGluZGV4KSk7XFxuICAgIH0pO1xcbiAgICBwcmVwZW5kSW5kZXhlcy5zb3J0KChhLCBiKSA9PiBiIC0gYSkuZm9yRWFjaCgoaW5kZXgpID0+IHtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5wcmVwZW5kKHJlbmRlclNsaWRlKHNsaWRlc1tpbmRleF0sIGluZGV4KSk7XFxuICAgIH0pO1xcbiAgICBzd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbignLnN3aXBlci1zbGlkZScpLmNzcyhvZmZzZXRQcm9wLCBgJHtvZmZzZXR9cHhgKTtcXG4gICAgb25SZW5kZXJlZCgpO1xcbiAgfSxcXG4gIHJlbmRlclNsaWRlKHNsaWRlLCBpbmRleCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnZpcnR1YWw7XFxuICAgIGlmIChwYXJhbXMuY2FjaGUgJiYgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdKSB7XFxuICAgICAgcmV0dXJuIHN3aXBlci52aXJ0dWFsLmNhY2hlW2luZGV4XTtcXG4gICAgfVxcbiAgICBjb25zdCAkc2xpZGVFbCA9IHBhcmFtcy5yZW5kZXJTbGlkZVxcbiAgICAgID8gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShwYXJhbXMucmVuZGVyU2xpZGUuY2FsbChzd2lwZXIsIHNsaWRlLCBpbmRleCkpXFxuICAgICAgOiBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGA8ZGl2IGNsYXNzPVxcXCIke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31cXFwiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke2luZGV4fVxcXCI+JHtzbGlkZX08L2Rpdj5gKTtcXG4gICAgaWYgKCEkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpKSAkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcXG4gICAgaWYgKHBhcmFtcy5jYWNoZSkgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdID0gJHNsaWRlRWw7XFxuICAgIHJldHVybiAkc2xpZGVFbDtcXG4gIH0sXFxuICBhcHBlbmRTbGlkZShzbGlkZXMpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHR5cGVvZiBzbGlkZXMgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHNsaWRlcykge1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICBpZiAoc2xpZGVzW2ldKSBzd2lwZXIudmlydHVhbC5zbGlkZXMucHVzaChzbGlkZXNbaV0pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMucHVzaChzbGlkZXMpO1xcbiAgICB9XFxuICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcXG4gIH0sXFxuICBwcmVwZW5kU2xpZGUoc2xpZGVzKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIDE7XFxuICAgIGxldCBudW1iZXJPZk5ld1NsaWRlcyA9IDE7XFxuXFxuICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlcykpIHtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHNsaWRlc1tpXSkgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoc2xpZGVzW2ldKTtcXG4gICAgICB9XFxuICAgICAgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIHNsaWRlcy5sZW5ndGg7XFxuICAgICAgbnVtYmVyT2ZOZXdTbGlkZXMgPSBzbGlkZXMubGVuZ3RoO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcy51bnNoaWZ0KHNsaWRlcyk7XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xcbiAgICAgIGNvbnN0IGNhY2hlID0gc3dpcGVyLnZpcnR1YWwuY2FjaGU7XFxuICAgICAgY29uc3QgbmV3Q2FjaGUgPSB7fTtcXG4gICAgICBPYmplY3Qua2V5cyhjYWNoZSkuZm9yRWFjaCgoY2FjaGVkSW5kZXgpID0+IHtcXG4gICAgICAgIGNvbnN0ICRjYWNoZWRFbCA9IGNhY2hlW2NhY2hlZEluZGV4XTtcXG4gICAgICAgIGNvbnN0IGNhY2hlZEVsSW5kZXggPSAkY2FjaGVkRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcXG4gICAgICAgIGlmIChjYWNoZWRFbEluZGV4KSB7XFxuICAgICAgICAgICRjYWNoZWRFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIHBhcnNlSW50KGNhY2hlZEVsSW5kZXgsIDEwKSArIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV3Q2FjaGVbcGFyc2VJbnQoY2FjaGVkSW5kZXgsIDEwKSArIG51bWJlck9mTmV3U2xpZGVzXSA9ICRjYWNoZWRFbDtcXG4gICAgICB9KTtcXG4gICAgICBzd2lwZXIudmlydHVhbC5jYWNoZSA9IG5ld0NhY2hlO1xcbiAgICB9XFxuICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcXG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDApO1xcbiAgfSxcXG4gIHJlbW92ZVNsaWRlKHNsaWRlc0luZGV4ZXMpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHR5cGVvZiBzbGlkZXNJbmRleGVzID09PSAndW5kZWZpbmVkJyB8fCBzbGlkZXNJbmRleGVzID09PSBudWxsKSByZXR1cm47XFxuICAgIGxldCBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2xpZGVzSW5kZXhlcykpIHtcXG4gICAgICBmb3IgKGxldCBpID0gc2xpZGVzSW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnNwbGljZShzbGlkZXNJbmRleGVzW2ldLCAxKTtcXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcXG4gICAgICAgICAgZGVsZXRlIHN3aXBlci52aXJ0dWFsLmNhY2hlW3NsaWRlc0luZGV4ZXNbaV1dO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHNsaWRlc0luZGV4ZXNbaV0gPCBhY3RpdmVJbmRleCkgYWN0aXZlSW5kZXggLT0gMTtcXG4gICAgICAgIGFjdGl2ZUluZGV4ID0gTWF0aC5tYXgoYWN0aXZlSW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMuc3BsaWNlKHNsaWRlc0luZGV4ZXMsIDEpO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcXG4gICAgICAgIGRlbGV0ZSBzd2lwZXIudmlydHVhbC5jYWNoZVtzbGlkZXNJbmRleGVzXTtcXG4gICAgICB9XFxuICAgICAgaWYgKHNsaWRlc0luZGV4ZXMgPCBhY3RpdmVJbmRleCkgYWN0aXZlSW5kZXggLT0gMTtcXG4gICAgICBhY3RpdmVJbmRleCA9IE1hdGgubWF4KGFjdGl2ZUluZGV4LCAwKTtcXG4gICAgfVxcbiAgICBzd2lwZXIudmlydHVhbC51cGRhdGUodHJ1ZSk7XFxuICAgIHN3aXBlci5zbGlkZVRvKGFjdGl2ZUluZGV4LCAwKTtcXG4gIH0sXFxuICByZW1vdmVBbGxTbGlkZXMoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcyA9IFtdO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmNhY2hlKSB7XFxuICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGUgPSB7fTtcXG4gICAgfVxcbiAgICBzd2lwZXIudmlydHVhbC51cGRhdGUodHJ1ZSk7XFxuICAgIHN3aXBlci5zbGlkZVRvKDAsIDApO1xcbiAgfSxcXG59O1xcblxcbnZhciBWaXJ0dWFsJDEgPSB7XFxuICBuYW1lOiAndmlydHVhbCcsXFxuICBwYXJhbXM6IHtcXG4gICAgdmlydHVhbDoge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIHNsaWRlczogW10sXFxuICAgICAgY2FjaGU6IHRydWUsXFxuICAgICAgcmVuZGVyU2xpZGU6IG51bGwsXFxuICAgICAgcmVuZGVyRXh0ZXJuYWw6IG51bGwsXFxuICAgICAgYWRkU2xpZGVzQmVmb3JlOiAwLFxcbiAgICAgIGFkZFNsaWRlc0FmdGVyOiAwLFxcbiAgICB9LFxcbiAgfSxcXG4gIGNyZWF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIHZpcnR1YWw6IHtcXG4gICAgICAgIHVwZGF0ZTogVmlydHVhbC51cGRhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgYXBwZW5kU2xpZGU6IFZpcnR1YWwuYXBwZW5kU2xpZGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgcHJlcGVuZFNsaWRlOiBWaXJ0dWFsLnByZXBlbmRTbGlkZS5iaW5kKHN3aXBlciksXFxuICAgICAgICByZW1vdmVTbGlkZTogVmlydHVhbC5yZW1vdmVTbGlkZS5iaW5kKHN3aXBlciksXFxuICAgICAgICByZW1vdmVBbGxTbGlkZXM6IFZpcnR1YWwucmVtb3ZlQWxsU2xpZGVzLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHJlbmRlclNsaWRlOiBWaXJ0dWFsLnJlbmRlclNsaWRlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHNsaWRlczogc3dpcGVyLnBhcmFtcy52aXJ0dWFsLnNsaWRlcyxcXG4gICAgICAgIGNhY2hlOiB7fSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBiZWZvcmVJbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXZpcnR1YWxgKTtcXG4gICAgICBjb25zdCBvdmVyd3JpdGVQYXJhbXMgPSB7XFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxcbiAgICAgIH07XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcXG5cXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlKSB7XFxuICAgICAgICBzd2lwZXIudmlydHVhbC51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIudmlydHVhbC51cGRhdGUoKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBLZXlib2FyZCA9IHtcXG4gIGhhbmRsZShldmVudCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB7IHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XFxuICAgIGxldCBlID0gZXZlbnQ7XFxuICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7IC8vIGpxdWVyeSBmaXhcXG4gICAgY29uc3Qga2MgPSBlLmtleUNvZGUgfHwgZS5jaGFyQ29kZTtcXG4gICAgY29uc3QgcGFnZVVwRG93biA9IHN3aXBlci5wYXJhbXMua2V5Ym9hcmQucGFnZVVwRG93bjtcXG4gICAgY29uc3QgaXNQYWdlVXAgPSBwYWdlVXBEb3duICYmIGtjID09PSAzMztcXG4gICAgY29uc3QgaXNQYWdlRG93biA9IHBhZ2VVcERvd24gJiYga2MgPT09IDM0O1xcbiAgICBjb25zdCBpc0Fycm93TGVmdCA9IGtjID09PSAzNztcXG4gICAgY29uc3QgaXNBcnJvd1JpZ2h0ID0ga2MgPT09IDM5O1xcbiAgICBjb25zdCBpc0Fycm93VXAgPSBrYyA9PT0gMzg7XFxuICAgIGNvbnN0IGlzQXJyb3dEb3duID0ga2MgPT09IDQwO1xcbiAgICAvLyBEaXJlY3Rpb25zIGxvY2tzXFxuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmICgoc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIGlzQXJyb3dSaWdodCkgfHwgKHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgaXNBcnJvd0Rvd24pIHx8IGlzUGFnZURvd24pKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmICgoc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIGlzQXJyb3dMZWZ0KSB8fCAoc3dpcGVyLmlzVmVydGljYWwoKSAmJiBpc0Fycm93VXApIHx8IGlzUGFnZVVwKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoZS5zaGlmdEtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICBpZiAoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQgJiYgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgJiYgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgfHwgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykpIHtcXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmtleWJvYXJkLm9ubHlJblZpZXdwb3J0ICYmIChpc1BhZ2VVcCB8fCBpc1BhZ2VEb3duIHx8IGlzQXJyb3dMZWZ0IHx8IGlzQXJyb3dSaWdodCB8fCBpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24pKSB7XFxuICAgICAgbGV0IGluVmlldyA9IGZhbHNlO1xcbiAgICAgIC8vIENoZWNrIHRoYXQgc3dpcGVyIHNob3VsZCBiZSBpbnNpZGUgb2YgdmlzaWJsZSBhcmVhIG9mIHdpbmRvd1xcbiAgICAgIGlmIChzd2lwZXIuJGVsLnBhcmVudHMoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKS5sZW5ndGggPiAwICYmIHN3aXBlci4kZWwucGFyZW50cyhgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzfWApLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgY29uc3Qgd2luZG93V2lkdGggPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmlubmVyV2lkdGg7XFxuICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5pbm5lckhlaWdodDtcXG4gICAgICBjb25zdCBzd2lwZXJPZmZzZXQgPSBzd2lwZXIuJGVsLm9mZnNldCgpO1xcbiAgICAgIGlmIChydGwpIHN3aXBlck9mZnNldC5sZWZ0IC09IHN3aXBlci4kZWxbMF0uc2Nyb2xsTGVmdDtcXG4gICAgICBjb25zdCBzd2lwZXJDb29yZCA9IFtcXG4gICAgICAgIFtzd2lwZXJPZmZzZXQubGVmdCwgc3dpcGVyT2Zmc2V0LnRvcF0sXFxuICAgICAgICBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXIud2lkdGgsIHN3aXBlck9mZnNldC50b3BdLFxcbiAgICAgICAgW3N3aXBlck9mZnNldC5sZWZ0LCBzd2lwZXJPZmZzZXQudG9wICsgc3dpcGVyLmhlaWdodF0sXFxuICAgICAgICBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXIud2lkdGgsIHN3aXBlck9mZnNldC50b3AgKyBzd2lwZXIuaGVpZ2h0XSxcXG4gICAgICBdO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyQ29vcmQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGNvbnN0IHBvaW50ID0gc3dpcGVyQ29vcmRbaV07XFxuICAgICAgICBpZiAoXFxuICAgICAgICAgIHBvaW50WzBdID49IDAgJiYgcG9pbnRbMF0gPD0gd2luZG93V2lkdGhcXG4gICAgICAgICAgJiYgcG9pbnRbMV0gPj0gMCAmJiBwb2ludFsxXSA8PSB3aW5kb3dIZWlnaHRcXG4gICAgICAgICkge1xcbiAgICAgICAgICBpblZpZXcgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoIWluVmlldykgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgaWYgKGlzUGFnZVVwIHx8IGlzUGFnZURvd24gfHwgaXNBcnJvd0xlZnQgfHwgaXNBcnJvd1JpZ2h0KSB7XFxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIGlmICgoKGlzUGFnZURvd24gfHwgaXNBcnJvd1JpZ2h0KSAmJiAhcnRsKSB8fCAoKGlzUGFnZVVwIHx8IGlzQXJyb3dMZWZ0KSAmJiBydGwpKSBzd2lwZXIuc2xpZGVOZXh0KCk7XFxuICAgICAgaWYgKCgoaXNQYWdlVXAgfHwgaXNBcnJvd0xlZnQpICYmICFydGwpIHx8ICgoaXNQYWdlRG93biB8fCBpc0Fycm93UmlnaHQpICYmIHJ0bCkpIHN3aXBlci5zbGlkZVByZXYoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoaXNQYWdlVXAgfHwgaXNQYWdlRG93biB8fCBpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24pIHtcXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICBlbHNlIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzUGFnZURvd24gfHwgaXNBcnJvd0Rvd24pIHN3aXBlci5zbGlkZU5leHQoKTtcXG4gICAgICBpZiAoaXNQYWdlVXAgfHwgaXNBcnJvd1VwKSBzd2lwZXIuc2xpZGVQcmV2KCk7XFxuICAgIH1cXG4gICAgc3dpcGVyLmVtaXQoJ2tleVByZXNzJywga2MpO1xcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfSxcXG4gIGVuYWJsZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHN3aXBlci5rZXlib2FyZC5lbmFibGVkKSByZXR1cm47XFxuICAgIE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdKS5vbigna2V5ZG93bicsIHN3aXBlci5rZXlib2FyZC5oYW5kbGUpO1xcbiAgICBzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCA9IHRydWU7XFxuICB9LFxcbiAgZGlzYWJsZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKCFzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCkgcmV0dXJuO1xcbiAgICBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXSkub2ZmKCdrZXlkb3duJywgc3dpcGVyLmtleWJvYXJkLmhhbmRsZSk7XFxuICAgIHN3aXBlci5rZXlib2FyZC5lbmFibGVkID0gZmFsc2U7XFxuICB9LFxcbn07XFxuXFxudmFyIEtleWJvYXJkJDEgPSB7XFxuICBuYW1lOiAna2V5Ym9hcmQnLFxcbiAgcGFyYW1zOiB7XFxuICAgIGtleWJvYXJkOiB7XFxuICAgICAgZW5hYmxlZDogZmFsc2UsXFxuICAgICAgb25seUluVmlld3BvcnQ6IHRydWUsXFxuICAgICAgcGFnZVVwRG93bjogdHJ1ZSxcXG4gICAgfSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBrZXlib2FyZDoge1xcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXFxuICAgICAgICBlbmFibGU6IEtleWJvYXJkLmVuYWJsZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBkaXNhYmxlOiBLZXlib2FyZC5kaXNhYmxlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGhhbmRsZTogS2V5Ym9hcmQuaGFuZGxlLmJpbmQoc3dpcGVyKSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMua2V5Ym9hcmQuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmtleWJvYXJkLmVuYWJsZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmtleWJvYXJkLmRpc2FibGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZCgpIHtcXG4gIGNvbnN0IGV2ZW50TmFtZSA9ICdvbndoZWVsJztcXG4gIGxldCBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl07XFxuXFxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XFxuICAgIGNvbnN0IGVsZW1lbnQgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcXG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xcbiAgfVxcblxcbiAgaWYgKCFpc1N1cHBvcnRlZFxcbiAgICAmJiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uaW1wbGVtZW50YXRpb25cXG4gICAgJiYgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmVcXG4gICAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxcbiAgICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxcbiAgICAmJiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlXFxuICApIHtcXG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxcbiAgICBpc1N1cHBvcnRlZCA9IHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XFxuICB9XFxuXFxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XFxufVxcbmNvbnN0IE1vdXNld2hlZWwgPSB7XFxuICBsYXN0U2Nyb2xsVGltZTogVXRpbHMubm93KCksXFxuICBsYXN0RXZlbnRCZWZvcmVTbmFwOiB1bmRlZmluZWQsXFxuICByZWNlbnRXaGVlbEV2ZW50czogW10sXFxuICBldmVudCgpIHtcXG4gICAgaWYgKHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdmaXJlZm94JykgPiAtMSkgcmV0dXJuICdET01Nb3VzZVNjcm9sbCc7XFxuICAgIHJldHVybiBpc0V2ZW50U3VwcG9ydGVkKCkgPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnO1xcbiAgfSxcXG4gIG5vcm1hbGl6ZShlKSB7XFxuICAgIC8vIFJlYXNvbmFibGUgZGVmYXVsdHNcXG4gICAgY29uc3QgUElYRUxfU1RFUCA9IDEwO1xcbiAgICBjb25zdCBMSU5FX0hFSUdIVCA9IDQwO1xcbiAgICBjb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcXG5cXG4gICAgbGV0IHNYID0gMDtcXG4gICAgbGV0IHNZID0gMDsgLy8gc3BpblgsIHNwaW5ZXFxuICAgIGxldCBwWCA9IDA7XFxuICAgIGxldCBwWSA9IDA7IC8vIHBpeGVsWCwgcGl4ZWxZXFxuXFxuICAgIC8vIExlZ2FjeVxcbiAgICBpZiAoJ2RldGFpbCcgaW4gZSkge1xcbiAgICAgIHNZID0gZS5kZXRhaWw7XFxuICAgIH1cXG4gICAgaWYgKCd3aGVlbERlbHRhJyBpbiBlKSB7XFxuICAgICAgc1kgPSAtZS53aGVlbERlbHRhIC8gMTIwO1xcbiAgICB9XFxuICAgIGlmICgnd2hlZWxEZWx0YVknIGluIGUpIHtcXG4gICAgICBzWSA9IC1lLndoZWVsRGVsdGFZIC8gMTIwO1xcbiAgICB9XFxuICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGUpIHtcXG4gICAgICBzWCA9IC1lLndoZWVsRGVsdGFYIC8gMTIwO1xcbiAgICB9XFxuXFxuICAgIC8vIHNpZGUgc2Nyb2xsaW5nIG9uIEZGIHdpdGggRE9NTW91c2VTY3JvbGxcXG4gICAgaWYgKCdheGlzJyBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcXG4gICAgICBzWCA9IHNZO1xcbiAgICAgIHNZID0gMDtcXG4gICAgfVxcblxcbiAgICBwWCA9IHNYICogUElYRUxfU1RFUDtcXG4gICAgcFkgPSBzWSAqIFBJWEVMX1NURVA7XFxuXFxuICAgIGlmICgnZGVsdGFZJyBpbiBlKSB7XFxuICAgICAgcFkgPSBlLmRlbHRhWTtcXG4gICAgfVxcbiAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xcbiAgICAgIHBYID0gZS5kZWx0YVg7XFxuICAgIH1cXG5cXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIXBYKSB7IC8vIGlmIHVzZXIgc2Nyb2xscyB3aXRoIHNoaWZ0IGhlIHdhbnRzIGhvcml6b250YWwgc2Nyb2xsXFxuICAgICAgcFggPSBwWTtcXG4gICAgICBwWSA9IDA7XFxuICAgIH1cXG5cXG4gICAgaWYgKChwWCB8fCBwWSkgJiYgZS5kZWx0YU1vZGUpIHtcXG4gICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHsgLy8gZGVsdGEgaW4gTElORSB1bml0c1xcbiAgICAgICAgcFggKj0gTElORV9IRUlHSFQ7XFxuICAgICAgICBwWSAqPSBMSU5FX0hFSUdIVDtcXG4gICAgICB9IGVsc2UgeyAvLyBkZWx0YSBpbiBQQUdFIHVuaXRzXFxuICAgICAgICBwWCAqPSBQQUdFX0hFSUdIVDtcXG4gICAgICAgIHBZICo9IFBBR0VfSEVJR0hUO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBGYWxsLWJhY2sgaWYgc3BpbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxcbiAgICBpZiAocFggJiYgIXNYKSB7XFxuICAgICAgc1ggPSAocFggPCAxKSA/IC0xIDogMTtcXG4gICAgfVxcbiAgICBpZiAocFkgJiYgIXNZKSB7XFxuICAgICAgc1kgPSAocFkgPCAxKSA/IC0xIDogMTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHNwaW5YOiBzWCxcXG4gICAgICBzcGluWTogc1ksXFxuICAgICAgcGl4ZWxYOiBwWCxcXG4gICAgICBwaXhlbFk6IHBZLFxcbiAgICB9O1xcbiAgfSxcXG4gIGhhbmRsZU1vdXNlRW50ZXIoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5tb3VzZUVudGVyZWQgPSB0cnVlO1xcbiAgfSxcXG4gIGhhbmRsZU1vdXNlTGVhdmUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5tb3VzZUVudGVyZWQgPSBmYWxzZTtcXG4gIH0sXFxuICBoYW5kbGUoZXZlbnQpIHtcXG4gICAgbGV0IGUgPSBldmVudDtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xcblxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9XFxuXFxuICAgIGxldCB0YXJnZXQgPSBzd2lwZXIuJGVsO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdlZCAhPT0gJ2NvbnRhaW5lcicpIHtcXG4gICAgICB0YXJnZXQgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZWQpO1xcbiAgICB9XFxuICAgIGlmICghc3dpcGVyLm1vdXNlRW50ZXJlZCAmJiAhdGFyZ2V0WzBdLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiAhcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDsgLy8ganF1ZXJ5IGZpeFxcbiAgICBsZXQgZGVsdGEgPSAwO1xcbiAgICBjb25zdCBydGxGYWN0b3IgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xcblxcbiAgICBjb25zdCBkYXRhID0gTW91c2V3aGVlbC5ub3JtYWxpemUoZSk7XFxuXFxuICAgIGlmIChwYXJhbXMuZm9yY2VUb0F4aXMpIHtcXG4gICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5waXhlbFgpID4gTWF0aC5hYnMoZGF0YS5waXhlbFkpKSBkZWx0YSA9IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvcjtcXG4gICAgICAgIGVsc2UgcmV0dXJuIHRydWU7XFxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkYXRhLnBpeGVsWSkgPiBNYXRoLmFicyhkYXRhLnBpeGVsWCkpIGRlbHRhID0gLWRhdGEucGl4ZWxZO1xcbiAgICAgIGVsc2UgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGVsdGEgPSBNYXRoLmFicyhkYXRhLnBpeGVsWCkgPiBNYXRoLmFicyhkYXRhLnBpeGVsWSkgPyAtZGF0YS5waXhlbFggKiBydGxGYWN0b3IgOiAtZGF0YS5waXhlbFk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRlbHRhID09PSAwKSByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgaWYgKHBhcmFtcy5pbnZlcnQpIGRlbHRhID0gLWRlbHRhO1xcblxcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuZnJlZU1vZGUpIHtcXG4gICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGV2ZW50IGluIGEgdmFyaWFibGUgd2hpY2ggc3RvcmVzIHRoZSByZWxldmFudCBkYXRhXFxuICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XFxuICAgICAgICB0aW1lOiBVdGlscy5ub3coKSxcXG4gICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXFxuICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSksXFxuICAgICAgICByYXc6IGV2ZW50LFxcbiAgICAgIH07XFxuXFxuICAgICAgLy8gS2VlcCB0aGUgbW9zdCByZWNlbnQgZXZlbnRzXFxuICAgICAgY29uc3QgcmVjZW50V2hlZWxFdmVudHMgPSBzd2lwZXIubW91c2V3aGVlbC5yZWNlbnRXaGVlbEV2ZW50cztcXG4gICAgICBpZiAocmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID49IDIpIHtcXG4gICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNoaWZ0KCk7IC8vIG9ubHkgc3RvcmUgdGhlIGxhc3QgTiBldmVudHNcXG4gICAgICB9XFxuICAgICAgY29uc3QgcHJldkV2ZW50ID0gcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID8gcmVjZW50V2hlZWxFdmVudHNbcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XFxuICAgICAgcmVjZW50V2hlZWxFdmVudHMucHVzaChuZXdFdmVudCk7XFxuXFxuICAgICAgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZXZpb3VzIHJlY29yZGVkIGV2ZW50OlxcbiAgICAgIC8vICAgSWYgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkIG9yXFxuICAgICAgLy8gICBpZiB0aGUgc2Nyb2xsIGlzIHF1aWNrZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lOlxcbiAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXFxuICAgICAgLy8gRWxzZSAodGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgd2hlZWwgaXMgbW92ZWQpOlxcbiAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXFxuICAgICAgaWYgKHByZXZFdmVudCkge1xcbiAgICAgICAgaWYgKG5ld0V2ZW50LmRpcmVjdGlvbiAhPT0gcHJldkV2ZW50LmRpcmVjdGlvbiB8fCBuZXdFdmVudC5kZWx0YSA+IHByZXZFdmVudC5kZWx0YSB8fCBuZXdFdmVudC50aW1lID4gcHJldkV2ZW50LnRpbWUgKyAxNTApIHtcXG4gICAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuYW5pbWF0ZVNsaWRlcihuZXdFdmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN3aXBlci5tb3VzZXdoZWVsLmFuaW1hdGVTbGlkZXIobmV3RXZlbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBJZiBpdCdzIHRpbWUgdG8gcmVsZWFzZSB0aGUgc2Nyb2xsOlxcbiAgICAgIC8vICAgUmV0dXJuIG5vdyBzbyB5b3UgZG9uJ3QgaGl0IHRoZSBwcmV2ZW50RGVmYXVsdC5cXG4gICAgICBpZiAoc3dpcGVyLm1vdXNld2hlZWwucmVsZWFzZVNjcm9sbChuZXdFdmVudCkpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBGcmVlbW9kZSBvciBzY3JvbGxDb250YWluZXI6XFxuXFxuICAgICAgLy8gSWYgd2UgcmVjZW50bHkgc25hcHBlZCBhZnRlciBhIG1vbWVudHVtIHNjcm9sbCwgdGhlbiBpZ25vcmUgd2hlZWwgZXZlbnRzXFxuICAgICAgLy8gdG8gZ2l2ZSB0aW1lIGZvciB0aGUgZGVjZWxlcmF0aW9uIHRvIGZpbmlzaC4gU3RvcCBpZ25vcmluZyBhZnRlciA1MDAgbXNlY3NcXG4gICAgICAvLyBvciBpZiBpdCdzIGEgbmV3IHNjcm9sbCAobGFyZ2VyIGRlbHRhIG9yIGludmVyc2Ugc2lnbiBhcyBsYXN0IGV2ZW50IGJlZm9yZVxcbiAgICAgIC8vIGFuIGVuZC1vZi1tb21lbnR1bSBzbmFwKS5cXG4gICAgICBjb25zdCBuZXdFdmVudCA9IHsgdGltZTogVXRpbHMubm93KCksIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksIGRpcmVjdGlvbjogTWF0aC5zaWduKGRlbHRhKSB9O1xcbiAgICAgIGNvbnN0IHsgbGFzdEV2ZW50QmVmb3JlU25hcCB9ID0gc3dpcGVyLm1vdXNld2hlZWw7XFxuICAgICAgY29uc3QgaWdub3JlV2hlZWxFdmVudHMgPSBsYXN0RXZlbnRCZWZvcmVTbmFwXFxuICAgICAgICAmJiBuZXdFdmVudC50aW1lIDwgbGFzdEV2ZW50QmVmb3JlU25hcC50aW1lICsgNTAwXFxuICAgICAgICAmJiBuZXdFdmVudC5kZWx0YSA8PSBsYXN0RXZlbnRCZWZvcmVTbmFwLmRlbHRhXFxuICAgICAgICAmJiBuZXdFdmVudC5kaXJlY3Rpb24gPT09IGxhc3RFdmVudEJlZm9yZVNuYXAuZGlyZWN0aW9uO1xcbiAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIHtcXG4gICAgICAgIHN3aXBlci5tb3VzZXdoZWVsLmxhc3RFdmVudEJlZm9yZVNuYXAgPSB1bmRlZmluZWQ7XFxuXFxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgcG9zaXRpb24gPSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCkgKyAoZGVsdGEgKiBwYXJhbXMuc2Vuc2l0aXZpdHkpO1xcbiAgICAgICAgY29uc3Qgd2FzQmVnaW5uaW5nID0gc3dpcGVyLmlzQmVnaW5uaW5nO1xcbiAgICAgICAgY29uc3Qgd2FzRW5kID0gc3dpcGVyLmlzRW5kO1xcblxcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XFxuICAgICAgICBpZiAocG9zaXRpb24gPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSBwb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcXG5cXG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShwb3NpdGlvbik7XFxuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcXG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG5cXG4gICAgICAgIGlmICgoIXdhc0JlZ2lubmluZyAmJiBzd2lwZXIuaXNCZWdpbm5pbmcpIHx8ICghd2FzRW5kICYmIHN3aXBlci5pc0VuZCkpIHtcXG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICAgIC8vIFdoZW4gd2hlZWwgc2Nyb2xsaW5nIHN0YXJ0cyB3aXRoIHN0aWNreSAoYWthIHNuYXApIGVuYWJsZWQsIHRoZW4gZGV0ZWN0XFxuICAgICAgICAgIC8vIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgYnkgc3RvcmluZyByZWNlbnQgKE49MTU/KSB3aGVlbCBldmVudHMuXFxuICAgICAgICAgIC8vIDEuIGRvIGFsbCBOIGV2ZW50cyBoYXZlIGRlY3JlYXNpbmcgb3Igc2FtZSAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhP1xcbiAgICAgICAgICAvLyAyLiBkaWQgYWxsIE4gZXZlbnRzIGFycml2ZSBpbiB0aGUgbGFzdCBNIChNPTUwMD8pIG1zZWNzP1xcbiAgICAgICAgICAvLyAzLiBkb2VzIHRoZSBlYXJsaWVzdCBldmVudCBoYXZlIGFuIChhYnNvbHV0ZSB2YWx1ZSkgZGVsdGEgdGhhdCdzXFxuICAgICAgICAgIC8vICAgIGF0IGxlYXN0IFAgKFA9MT8pIGxhcmdlciB0aGFuIHRoZSBtb3N0IHJlY2VudCBldmVudCdzIGRlbHRhP1xcbiAgICAgICAgICAvLyA0LiBkb2VzIHRoZSBsYXRlc3QgZXZlbnQgaGF2ZSBhIGRlbHRhIHRoYXQncyBzbWFsbGVyIHRoYW4gUSAoUT02PykgcGl4ZWxzP1xcbiAgICAgICAgICAvLyBJZiAxLTQgYXJlIFxcXCJ5ZXNcXFwiIHRoZW4gd2UncmUgbmVhciB0aGUgZW5kIG9mIGEgbW9tdW50dW0gc2Nyb2xsIGRlY2VsZXJhdGlvbi5cXG4gICAgICAgICAgLy8gU25hcCBpbW1lZGlhdGVseSBhbmQgaWdub3JlIHJlbWFpbmluZyB3aGVlbCBldmVudHMgaW4gdGhpcyBzY3JvbGwuXFxuICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGZvciBcXFwicmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbFxcXCIgZGV0ZXJtaW5hdGlvbi5cXG4gICAgICAgICAgLy8gSWYgMS00IGFyZW4ndCBzYXRpc2ZpZWQsIHRoZW4gd2FpdCB0byBzbmFwIHVudGlsIDUwMG1zIGFmdGVyIHRoZSBsYXN0IGV2ZW50LlxcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc3dpcGVyLm1vdXNld2hlZWwudGltZW91dCk7XFxuICAgICAgICAgIHN3aXBlci5tb3VzZXdoZWVsLnRpbWVvdXQgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIGNvbnN0IHJlY2VudFdoZWVsRXZlbnRzID0gc3dpcGVyLm1vdXNld2hlZWwucmVjZW50V2hlZWxFdmVudHM7XFxuICAgICAgICAgIGlmIChyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPj0gMTUpIHtcXG4gICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zaGlmdCgpOyAvLyBvbmx5IHN0b3JlIHRoZSBsYXN0IE4gZXZlbnRzXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY29uc3QgcHJldkV2ZW50ID0gcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID8gcmVjZW50V2hlZWxFdmVudHNbcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XFxuICAgICAgICAgIGNvbnN0IGZpcnN0RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50c1swXTtcXG4gICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMucHVzaChuZXdFdmVudCk7XFxuICAgICAgICAgIGlmIChwcmV2RXZlbnQgJiYgKG5ld0V2ZW50LmRlbHRhID4gcHJldkV2ZW50LmRlbHRhIHx8IG5ld0V2ZW50LmRpcmVjdGlvbiAhPT0gcHJldkV2ZW50LmRpcmVjdGlvbikpIHtcXG4gICAgICAgICAgICAvLyBJbmNyZWFzaW5nIG9yIHJldmVyc2Utc2lnbiBkZWx0YSBtZWFucyB0aGUgdXNlciBzdGFydGVkIHNjcm9sbGluZyBhZ2Fpbi4gQ2xlYXIgdGhlIHdoZWVsIGV2ZW50IGxvZy5cXG4gICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zcGxpY2UoMCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID49IDE1XFxuICAgICAgICAgICAgICAmJiBuZXdFdmVudC50aW1lIC0gZmlyc3RFdmVudC50aW1lIDwgNTAwXFxuICAgICAgICAgICAgICAmJiBmaXJzdEV2ZW50LmRlbHRhIC0gbmV3RXZlbnQuZGVsdGEgPj0gMVxcbiAgICAgICAgICAgICAgJiYgbmV3RXZlbnQuZGVsdGEgPD0gNlxcbiAgICAgICAgICApIHtcXG4gICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWNlbGVyYXRpb24gb2YgYSBtb21lbnR1bSBzY3JvbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxcbiAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIG1vcmUgZXZlbnRzLiBTbmFwIEFTQVAgb24gdGhlIG5leHQgdGljay5cXG4gICAgICAgICAgICAvLyBBbHNvLCBiZWNhdXNlIHRoZXJlJ3Mgc29tZSByZW1haW5pbmcgbW9tZW50dW0gd2UnbGwgYmlhcyB0aGUgc25hcCBpbiB0aGVcXG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gb2YgdGhlIG9uZ29pbmcgc2Nyb2xsIGJlY2F1c2UgaXQncyBiZXR0ZXIgVVggZm9yIHRoZSBzY3JvbGwgdG8gc25hcFxcbiAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgc2Nyb2xsIGluc3RlYWQgb2YgcmV2ZXJzaW5nIHRvIHNuYXAuICBUaGVyZWZvcmUsXFxuICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IHNjcm9sbGVkIG1vcmUgdGhhbiAyMCUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBrZWVwIGdvaW5nLlxcbiAgICAgICAgICAgIGNvbnN0IHNuYXBUb1RocmVzaG9sZCA9IGRlbHRhID4gMCA/IDAuOCA6IDAuMjtcXG4gICAgICAgICAgICBzd2lwZXIubW91c2V3aGVlbC5sYXN0RXZlbnRCZWZvcmVTbmFwID0gbmV3RXZlbnQ7XFxuICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xcbiAgICAgICAgICAgIHN3aXBlci5tb3VzZXdoZWVsLnRpbWVvdXQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XFxuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xcbiAgICAgICAgICAgIH0sIDApOyAvLyBubyBkZWxheTsgbW92ZSBvbiBuZXh0IHRpY2tcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIXN3aXBlci5tb3VzZXdoZWVsLnRpbWVvdXQpIHtcXG4gICAgICAgICAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgdGhlbiB3ZSBoYXZlbid0IGRldGVjdGVkIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwsIHNvXFxuICAgICAgICAgICAgLy8gd2UnbGwgY29uc2lkZXIgYSBzY3JvbGwgXFxcImNvbXBsZXRlXFxcIiB3aGVuIHRoZXJlIGhhdmVuJ3QgYmVlbiBhbnkgd2hlZWwgZXZlbnRzXFxuICAgICAgICAgICAgLy8gZm9yIDUwMG1zLlxcbiAgICAgICAgICAgIHN3aXBlci5tb3VzZXdoZWVsLnRpbWVvdXQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XFxuICAgICAgICAgICAgICBjb25zdCBzbmFwVG9UaHJlc2hvbGQgPSAwLjU7XFxuICAgICAgICAgICAgICBzd2lwZXIubW91c2V3aGVlbC5sYXN0RXZlbnRCZWZvcmVTbmFwID0gbmV3RXZlbnQ7XFxuICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zcGxpY2UoMCk7XFxuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xcbiAgICAgICAgICAgIH0sIDUwMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEVtaXQgZXZlbnRcXG4gICAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIHN3aXBlci5lbWl0KCdzY3JvbGwnLCBlKTtcXG5cXG4gICAgICAgIC8vIFN0b3AgYXV0b3BsYXlcXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5ICYmIHN3aXBlci5wYXJhbXMuYXV0b3BsYXlEaXNhYmxlT25JbnRlcmFjdGlvbikgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcXG4gICAgICAgIC8vIFJldHVybiBwYWdlIHNjcm9sbCBvbiBlZGdlIHBvc2l0aW9uc1xcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBzd2lwZXIubWluVHJhbnNsYXRlKCkgfHwgcG9zaXRpb24gPT09IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGVsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcbiAgYW5pbWF0ZVNsaWRlcihuZXdFdmVudCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAvLyBJZiB0aGUgbW92ZW1lbnQgaXMgTk9UIGJpZyBlbm91Z2ggYW5kXFxuICAgIC8vIGlmIHRoZSBsYXN0IHRpbWUgdGhlIHVzZXIgc2Nyb2xsZWQgd2FzIHRvbyBjbG9zZSB0byB0aGUgY3VycmVudCBvbmUgKGF2b2lkIGNvbnRpbnVvdXNseSB0cmlnZ2VyaW5nIHRoZSBzbGlkZXIpOlxcbiAgICAvLyAgIERvbid0IGdvIGFueSBmdXJ0aGVyIChhdm9pZCBpbnNpZ25pZmljYW50IHNjcm9sbCBtb3ZlbWVudCkuXFxuICAgIGlmIChuZXdFdmVudC5kZWx0YSA+PSA2ICYmIFV0aWxzLm5vdygpIC0gc3dpcGVyLm1vdXNld2hlZWwubGFzdFNjcm9sbFRpbWUgPCA2MCkge1xcbiAgICAgIC8vIFJldHVybiBmYWxzZSBhcyBhIGRlZmF1bHRcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICAvLyBJZiB1c2VyIGlzIHNjcm9sbGluZyB0b3dhcmRzIHRoZSBlbmQ6XFxuICAgIC8vICAgSWYgdGhlIHNsaWRlciBoYXNuJ3QgaGl0IHRoZSBsYXRlc3Qgc2xpZGUgb3JcXG4gICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzIGEgbG9vcCBhbmRcXG4gICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzbid0IG1vdmluZyByaWdodCBub3c6XFxuICAgIC8vICAgICBHbyB0byBuZXh0IHNsaWRlIGFuZFxcbiAgICAvLyAgICAgZW1pdCBhIHNjcm9sbCBldmVudC5cXG4gICAgLy8gRWxzZSAodGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRvd2FyZHMgdGhlIGJlZ2lubmluZykgYW5kXFxuICAgIC8vIGlmIHRoZSBzbGlkZXIgaGFzbid0IGhpdCB0aGUgZmlyc3Qgc2xpZGUgb3JcXG4gICAgLy8gaWYgdGhlIHNsaWRlciBpcyBhIGxvb3AgYW5kXFxuICAgIC8vIGlmIHRoZSBzbGlkZXIgaXNuJ3QgbW92aW5nIHJpZ2h0IG5vdzpcXG4gICAgLy8gICBHbyB0byBwcmV2IHNsaWRlIGFuZFxcbiAgICAvLyAgIGVtaXQgYSBzY3JvbGwgZXZlbnQuXFxuICAgIGlmIChuZXdFdmVudC5kaXJlY3Rpb24gPCAwKSB7XFxuICAgICAgaWYgKCghc3dpcGVyLmlzRW5kIHx8IHN3aXBlci5wYXJhbXMubG9vcCkgJiYgIXN3aXBlci5hbmltYXRpbmcpIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZU5leHQoKTtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICgoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XFxuICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xcbiAgICAgIHN3aXBlci5lbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xcbiAgICB9XFxuICAgIC8vIElmIHlvdSBnb3QgaGVyZSBpcyBiZWNhdXNlIGFuIGFuaW1hdGlvbiBoYXMgYmVlbiB0cmlnZ2VyZWQgc28gc3RvcmUgdGhlIGN1cnJlbnQgdGltZVxcbiAgICBzd2lwZXIubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZSA9IChuZXcgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5EYXRlKCkpLmdldFRpbWUoKTtcXG4gICAgLy8gUmV0dXJuIGZhbHNlIGFzIGEgZGVmYXVsdFxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcbiAgcmVsZWFzZVNjcm9sbChuZXdFdmVudCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWw7XFxuICAgIGlmIChuZXdFdmVudC5kaXJlY3Rpb24gPCAwKSB7XFxuICAgICAgaWYgKHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIHBhcmFtcy5yZWxlYXNlT25FZGdlcykge1xcbiAgICAgICAgLy8gUmV0dXJuIHRydWUgdG8gYW5pbWF0ZSBzY3JvbGwgb24gZWRnZXNcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMubG9vcCAmJiBwYXJhbXMucmVsZWFzZU9uRWRnZXMpIHtcXG4gICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBhbmltYXRlIHNjcm9sbCBvbiBlZGdlc1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH0sXFxuICBlbmFibGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IGV2ZW50ID0gTW91c2V3aGVlbC5ldmVudCgpO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBzd2lwZXIubW91c2V3aGVlbC5oYW5kbGUpO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIGlmICghZXZlbnQpIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcXG4gICAgbGV0IHRhcmdldCA9IHN3aXBlci4kZWw7XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2VkICE9PSAnY29udGFpbmVyJykge1xcbiAgICAgIHRhcmdldCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdlZCk7XFxuICAgIH1cXG4gICAgdGFyZ2V0Lm9uKCdtb3VzZWVudGVyJywgc3dpcGVyLm1vdXNld2hlZWwuaGFuZGxlTW91c2VFbnRlcik7XFxuICAgIHRhcmdldC5vbignbW91c2VsZWF2ZScsIHN3aXBlci5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlTGVhdmUpO1xcbiAgICB0YXJnZXQub24oZXZlbnQsIHN3aXBlci5tb3VzZXdoZWVsLmhhbmRsZSk7XFxuICAgIHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQgPSB0cnVlO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0sXFxuICBkaXNhYmxlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBldmVudCA9IE1vdXNld2hlZWwuZXZlbnQoKTtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc3dpcGVyLm1vdXNld2hlZWwuaGFuZGxlKTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gZmFsc2U7XFxuICAgIGlmICghc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xcbiAgICBsZXQgdGFyZ2V0ID0gc3dpcGVyLiRlbDtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZWQgIT09ICdjb250YWluZXInKSB7XFxuICAgICAgdGFyZ2V0ID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2VkKTtcXG4gICAgfVxcbiAgICB0YXJnZXQub2ZmKGV2ZW50LCBzd2lwZXIubW91c2V3aGVlbC5oYW5kbGUpO1xcbiAgICBzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkID0gZmFsc2U7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSxcXG59O1xcblxcbnZhciBNb3VzZXdoZWVsJDEgPSB7XFxuICBuYW1lOiAnbW91c2V3aGVlbCcsXFxuICBwYXJhbXM6IHtcXG4gICAgbW91c2V3aGVlbDoge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcXG4gICAgICBpbnZlcnQ6IGZhbHNlLFxcbiAgICAgIGZvcmNlVG9BeGlzOiBmYWxzZSxcXG4gICAgICBzZW5zaXRpdml0eTogMSxcXG4gICAgICBldmVudHNUYXJnZWQ6ICdjb250YWluZXInLFxcbiAgICB9LFxcbiAgfSxcXG4gIGNyZWF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIG1vdXNld2hlZWw6IHtcXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgICAgZW5hYmxlOiBNb3VzZXdoZWVsLmVuYWJsZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBkaXNhYmxlOiBNb3VzZXdoZWVsLmRpc2FibGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgaGFuZGxlOiBNb3VzZXdoZWVsLmhhbmRsZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBoYW5kbGVNb3VzZUVudGVyOiBNb3VzZXdoZWVsLmhhbmRsZU1vdXNlRW50ZXIuYmluZChzd2lwZXIpLFxcbiAgICAgICAgaGFuZGxlTW91c2VMZWF2ZTogTW91c2V3aGVlbC5oYW5kbGVNb3VzZUxlYXZlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGFuaW1hdGVTbGlkZXI6IE1vdXNld2hlZWwuYW5pbWF0ZVNsaWRlci5iaW5kKHN3aXBlciksXFxuICAgICAgICByZWxlYXNlU2Nyb2xsOiBNb3VzZXdoZWVsLnJlbGVhc2VTY3JvbGwuYmluZChzd2lwZXIpLFxcbiAgICAgICAgbGFzdFNjcm9sbFRpbWU6IFV0aWxzLm5vdygpLFxcbiAgICAgICAgbGFzdEV2ZW50QmVmb3JlU25hcDogdW5kZWZpbmVkLFxcbiAgICAgICAgcmVjZW50V2hlZWxFdmVudHM6IFtdLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuZGlzYWJsZSgpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQpIHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZSgpO1xcbiAgICB9LFxcbiAgICBkZXN0cm95KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlKCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSBzd2lwZXIubW91c2V3aGVlbC5kaXNhYmxlKCk7XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuY29uc3QgTmF2aWdhdGlvbiA9IHtcXG4gIHVwZGF0ZSgpIHtcXG4gICAgLy8gVXBkYXRlIE5hdmlnYXRpb24gQnV0dG9uc1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcXG4gICAgY29uc3QgeyAkbmV4dEVsLCAkcHJldkVsIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcXG5cXG4gICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZykge1xcbiAgICAgICAgJHByZXZFbC5hZGRDbGFzcyhwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3MocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgICAkcHJldkVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XFxuICAgIH1cXG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgJG5leHRFbC5hZGRDbGFzcyhwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICRuZXh0RWwucmVtb3ZlQ2xhc3MocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgICAkbmV4dEVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XFxuICAgIH1cXG4gIH0sXFxuICBvblByZXZDbGljayhlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSByZXR1cm47XFxuICAgIHN3aXBlci5zbGlkZVByZXYoKTtcXG4gIH0sXFxuICBvbk5leHRDbGljayhlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgaWYgKHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSByZXR1cm47XFxuICAgIHN3aXBlci5zbGlkZU5leHQoKTtcXG4gIH0sXFxuICBpbml0KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XFxuICAgIGlmICghKHBhcmFtcy5uZXh0RWwgfHwgcGFyYW1zLnByZXZFbCkpIHJldHVybjtcXG5cXG4gICAgbGV0ICRuZXh0RWw7XFxuICAgIGxldCAkcHJldkVsO1xcbiAgICBpZiAocGFyYW1zLm5leHRFbCkge1xcbiAgICAgICRuZXh0RWwgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHBhcmFtcy5uZXh0RWwpO1xcbiAgICAgIGlmIChcXG4gICAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHNcXG4gICAgICAgICYmIHR5cGVvZiBwYXJhbXMubmV4dEVsID09PSAnc3RyaW5nJ1xcbiAgICAgICAgJiYgJG5leHRFbC5sZW5ndGggPiAxXFxuICAgICAgICAmJiBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLm5leHRFbCkubGVuZ3RoID09PSAxXFxuICAgICAgKSB7XFxuICAgICAgICAkbmV4dEVsID0gc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5uZXh0RWwpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocGFyYW1zLnByZXZFbCkge1xcbiAgICAgICRwcmV2RWwgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHBhcmFtcy5wcmV2RWwpO1xcbiAgICAgIGlmIChcXG4gICAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHNcXG4gICAgICAgICYmIHR5cGVvZiBwYXJhbXMucHJldkVsID09PSAnc3RyaW5nJ1xcbiAgICAgICAgJiYgJHByZXZFbC5sZW5ndGggPiAxXFxuICAgICAgICAmJiBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLnByZXZFbCkubGVuZ3RoID09PSAxXFxuICAgICAgKSB7XFxuICAgICAgICAkcHJldkVsID0gc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5wcmV2RWwpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCA+IDApIHtcXG4gICAgICAkbmV4dEVsLm9uKCdjbGljaycsIHN3aXBlci5uYXZpZ2F0aW9uLm9uTmV4dENsaWNrKTtcXG4gICAgfVxcbiAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCA+IDApIHtcXG4gICAgICAkcHJldkVsLm9uKCdjbGljaycsIHN3aXBlci5uYXZpZ2F0aW9uLm9uUHJldkNsaWNrKTtcXG4gICAgfVxcblxcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLm5hdmlnYXRpb24sIHtcXG4gICAgICAkbmV4dEVsLFxcbiAgICAgIG5leHRFbDogJG5leHRFbCAmJiAkbmV4dEVsWzBdLFxcbiAgICAgICRwcmV2RWwsXFxuICAgICAgcHJldkVsOiAkcHJldkVsICYmICRwcmV2RWxbMF0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIGRlc3Ryb3koKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHsgJG5leHRFbCwgJHByZXZFbCB9ID0gc3dpcGVyLm5hdmlnYXRpb247XFxuICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoKSB7XFxuICAgICAgJG5leHRFbC5vZmYoJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spO1xcbiAgICAgICRuZXh0RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xcbiAgICB9XFxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoKSB7XFxuICAgICAgJHByZXZFbC5vZmYoJ2NsaWNrJywgc3dpcGVyLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spO1xcbiAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xcbiAgICB9XFxuICB9LFxcbn07XFxuXFxudmFyIE5hdmlnYXRpb24kMSA9IHtcXG4gIG5hbWU6ICduYXZpZ2F0aW9uJyxcXG4gIHBhcmFtczoge1xcbiAgICBuYXZpZ2F0aW9uOiB7XFxuICAgICAgbmV4dEVsOiBudWxsLFxcbiAgICAgIHByZXZFbDogbnVsbCxcXG5cXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXFxuICAgICAgZGlzYWJsZWRDbGFzczogJ3N3aXBlci1idXR0b24tZGlzYWJsZWQnLFxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLWJ1dHRvbi1oaWRkZW4nLFxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaycsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgbmF2aWdhdGlvbjoge1xcbiAgICAgICAgaW5pdDogTmF2aWdhdGlvbi5pbml0LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHVwZGF0ZTogTmF2aWdhdGlvbi51cGRhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgZGVzdHJveTogTmF2aWdhdGlvbi5kZXN0cm95LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9uTmV4dENsaWNrOiBOYXZpZ2F0aW9uLm9uTmV4dENsaWNrLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9uUHJldkNsaWNrOiBOYXZpZ2F0aW9uLm9uUHJldkNsaWNrLmJpbmQoc3dpcGVyKSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgc3dpcGVyLm5hdmlnYXRpb24uaW5pdCgpO1xcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICB0b0VkZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgZnJvbUVkZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uLmRlc3Ryb3koKTtcXG4gICAgfSxcXG4gICAgY2xpY2soZSkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgY29uc3QgeyAkbmV4dEVsLCAkcHJldkVsIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcXG4gICAgICBpZiAoXFxuICAgICAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZU9uQ2xpY2tcXG4gICAgICAgICYmICFPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGUudGFyZ2V0KS5pcygkcHJldkVsKVxcbiAgICAgICAgJiYgIU9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoZS50YXJnZXQpLmlzKCRuZXh0RWwpXFxuICAgICAgKSB7XFxuICAgICAgICBsZXQgaXNIaWRkZW47XFxuICAgICAgICBpZiAoJG5leHRFbCkge1xcbiAgICAgICAgICBpc0hpZGRlbiA9ICRuZXh0RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbCkge1xcbiAgICAgICAgICBpc0hpZGRlbiA9ICRwcmV2RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnbmF2aWdhdGlvblNob3cnLCBzd2lwZXIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ25hdmlnYXRpb25IaWRlJywgc3dpcGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgkbmV4dEVsKSB7XFxuICAgICAgICAgICRuZXh0RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgkcHJldkVsKSB7XFxuICAgICAgICAgICRwcmV2RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuY29uc3QgUGFnaW5hdGlvbiA9IHtcXG4gIHVwZGF0ZSgpIHtcXG4gICAgLy8gUmVuZGVyIHx8IFVwZGF0ZSBQYWdpbmF0aW9uIGJ1bGxldHMvaXRlbXNcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgcnRsID0gc3dpcGVyLnJ0bDtcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xcbiAgICBpZiAoIXBhcmFtcy5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIGNvbnN0IHNsaWRlc0xlbmd0aCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xcbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XFxuICAgIC8vIEN1cnJlbnQvVG90YWxcXG4gICAgbGV0IGN1cnJlbnQ7XFxuICAgIGNvbnN0IHRvdGFsID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSAoc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgIGN1cnJlbnQgPSBNYXRoLmNlaWwoKHN3aXBlci5hY3RpdmVJbmRleCAtIHN3aXBlci5sb29wZWRTbGlkZXMpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XFxuICAgICAgaWYgKGN1cnJlbnQgPiBzbGlkZXNMZW5ndGggLSAxIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSkge1xcbiAgICAgICAgY3VycmVudCAtPSAoc2xpZGVzTGVuZ3RoIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChjdXJyZW50ID4gdG90YWwgLSAxKSBjdXJyZW50IC09IHRvdGFsO1xcbiAgICAgIGlmIChjdXJyZW50IDwgMCAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb25UeXBlICE9PSAnYnVsbGV0cycpIGN1cnJlbnQgPSB0b3RhbCArIGN1cnJlbnQ7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN3aXBlci5zbmFwSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgY3VycmVudCA9IHN3aXBlci5zbmFwSW5kZXg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3VycmVudCA9IHN3aXBlci5hY3RpdmVJbmRleCB8fCAwO1xcbiAgICB9XFxuICAgIC8vIFR5cGVzXFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgY29uc3QgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XFxuICAgICAgbGV0IGZpcnN0SW5kZXg7XFxuICAgICAgbGV0IGxhc3RJbmRleDtcXG4gICAgICBsZXQgbWlkSW5kZXg7XFxuICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSA9IGJ1bGxldHMuZXEoMClbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ291dGVyV2lkdGgnIDogJ291dGVySGVpZ2h0J10odHJ1ZSk7XFxuICAgICAgICAkZWwuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0JywgYCR7c3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSAqIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzICsgNCl9cHhgKTtcXG4gICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzID4gMSAmJiBzd2lwZXIucHJldmlvdXNJbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCArPSAoY3VycmVudCAtIHN3aXBlci5wcmV2aW91c0luZGV4KTtcXG4gICAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA+IChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMSkpIHtcXG4gICAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPSBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggPCAwKSB7XFxuICAgICAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmlyc3RJbmRleCA9IGN1cnJlbnQgLSBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXg7XFxuICAgICAgICBsYXN0SW5kZXggPSBmaXJzdEluZGV4ICsgKE1hdGgubWluKGJ1bGxldHMubGVuZ3RoLCBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSAtIDEpO1xcbiAgICAgICAgbWlkSW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgLyAyO1xcbiAgICAgIH1cXG4gICAgICBidWxsZXRzLnJlbW92ZUNsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30gJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dCAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldiAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldi1wcmV2ICR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1tYWluYCk7XFxuICAgICAgaWYgKCRlbC5sZW5ndGggPiAxKSB7XFxuICAgICAgICBidWxsZXRzLmVhY2goKGluZGV4LCBidWxsZXQpID0+IHtcXG4gICAgICAgICAgY29uc3QgJGJ1bGxldCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYnVsbGV0KTtcXG4gICAgICAgICAgY29uc3QgYnVsbGV0SW5kZXggPSAkYnVsbGV0LmluZGV4KCk7XFxuICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xcbiAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XFxuICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID49IGZpcnN0SW5kZXggJiYgYnVsbGV0SW5kZXggPD0gbGFzdEluZGV4KSB7XFxuICAgICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGZpcnN0SW5kZXgpIHtcXG4gICAgICAgICAgICAgICRidWxsZXRcXG4gICAgICAgICAgICAgICAgLnByZXYoKVxcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2YClcXG4gICAgICAgICAgICAgICAgLnByZXYoKVxcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2LXByZXZgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID09PSBsYXN0SW5kZXgpIHtcXG4gICAgICAgICAgICAgICRidWxsZXRcXG4gICAgICAgICAgICAgICAgLm5leHQoKVxcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1uZXh0YClcXG4gICAgICAgICAgICAgICAgLm5leHQoKVxcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1uZXh0LW5leHRgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zdCAkYnVsbGV0ID0gYnVsbGV0cy5lcShjdXJyZW50KTtcXG4gICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xcbiAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xcbiAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgICBjb25zdCAkZmlyc3REaXNwbGF5ZWRCdWxsZXQgPSBidWxsZXRzLmVxKGZpcnN0SW5kZXgpO1xcbiAgICAgICAgICBjb25zdCAkbGFzdERpc3BsYXllZEJ1bGxldCA9IGJ1bGxldHMuZXEobGFzdEluZGV4KTtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW5kZXg7IGkgPD0gbGFzdEluZGV4OyBpICs9IDEpIHtcXG4gICAgICAgICAgICBidWxsZXRzLmVxKGkpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gYnVsbGV0cy5sZW5ndGggLSBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSB7XFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0czsgaSA+PSAwOyBpIC09IDEpIHtcXG4gICAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIGkpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgJGZpcnN0RGlzcGxheWVkQnVsbGV0XFxuICAgICAgICAgICAgICAgIC5wcmV2KClcXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldmApXFxuICAgICAgICAgICAgICAgIC5wcmV2KClcXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldi1wcmV2YCk7XFxuICAgICAgICAgICAgICAkbGFzdERpc3BsYXllZEJ1bGxldFxcbiAgICAgICAgICAgICAgICAubmV4dCgpXFxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHRgKVxcbiAgICAgICAgICAgICAgICAubmV4dCgpXFxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dGApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAkZmlyc3REaXNwbGF5ZWRCdWxsZXRcXG4gICAgICAgICAgICAgIC5wcmV2KClcXG4gICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKVxcbiAgICAgICAgICAgICAgLnByZXYoKVxcbiAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldi1wcmV2YCk7XFxuICAgICAgICAgICAgJGxhc3REaXNwbGF5ZWRCdWxsZXRcXG4gICAgICAgICAgICAgIC5uZXh0KClcXG4gICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHRgKVxcbiAgICAgICAgICAgICAgLm5leHQoKVxcbiAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dC1uZXh0YCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICAgY29uc3QgZHluYW1pY0J1bGxldHNMZW5ndGggPSBNYXRoLm1pbihidWxsZXRzLmxlbmd0aCwgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpO1xcbiAgICAgICAgY29uc3QgYnVsbGV0c09mZnNldCA9ICgoKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgKiBkeW5hbWljQnVsbGV0c0xlbmd0aCkgLSAoc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSkpIC8gMikgLSAobWlkSW5kZXggKiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRTaXplKTtcXG4gICAgICAgIGNvbnN0IG9mZnNldFByb3AgPSBydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xcbiAgICAgICAgYnVsbGV0cy5jc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gb2Zmc2V0UHJvcCA6ICd0b3AnLCBgJHtidWxsZXRzT2Zmc2V0fXB4YCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xcbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMuY3VycmVudENsYXNzfWApLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uQ3VycmVudChjdXJyZW50ICsgMSkpO1xcbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMudG90YWxDbGFzc31gKS50ZXh0KHBhcmFtcy5mb3JtYXRGcmFjdGlvblRvdGFsKHRvdGFsKSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XFxuICAgICAgbGV0IHByb2dyZXNzYmFyRGlyZWN0aW9uO1xcbiAgICAgIGlmIChwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZSkge1xcbiAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwcm9ncmVzc2JhckRpcmVjdGlvbiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHNjYWxlID0gKGN1cnJlbnQgKyAxKSAvIHRvdGFsO1xcbiAgICAgIGxldCBzY2FsZVggPSAxO1xcbiAgICAgIGxldCBzY2FsZVkgPSAxO1xcbiAgICAgIGlmIChwcm9ncmVzc2JhckRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XFxuICAgICAgICBzY2FsZVggPSBzY2FsZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2NhbGVZID0gc2NhbGU7XFxuICAgICAgfVxcbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3N9YCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGVYKCR7c2NhbGVYfSkgc2NhbGVZKCR7c2NhbGVZfSlgKS50cmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpO1xcbiAgICB9XFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2N1c3RvbScgJiYgcGFyYW1zLnJlbmRlckN1c3RvbSkge1xcbiAgICAgICRlbC5odG1sKHBhcmFtcy5yZW5kZXJDdXN0b20oc3dpcGVyLCBjdXJyZW50ICsgMSwgdG90YWwpKTtcXG4gICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblJlbmRlcicsIHN3aXBlciwgJGVsWzBdKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblVwZGF0ZScsIHN3aXBlciwgJGVsWzBdKTtcXG4gICAgfVxcbiAgICAkZWxbc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcXG4gIH0sXFxuICByZW5kZXIoKSB7XFxuICAgIC8vIFJlbmRlciBDb250YWluZXJcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xcbiAgICBpZiAoIXBhcmFtcy5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIGNvbnN0IHNsaWRlc0xlbmd0aCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xcblxcbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XFxuICAgIGxldCBwYWdpbmF0aW9uSFRNTCA9ICcnO1xcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJykge1xcbiAgICAgIGNvbnN0IG51bWJlck9mQnVsbGV0cyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoc2xpZGVzTGVuZ3RoIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkJ1bGxldHM7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHBhcmFtcy5yZW5kZXJCdWxsZXQpIHtcXG4gICAgICAgICAgcGFnaW5hdGlvbkhUTUwgKz0gcGFyYW1zLnJlbmRlckJ1bGxldC5jYWxsKHN3aXBlciwgaSwgcGFyYW1zLmJ1bGxldENsYXNzKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IGA8JHtwYXJhbXMuYnVsbGV0RWxlbWVudH0gY2xhc3M9XFxcIiR7cGFyYW1zLmJ1bGxldENsYXNzfVxcXCI+PC8ke3BhcmFtcy5idWxsZXRFbGVtZW50fT5gO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyA9ICRlbC5maW5kKGAuJHtwYXJhbXMuYnVsbGV0Q2xhc3N9YCk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnZnJhY3Rpb24nKSB7XFxuICAgICAgaWYgKHBhcmFtcy5yZW5kZXJGcmFjdGlvbikge1xcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBwYXJhbXMucmVuZGVyRnJhY3Rpb24uY2FsbChzd2lwZXIsIHBhcmFtcy5jdXJyZW50Q2xhc3MsIHBhcmFtcy50b3RhbENsYXNzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XFxcIiR7cGFyYW1zLmN1cnJlbnRDbGFzc31cXFwiPjwvc3Bhbj5gXFxuICAgICAgICArICcgLyAnXFxuICAgICAgICArIGA8c3BhbiBjbGFzcz1cXFwiJHtwYXJhbXMudG90YWxDbGFzc31cXFwiPjwvc3Bhbj5gO1xcbiAgICAgIH1cXG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XFxuICAgICAgaWYgKHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhcikge1xcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBwYXJhbXMucmVuZGVyUHJvZ3Jlc3NiYXIuY2FsbChzd2lwZXIsIHBhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gYDxzcGFuIGNsYXNzPVxcXCIke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31cXFwiPjwvc3Bhbj5gO1xcbiAgICAgIH1cXG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnY3VzdG9tJykge1xcbiAgICAgIHN3aXBlci5lbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgc3dpcGVyLnBhZ2luYXRpb24uJGVsWzBdKTtcXG4gICAgfVxcbiAgfSxcXG4gIGluaXQoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcXG4gICAgaWYgKCFwYXJhbXMuZWwpIHJldHVybjtcXG5cXG4gICAgbGV0ICRlbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkocGFyYW1zLmVsKTtcXG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybjtcXG5cXG4gICAgaWYgKFxcbiAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHNcXG4gICAgICAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJ1xcbiAgICAgICYmICRlbC5sZW5ndGggPiAxXFxuICAgICkge1xcbiAgICAgICRlbCA9IHN3aXBlci4kZWwuZmluZChwYXJhbXMuZWwpO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5jbGlja2FibGUpIHtcXG4gICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLmNsaWNrYWJsZUNsYXNzKTtcXG4gICAgfVxcblxcbiAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XFxuXFxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xcbiAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMDtcXG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA8IDEpIHtcXG4gICAgICAgIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPSAxO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicgJiYgcGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcXG4gICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcXG4gICAgICAkZWwub24oJ2NsaWNrJywgYC4ke3BhcmFtcy5idWxsZXRDbGFzc31gLCBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIGxldCBpbmRleCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkodGhpcykuaW5kZXgoKSAqIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XFxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSBpbmRleCArPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oaW5kZXgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFnaW5hdGlvbiwge1xcbiAgICAgICRlbCxcXG4gICAgICBlbDogJGVsWzBdLFxcbiAgICB9KTtcXG4gIH0sXFxuICBkZXN0cm95KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XFxuICAgIGlmICghcGFyYW1zLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uJGVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPT09IDApIHJldHVybjtcXG4gICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xcblxcbiAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLmhpZGRlbkNsYXNzKTtcXG4gICAgJGVsLnJlbW92ZUNsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgcGFyYW1zLnR5cGUpO1xcbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cykgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xcbiAgICBpZiAocGFyYW1zLmNsaWNrYWJsZSkge1xcbiAgICAgICRlbC5vZmYoJ2NsaWNrJywgYC4ke3BhcmFtcy5idWxsZXRDbGFzc31gKTtcXG4gICAgfVxcbiAgfSxcXG59O1xcblxcbnZhciBQYWdpbmF0aW9uJDEgPSB7XFxuICBuYW1lOiAncGFnaW5hdGlvbicsXFxuICBwYXJhbXM6IHtcXG4gICAgcGFnaW5hdGlvbjoge1xcbiAgICAgIGVsOiBudWxsLFxcbiAgICAgIGJ1bGxldEVsZW1lbnQ6ICdzcGFuJyxcXG4gICAgICBjbGlja2FibGU6IGZhbHNlLFxcbiAgICAgIGhpZGVPbkNsaWNrOiBmYWxzZSxcXG4gICAgICByZW5kZXJCdWxsZXQ6IG51bGwsXFxuICAgICAgcmVuZGVyUHJvZ3Jlc3NiYXI6IG51bGwsXFxuICAgICAgcmVuZGVyRnJhY3Rpb246IG51bGwsXFxuICAgICAgcmVuZGVyQ3VzdG9tOiBudWxsLFxcbiAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGU6IGZhbHNlLFxcbiAgICAgIHR5cGU6ICdidWxsZXRzJywgLy8gJ2J1bGxldHMnIG9yICdwcm9ncmVzc2Jhcicgb3IgJ2ZyYWN0aW9uJyBvciAnY3VzdG9tJ1xcbiAgICAgIGR5bmFtaWNCdWxsZXRzOiBmYWxzZSxcXG4gICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXFxuICAgICAgZm9ybWF0RnJhY3Rpb25DdXJyZW50OiAobnVtYmVyKSA9PiBudW1iZXIsXFxuICAgICAgZm9ybWF0RnJhY3Rpb25Ub3RhbDogKG51bWJlcikgPT4gbnVtYmVyLFxcbiAgICAgIGJ1bGxldENsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0JyxcXG4gICAgICBidWxsZXRBY3RpdmVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1hY3RpdmUnLFxcbiAgICAgIG1vZGlmaWVyQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi0nLCAvLyBORVdcXG4gICAgICBjdXJyZW50Q2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1jdXJyZW50JyxcXG4gICAgICB0b3RhbENsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tdG90YWwnLFxcbiAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24taGlkZGVuJyxcXG4gICAgICBwcm9ncmVzc2JhckZpbGxDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGwnLFxcbiAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLW9wcG9zaXRlJyxcXG4gICAgICBjbGlja2FibGVDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWNsaWNrYWJsZScsIC8vIE5FV1xcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWxvY2snLFxcbiAgICB9LFxcbiAgfSxcXG4gIGNyZWF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIHBhZ2luYXRpb246IHtcXG4gICAgICAgIGluaXQ6IFBhZ2luYXRpb24uaW5pdC5iaW5kKHN3aXBlciksXFxuICAgICAgICByZW5kZXI6IFBhZ2luYXRpb24ucmVuZGVyLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHVwZGF0ZTogUGFnaW5hdGlvbi51cGRhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgZGVzdHJveTogUGFnaW5hdGlvbi5kZXN0cm95LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleDogMCxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uaW5pdCgpO1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnJlbmRlcigpO1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICBhY3RpdmVJbmRleENoYW5nZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN3aXBlci5zbmFwSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNuYXBJbmRleENoYW5nZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNsaWRlc0xlbmd0aENoYW5nZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnJlbmRlcigpO1xcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24udXBkYXRlKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzbmFwR3JpZExlbmd0aENoYW5nZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5yZW5kZXIoKTtcXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmRlc3Ryb3koKTtcXG4gICAgfSxcXG4gICAgY2xpY2soZSkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKFxcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVsXFxuICAgICAgICAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2tcXG4gICAgICAgICYmIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPiAwXFxuICAgICAgICAmJiAhT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShlLnRhcmdldCkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKVxcbiAgICAgICkge1xcbiAgICAgICAgY29uc3QgaXNIaWRkZW4gPSBzd2lwZXIucGFnaW5hdGlvbi4kZWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcXG4gICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBzd2lwZXIuZW1pdCgncGFnaW5hdGlvblNob3cnLCBzd2lwZXIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3BhZ2luYXRpb25IaWRlJywgc3dpcGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBTY3JvbGxiYXIgPSB7XFxuICBzZXRUcmFuc2xhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcXG4gICAgY29uc3QgeyBzY3JvbGxiYXIsIHJ0bFRyYW5zbGF0ZTogcnRsLCBwcm9ncmVzcyB9ID0gc3dpcGVyO1xcbiAgICBjb25zdCB7XFxuICAgICAgZHJhZ1NpemUsIHRyYWNrU2l6ZSwgJGRyYWdFbCwgJGVsLFxcbiAgICB9ID0gc2Nyb2xsYmFyO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcXG5cXG4gICAgbGV0IG5ld1NpemUgPSBkcmFnU2l6ZTtcXG4gICAgbGV0IG5ld1BvcyA9ICh0cmFja1NpemUgLSBkcmFnU2l6ZSkgKiBwcm9ncmVzcztcXG4gICAgaWYgKHJ0bCkge1xcbiAgICAgIG5ld1BvcyA9IC1uZXdQb3M7XFxuICAgICAgaWYgKG5ld1BvcyA+IDApIHtcXG4gICAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSAtIG5ld1BvcztcXG4gICAgICAgIG5ld1BvcyA9IDA7XFxuICAgICAgfSBlbHNlIGlmICgtbmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcXG4gICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgKyBuZXdQb3M7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IDApIHtcXG4gICAgICBuZXdTaXplID0gZHJhZ1NpemUgKyBuZXdQb3M7XFxuICAgICAgbmV3UG9zID0gMDtcXG4gICAgfSBlbHNlIGlmIChuZXdQb3MgKyBkcmFnU2l6ZSA+IHRyYWNrU2l6ZSkge1xcbiAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgLSBuZXdQb3M7XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xcbiAgICAgICRkcmFnRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke25ld1Bvc31weCwgMCwgMClgKTtcXG4gICAgICAkZHJhZ0VsWzBdLnN0eWxlLndpZHRoID0gYCR7bmV3U2l6ZX1weGA7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHtuZXdQb3N9cHgsIDApYCk7XFxuICAgICAgJGRyYWdFbFswXS5zdHlsZS5oZWlnaHQgPSBgJHtuZXdTaXplfXB4YDtcXG4gICAgfVxcbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcXG4gICAgICBjbGVhclRpbWVvdXQoc3dpcGVyLnNjcm9sbGJhci50aW1lb3V0KTtcXG4gICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDE7XFxuICAgICAgc3dpcGVyLnNjcm9sbGJhci50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XFxuICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xcbiAgICAgIH0sIDEwMDApO1xcbiAgICB9XFxuICB9LFxcbiAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XFxuICAgIHN3aXBlci5zY3JvbGxiYXIuJGRyYWdFbC50cmFuc2l0aW9uKGR1cmF0aW9uKTtcXG4gIH0sXFxuICB1cGRhdGVTaXplKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XFxuXFxuICAgIGNvbnN0IHsgc2Nyb2xsYmFyIH0gPSBzd2lwZXI7XFxuICAgIGNvbnN0IHsgJGRyYWdFbCwgJGVsIH0gPSBzY3JvbGxiYXI7XFxuXFxuICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSAnJztcXG4gICAgJGRyYWdFbFswXS5zdHlsZS5oZWlnaHQgPSAnJztcXG4gICAgY29uc3QgdHJhY2tTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJGVsWzBdLm9mZnNldFdpZHRoIDogJGVsWzBdLm9mZnNldEhlaWdodDtcXG5cXG4gICAgY29uc3QgZGl2aWRlciA9IHN3aXBlci5zaXplIC8gc3dpcGVyLnZpcnR1YWxTaXplO1xcbiAgICBjb25zdCBtb3ZlRGl2aWRlciA9IGRpdmlkZXIgKiAodHJhY2tTaXplIC8gc3dpcGVyLnNpemUpO1xcbiAgICBsZXQgZHJhZ1NpemU7XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSA9PT0gJ2F1dG8nKSB7XFxuICAgICAgZHJhZ1NpemUgPSB0cmFja1NpemUgKiBkaXZpZGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRyYWdTaXplID0gcGFyc2VJbnQoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUsIDEwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgJGRyYWdFbFswXS5zdHlsZS53aWR0aCA9IGAke2RyYWdTaXplfXB4YDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke2RyYWdTaXplfXB4YDtcXG4gICAgfVxcblxcbiAgICBpZiAoZGl2aWRlciA+PSAxKSB7XFxuICAgICAgJGVsWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJGVsWzBdLnN0eWxlLmRpc3BsYXkgPSAnJztcXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuaGlkZSkge1xcbiAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gMDtcXG4gICAgfVxcbiAgICBVdGlscy5leHRlbmQoc2Nyb2xsYmFyLCB7XFxuICAgICAgdHJhY2tTaXplLFxcbiAgICAgIGRpdmlkZXIsXFxuICAgICAgbW92ZURpdmlkZXIsXFxuICAgICAgZHJhZ1NpemUsXFxuICAgIH0pO1xcbiAgICBzY3JvbGxiYXIuJGVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcXG4gIH0sXFxuICBnZXRQb2ludGVyUG9zaXRpb24oZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgcmV0dXJuICgoZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WCk7XFxuICAgIH1cXG4gICAgcmV0dXJuICgoZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSA6IGUuY2xpZW50WSk7XFxuICB9LFxcbiAgc2V0RHJhZ1Bvc2l0aW9uKGUpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyBzY3JvbGxiYXIsIHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XFxuICAgIGNvbnN0IHtcXG4gICAgICAkZWwsXFxuICAgICAgZHJhZ1NpemUsXFxuICAgICAgdHJhY2tTaXplLFxcbiAgICAgIGRyYWdTdGFydFBvcyxcXG4gICAgfSA9IHNjcm9sbGJhcjtcXG5cXG4gICAgbGV0IHBvc2l0aW9uUmF0aW87XFxuICAgIHBvc2l0aW9uUmF0aW8gPSAoKHNjcm9sbGJhci5nZXRQb2ludGVyUG9zaXRpb24oZSkpIC0gJGVsLm9mZnNldCgpW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnXVxcbiAgICAgIC0gKGRyYWdTdGFydFBvcyAhPT0gbnVsbCA/IGRyYWdTdGFydFBvcyA6IGRyYWdTaXplIC8gMikpIC8gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKTtcXG4gICAgcG9zaXRpb25SYXRpbyA9IE1hdGgubWF4KE1hdGgubWluKHBvc2l0aW9uUmF0aW8sIDEpLCAwKTtcXG4gICAgaWYgKHJ0bCkge1xcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxIC0gcG9zaXRpb25SYXRpbztcXG4gICAgfVxcblxcbiAgICBjb25zdCBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSArICgoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAqIHBvc2l0aW9uUmF0aW8pO1xcblxcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pO1xcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcXG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XFxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XFxuICB9LFxcbiAgb25EcmFnU3RhcnQoZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcXG4gICAgY29uc3QgeyBzY3JvbGxiYXIsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgeyAkZWwsICRkcmFnRWwgfSA9IHNjcm9sbGJhcjtcXG4gICAgc3dpcGVyLnNjcm9sbGJhci5pc1RvdWNoZWQgPSB0cnVlO1xcbiAgICBzd2lwZXIuc2Nyb2xsYmFyLmRyYWdTdGFydFBvcyA9IChlLnRhcmdldCA9PT0gJGRyYWdFbFswXSB8fCBlLnRhcmdldCA9PT0gJGRyYWdFbClcXG4gICAgICA/IHNjcm9sbGJhci5nZXRQb2ludGVyUG9zaXRpb24oZSkgLSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJ10gOiBudWxsO1xcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFxuICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbigxMDApO1xcbiAgICAkZHJhZ0VsLnRyYW5zaXRpb24oMTAwKTtcXG4gICAgc2Nyb2xsYmFyLnNldERyYWdQb3NpdGlvbihlKTtcXG5cXG4gICAgY2xlYXJUaW1lb3V0KHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQpO1xcblxcbiAgICAkZWwudHJhbnNpdGlvbigwKTtcXG4gICAgaWYgKHBhcmFtcy5oaWRlKSB7XFxuICAgICAgJGVsLmNzcygnb3BhY2l0eScsIDEpO1xcbiAgICB9XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ3Njcm9sbC1zbmFwLXR5cGUnLCAnbm9uZScpO1xcbiAgICB9XFxuICAgIHN3aXBlci5lbWl0KCdzY3JvbGxiYXJEcmFnU3RhcnQnLCBlKTtcXG4gIH0sXFxuICBvbkRyYWdNb3ZlKGUpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyBzY3JvbGxiYXIsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgeyAkZWwsICRkcmFnRWwgfSA9IHNjcm9sbGJhcjtcXG5cXG4gICAgaWYgKCFzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCkgcmV0dXJuO1xcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBlbHNlIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcXG4gICAgc2Nyb2xsYmFyLnNldERyYWdQb3NpdGlvbihlKTtcXG4gICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDApO1xcbiAgICAkZWwudHJhbnNpdGlvbigwKTtcXG4gICAgJGRyYWdFbC50cmFuc2l0aW9uKDApO1xcbiAgICBzd2lwZXIuZW1pdCgnc2Nyb2xsYmFyRHJhZ01vdmUnLCBlKTtcXG4gIH0sXFxuICBvbkRyYWdFbmQoZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcXG4gICAgY29uc3QgeyBzY3JvbGxiYXIsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgeyAkZWwgfSA9IHNjcm9sbGJhcjtcXG5cXG4gICAgaWYgKCFzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCkgcmV0dXJuO1xcbiAgICBzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCA9IGZhbHNlO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuY3NzKCdzY3JvbGwtc25hcC10eXBlJywgJycpO1xcbiAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbignJyk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy5oaWRlKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQpO1xcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XFxuICAgICAgICAkZWwuY3NzKCdvcGFjaXR5JywgMCk7XFxuICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xcbiAgICAgIH0sIDEwMDApO1xcbiAgICB9XFxuICAgIHN3aXBlci5lbWl0KCdzY3JvbGxiYXJEcmFnRW5kJywgZSk7XFxuICAgIGlmIChwYXJhbXMuc25hcE9uUmVsZWFzZSkge1xcbiAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xcbiAgICB9XFxuICB9LFxcbiAgZW5hYmxlRHJhZ2dhYmxlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XFxuICAgIGNvbnN0IHtcXG4gICAgICBzY3JvbGxiYXIsIHRvdWNoRXZlbnRzVG91Y2gsIHRvdWNoRXZlbnRzRGVza3RvcCwgcGFyYW1zLFxcbiAgICB9ID0gc3dpcGVyO1xcbiAgICBjb25zdCAkZWwgPSBzY3JvbGxiYXIuJGVsO1xcbiAgICBjb25zdCB0YXJnZXQgPSAkZWxbMF07XFxuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIGlmICghU3VwcG9ydC50b3VjaCkge1xcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcXG4gICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0uYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3AuZW5kLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLnN0YXJ0LCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XFxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNUb3VjaC5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLmVuZCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgIH1cXG4gIH0sXFxuICBkaXNhYmxlRHJhZ2dhYmxlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XFxuICAgIGNvbnN0IHtcXG4gICAgICBzY3JvbGxiYXIsIHRvdWNoRXZlbnRzVG91Y2gsIHRvdWNoRXZlbnRzRGVza3RvcCwgcGFyYW1zLFxcbiAgICB9ID0gc3dpcGVyO1xcbiAgICBjb25zdCAkZWwgPSBzY3JvbGxiYXIuJGVsO1xcbiAgICBjb25zdCB0YXJnZXQgPSAkZWxbMF07XFxuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIGlmICghU3VwcG9ydC50b3VjaCkge1xcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZG9jdW1lbnRcXFwiXS5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcXG4gICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3AuZW5kLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLnN0YXJ0LCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XFxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNUb3VjaC5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c1RvdWNoLmVuZCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgIH1cXG4gIH0sXFxuICBpbml0KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XFxuICAgIGNvbnN0IHsgc2Nyb2xsYmFyLCAkZWw6ICRzd2lwZXJFbCB9ID0gc3dpcGVyO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcXG5cXG4gICAgbGV0ICRlbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkocGFyYW1zLmVsKTtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgJGVsLmxlbmd0aCA+IDEgJiYgJHN3aXBlckVsLmZpbmQocGFyYW1zLmVsKS5sZW5ndGggPT09IDEpIHtcXG4gICAgICAkZWwgPSAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpO1xcbiAgICB9XFxuXFxuICAgIGxldCAkZHJhZ0VsID0gJGVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzc31gKTtcXG4gICAgaWYgKCRkcmFnRWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgJGRyYWdFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYDxkaXYgY2xhc3M9XFxcIiR7c3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfVxcXCI+PC9kaXY+YCk7XFxuICAgICAgJGVsLmFwcGVuZCgkZHJhZ0VsKTtcXG4gICAgfVxcblxcbiAgICBVdGlscy5leHRlbmQoc2Nyb2xsYmFyLCB7XFxuICAgICAgJGVsLFxcbiAgICAgIGVsOiAkZWxbMF0sXFxuICAgICAgJGRyYWdFbCxcXG4gICAgICBkcmFnRWw6ICRkcmFnRWxbMF0sXFxuICAgIH0pO1xcblxcbiAgICBpZiAocGFyYW1zLmRyYWdnYWJsZSkge1xcbiAgICAgIHNjcm9sbGJhci5lbmFibGVEcmFnZ2FibGUoKTtcXG4gICAgfVxcbiAgfSxcXG4gIGRlc3Ryb3koKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5zY3JvbGxiYXIuZGlzYWJsZURyYWdnYWJsZSgpO1xcbiAgfSxcXG59O1xcblxcbnZhciBTY3JvbGxiYXIkMSA9IHtcXG4gIG5hbWU6ICdzY3JvbGxiYXInLFxcbiAgcGFyYW1zOiB7XFxuICAgIHNjcm9sbGJhcjoge1xcbiAgICAgIGVsOiBudWxsLFxcbiAgICAgIGRyYWdTaXplOiAnYXV0bycsXFxuICAgICAgaGlkZTogZmFsc2UsXFxuICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcXG4gICAgICBzbmFwT25SZWxlYXNlOiB0cnVlLFxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1zY3JvbGxiYXItbG9jaycsXFxuICAgICAgZHJhZ0NsYXNzOiAnc3dpcGVyLXNjcm9sbGJhci1kcmFnJyxcXG4gICAgfSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBzY3JvbGxiYXI6IHtcXG4gICAgICAgIGluaXQ6IFNjcm9sbGJhci5pbml0LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGRlc3Ryb3k6IFNjcm9sbGJhci5kZXN0cm95LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHVwZGF0ZVNpemU6IFNjcm9sbGJhci51cGRhdGVTaXplLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHNldFRyYW5zbGF0ZTogU2Nyb2xsYmFyLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBTY3JvbGxiYXIuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXFxuICAgICAgICBlbmFibGVEcmFnZ2FibGU6IFNjcm9sbGJhci5lbmFibGVEcmFnZ2FibGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgZGlzYWJsZURyYWdnYWJsZTogU2Nyb2xsYmFyLmRpc2FibGVEcmFnZ2FibGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgc2V0RHJhZ1Bvc2l0aW9uOiBTY3JvbGxiYXIuc2V0RHJhZ1Bvc2l0aW9uLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGdldFBvaW50ZXJQb3NpdGlvbjogU2Nyb2xsYmFyLmdldFBvaW50ZXJQb3NpdGlvbi5iaW5kKHN3aXBlciksXFxuICAgICAgICBvbkRyYWdTdGFydDogU2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9uRHJhZ01vdmU6IFNjcm9sbGJhci5vbkRyYWdNb3ZlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9uRHJhZ0VuZDogU2Nyb2xsYmFyLm9uRHJhZ0VuZC5iaW5kKHN3aXBlciksXFxuICAgICAgICBpc1RvdWNoZWQ6IGZhbHNlLFxcbiAgICAgICAgdGltZW91dDogbnVsbCxcXG4gICAgICAgIGRyYWdUaW1lb3V0OiBudWxsLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLmluaXQoKTtcXG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKTtcXG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xcbiAgICB9LFxcbiAgICB1cGRhdGUoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKTtcXG4gICAgfSxcXG4gICAgcmVzaXplKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XFxuICAgIH0sXFxuICAgIG9ic2VydmVyVXBkYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuc2V0VHJhbnNsYXRlKCk7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICAgIH0sXFxuICAgIGRlc3Ryb3koKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLmRlc3Ryb3koKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBQYXJhbGxheCA9IHtcXG4gIHNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyBydGwgfSA9IHN3aXBlcjtcXG5cXG4gICAgY29uc3QgJGVsID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShlbCk7XFxuICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcXG5cXG4gICAgY29uc3QgcCA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheCcpIHx8ICcwJztcXG4gICAgbGV0IHggPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xcbiAgICBsZXQgeSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XFxuICAgIGNvbnN0IHNjYWxlID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJyk7XFxuICAgIGNvbnN0IG9wYWNpdHkgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xcblxcbiAgICBpZiAoeCB8fCB5KSB7XFxuICAgICAgeCA9IHggfHwgJzAnO1xcbiAgICAgIHkgPSB5IHx8ICcwJztcXG4gICAgfSBlbHNlIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgICB4ID0gcDtcXG4gICAgICB5ID0gJzAnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHkgPSBwO1xcbiAgICAgIHggPSAnMCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKCh4KS5pbmRleE9mKCclJykgPj0gMCkge1xcbiAgICAgIHggPSBgJHtwYXJzZUludCh4LCAxMCkgKiBwcm9ncmVzcyAqIHJ0bEZhY3Rvcn0lYDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB4ID0gYCR7eCAqIHByb2dyZXNzICogcnRsRmFjdG9yfXB4YDtcXG4gICAgfVxcbiAgICBpZiAoKHkpLmluZGV4T2YoJyUnKSA+PSAwKSB7XFxuICAgICAgeSA9IGAke3BhcnNlSW50KHksIDEwKSAqIHByb2dyZXNzfSVgO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHkgPSBgJHt5ICogcHJvZ3Jlc3N9cHhgO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3BhY2l0eSAhPT0gbnVsbCkge1xcbiAgICAgIGNvbnN0IGN1cnJlbnRPcGFjaXR5ID0gb3BhY2l0eSAtICgob3BhY2l0eSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpKTtcXG4gICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IGN1cnJlbnRPcGFjaXR5O1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2Ygc2NhbGUgPT09ICd1bmRlZmluZWQnIHx8IHNjYWxlID09PSBudWxsKSB7XFxuICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt4fSwgJHt5fSwgMHB4KWApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHNjYWxlIC0gKChzY2FsZSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpKTtcXG4gICAgICAkZWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3h9LCAke3l9LCAwcHgpIHNjYWxlKCR7Y3VycmVudFNjYWxlfSlgKTtcXG4gICAgfVxcbiAgfSxcXG4gIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qge1xcbiAgICAgICRlbCwgc2xpZGVzLCBwcm9ncmVzcywgc25hcEdyaWQsXFxuICAgIH0gPSBzd2lwZXI7XFxuICAgICRlbC5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpXFxuICAgICAgLmVhY2goKGluZGV4LCBlbCkgPT4ge1xcbiAgICAgICAgc3dpcGVyLnBhcmFsbGF4LnNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpO1xcbiAgICAgIH0pO1xcbiAgICBzbGlkZXMuZWFjaCgoc2xpZGVJbmRleCwgc2xpZGVFbCkgPT4ge1xcbiAgICAgIGxldCBzbGlkZVByb2dyZXNzID0gc2xpZGVFbC5wcm9ncmVzcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycpIHtcXG4gICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIChwcm9ncmVzcyAqIChzbmFwR3JpZC5sZW5ndGggLSAxKSk7XFxuICAgICAgfVxcbiAgICAgIHNsaWRlUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtMSksIDEpO1xcbiAgICAgIE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc2xpZGVFbCkuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpXFxuICAgICAgICAuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XFxuICAgICAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2Zvcm0oZWwsIHNsaWRlUHJvZ3Jlc3MpO1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfSxcXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24gPSB0aGlzLnBhcmFtcy5zcGVlZCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB7ICRlbCB9ID0gc3dpcGVyO1xcbiAgICAkZWwuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpXFxuICAgICAgLmVhY2goKGluZGV4LCBwYXJhbGxheEVsKSA9PiB7XFxuICAgICAgICBjb25zdCAkcGFyYWxsYXhFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkocGFyYWxsYXhFbCk7XFxuICAgICAgICBsZXQgcGFyYWxsYXhEdXJhdGlvbiA9IHBhcnNlSW50KCRwYXJhbGxheEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LWR1cmF0aW9uJyksIDEwKSB8fCBkdXJhdGlvbjtcXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcGFyYWxsYXhEdXJhdGlvbiA9IDA7XFxuICAgICAgICAkcGFyYWxsYXhFbC50cmFuc2l0aW9uKHBhcmFsbGF4RHVyYXRpb24pO1xcbiAgICAgIH0pO1xcbiAgfSxcXG59O1xcblxcbnZhciBQYXJhbGxheCQxID0ge1xcbiAgbmFtZTogJ3BhcmFsbGF4JyxcXG4gIHBhcmFtczoge1xcbiAgICBwYXJhbGxheDoge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICB9LFxcbiAgfSxcXG4gIGNyZWF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIHBhcmFsbGF4OiB7XFxuICAgICAgICBzZXRUcmFuc2Zvcm06IFBhcmFsbGF4LnNldFRyYW5zZm9ybS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2xhdGU6IFBhcmFsbGF4LnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBQYXJhbGxheC5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBiZWZvcmVJbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xcbiAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcXG4gICAgfSxcXG4gICAgaW5pdCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XFxuICAgICAgc3dpcGVyLnBhcmFsbGF4LnNldFRyYW5zbGF0ZSgpO1xcbiAgICB9LFxcbiAgICBzZXRUcmFuc2xhdGUoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIucGFyYWxsYXguc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuY29uc3QgWm9vbSA9IHtcXG4gIC8vIENhbGMgU2NhbGUgRnJvbSBNdWx0aS10b3VjaGVzXFxuICBnZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGUpIHtcXG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSByZXR1cm4gMTtcXG4gICAgY29uc3QgeDEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XFxuICAgIGNvbnN0IHkxID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xcbiAgICBjb25zdCB4MiA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWDtcXG4gICAgY29uc3QgeTIgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVk7XFxuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCgoeDIgLSB4MSkgKiogMikgKyAoKHkyIC0geTEpICoqIDIpKTtcXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xcbiAgfSxcXG4gIC8vIEV2ZW50c1xcbiAgb25HZXN0dXJlU3RhcnQoZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XFxuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcXG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xcbiAgICB6b29tLmZha2VHZXN0dXJlVG91Y2hlZCA9IGZhbHNlO1xcbiAgICB6b29tLmZha2VHZXN0dXJlTW92ZWQgPSBmYWxzZTtcXG4gICAgaWYgKCFTdXBwb3J0Lmdlc3R1cmVzKSB7XFxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoc3RhcnQnIHx8IChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgem9vbS5mYWtlR2VzdHVyZVRvdWNoZWQgPSB0cnVlO1xcbiAgICAgIGdlc3R1cmUuc2NhbGVTdGFydCA9IFpvb20uZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKTtcXG4gICAgfVxcbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwgfHwgIWdlc3R1cmUuJHNsaWRlRWwubGVuZ3RoKSB7XFxuICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKTtcXG4gICAgICBpZiAoZ2VzdHVyZS4kc2xpZGVFbC5sZW5ndGggPT09IDApIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XFxuICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IGdlc3R1cmUuJHNsaWRlRWwuZmluZCgnaW1nLCBzdmcsIGNhbnZhcywgcGljdHVyZSwgLnN3aXBlci16b29tLXRhcmdldCcpO1xcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcXG4gICAgICBnZXN0dXJlLm1heFJhdGlvID0gZ2VzdHVyZS4kaW1hZ2VXcmFwRWwuYXR0cignZGF0YS1zd2lwZXItem9vbScpIHx8IHBhcmFtcy5tYXhSYXRpbztcXG4gICAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VXcmFwRWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBnZXN0dXJlLiRpbWFnZUVsID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VFbCkge1xcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigwKTtcXG4gICAgfVxcbiAgICBzd2lwZXIuem9vbS5pc1NjYWxpbmcgPSB0cnVlO1xcbiAgfSxcXG4gIG9uR2VzdHVyZUNoYW5nZShlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XFxuICAgIGlmICghU3VwcG9ydC5nZXN0dXJlcykge1xcbiAgICAgIGlmIChlLnR5cGUgIT09ICd0b3VjaG1vdmUnIHx8IChlLnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICB6b29tLmZha2VHZXN0dXJlTW92ZWQgPSB0cnVlO1xcbiAgICAgIGdlc3R1cmUuc2NhbGVNb3ZlID0gWm9vbS5nZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGUpO1xcbiAgICB9XFxuICAgIGlmICghZ2VzdHVyZS4kaW1hZ2VFbCB8fCBnZXN0dXJlLiRpbWFnZUVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xcbiAgICAgIHpvb20uc2NhbGUgPSBlLnNjYWxlICogem9vbS5jdXJyZW50U2NhbGU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgem9vbS5zY2FsZSA9IChnZXN0dXJlLnNjYWxlTW92ZSAvIGdlc3R1cmUuc2NhbGVTdGFydCkgKiB6b29tLmN1cnJlbnRTY2FsZTtcXG4gICAgfVxcbiAgICBpZiAoem9vbS5zY2FsZSA+IGdlc3R1cmUubWF4UmF0aW8pIHtcXG4gICAgICB6b29tLnNjYWxlID0gKGdlc3R1cmUubWF4UmF0aW8gLSAxKSArICgoKHpvb20uc2NhbGUgLSBnZXN0dXJlLm1heFJhdGlvKSArIDEpICoqIDAuNSk7XFxuICAgIH1cXG4gICAgaWYgKHpvb20uc2NhbGUgPCBwYXJhbXMubWluUmF0aW8pIHtcXG4gICAgICB6b29tLnNjYWxlID0gKHBhcmFtcy5taW5SYXRpbyArIDEpIC0gKCgocGFyYW1zLm1pblJhdGlvIC0gem9vbS5zY2FsZSkgKyAxKSAqKiAwLjUpO1xcbiAgICB9XFxuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHt6b29tLnNjYWxlfSlgKTtcXG4gIH0sXFxuICBvbkdlc3R1cmVFbmQoZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XFxuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcXG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xcbiAgICBpZiAoIVN1cHBvcnQuZ2VzdHVyZXMpIHtcXG4gICAgICBpZiAoIXpvb20uZmFrZUdlc3R1cmVUb3VjaGVkIHx8ICF6b29tLmZha2VHZXN0dXJlTW92ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoZW5kJyB8fCAoZS50eXBlID09PSAndG91Y2hlbmQnICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgMiAmJiAhRGV2aWNlLmFuZHJvaWQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIHpvb20uZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XFxuICAgICAgem9vbS5mYWtlR2VzdHVyZU1vdmVkID0gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIHpvb20uc2NhbGUgPSBNYXRoLm1heChNYXRoLm1pbih6b29tLnNjYWxlLCBnZXN0dXJlLm1heFJhdGlvKSwgcGFyYW1zLm1pblJhdGlvKTtcXG4gICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2l0aW9uKHN3aXBlci5wYXJhbXMuc3BlZWQpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYCk7XFxuICAgIHpvb20uY3VycmVudFNjYWxlID0gem9vbS5zY2FsZTtcXG4gICAgem9vbS5pc1NjYWxpbmcgPSBmYWxzZTtcXG4gICAgaWYgKHpvb20uc2NhbGUgPT09IDEpIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XFxuICB9LFxcbiAgb25Ub3VjaFN0YXJ0KGUpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xcbiAgICBjb25zdCB7IGdlc3R1cmUsIGltYWdlIH0gPSB6b29tO1xcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcXG4gICAgaWYgKGltYWdlLmlzVG91Y2hlZCkgcmV0dXJuO1xcbiAgICBpZiAoRGV2aWNlLmFuZHJvaWQgJiYgZS5jYW5jZWxhYmxlKSBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGltYWdlLmlzVG91Y2hlZCA9IHRydWU7XFxuICAgIGltYWdlLnRvdWNoZXNTdGFydC54ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xcbiAgICBpbWFnZS50b3VjaGVzU3RhcnQueSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcXG4gIH0sXFxuICBvblRvdWNoTW92ZShlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcXG4gICAgY29uc3QgeyBnZXN0dXJlLCBpbWFnZSwgdmVsb2NpdHkgfSA9IHpvb207XFxuICAgIGlmICghZ2VzdHVyZS4kaW1hZ2VFbCB8fCBnZXN0dXJlLiRpbWFnZUVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xcbiAgICBpZiAoIWltYWdlLmlzVG91Y2hlZCB8fCAhZ2VzdHVyZS4kc2xpZGVFbCkgcmV0dXJuO1xcblxcbiAgICBpZiAoIWltYWdlLmlzTW92ZWQpIHtcXG4gICAgICBpbWFnZS53aWR0aCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGg7XFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZ2VzdHVyZS4kaW1hZ2VFbFswXS5vZmZzZXRIZWlnaHQ7XFxuICAgICAgaW1hZ2Uuc3RhcnRYID0gVXRpbHMuZ2V0VHJhbnNsYXRlKGdlc3R1cmUuJGltYWdlV3JhcEVsWzBdLCAneCcpIHx8IDA7XFxuICAgICAgaW1hZ2Uuc3RhcnRZID0gVXRpbHMuZ2V0VHJhbnNsYXRlKGdlc3R1cmUuJGltYWdlV3JhcEVsWzBdLCAneScpIHx8IDA7XFxuICAgICAgZ2VzdHVyZS5zbGlkZVdpZHRoID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aDtcXG4gICAgICBnZXN0dXJlLnNsaWRlSGVpZ2h0ID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQ7XFxuICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigwKTtcXG4gICAgICBpZiAoc3dpcGVyLnJ0bCkge1xcbiAgICAgICAgaW1hZ2Uuc3RhcnRYID0gLWltYWdlLnN0YXJ0WDtcXG4gICAgICAgIGltYWdlLnN0YXJ0WSA9IC1pbWFnZS5zdGFydFk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8vIERlZmluZSBpZiB3ZSBuZWVkIGltYWdlIGRyYWdcXG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBpbWFnZS53aWR0aCAqIHpvb20uc2NhbGU7XFxuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGltYWdlLmhlaWdodCAqIHpvb20uc2NhbGU7XFxuXFxuICAgIGlmIChzY2FsZWRXaWR0aCA8IGdlc3R1cmUuc2xpZGVXaWR0aCAmJiBzY2FsZWRIZWlnaHQgPCBnZXN0dXJlLnNsaWRlSGVpZ2h0KSByZXR1cm47XFxuXFxuICAgIGltYWdlLm1pblggPSBNYXRoLm1pbigoKGdlc3R1cmUuc2xpZGVXaWR0aCAvIDIpIC0gKHNjYWxlZFdpZHRoIC8gMikpLCAwKTtcXG4gICAgaW1hZ2UubWF4WCA9IC1pbWFnZS5taW5YO1xcbiAgICBpbWFnZS5taW5ZID0gTWF0aC5taW4oKChnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcXG4gICAgaW1hZ2UubWF4WSA9IC1pbWFnZS5taW5ZO1xcblxcbiAgICBpbWFnZS50b3VjaGVzQ3VycmVudC54ID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XFxuICAgIGltYWdlLnRvdWNoZXNDdXJyZW50LnkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcXG5cXG4gICAgaWYgKCFpbWFnZS5pc01vdmVkICYmICF6b29tLmlzU2NhbGluZykge1xcbiAgICAgIGlmIChcXG4gICAgICAgIHN3aXBlci5pc0hvcml6b250YWwoKVxcbiAgICAgICAgJiYgKFxcbiAgICAgICAgICAoTWF0aC5mbG9vcihpbWFnZS5taW5YKSA9PT0gTWF0aC5mbG9vcihpbWFnZS5zdGFydFgpICYmIGltYWdlLnRvdWNoZXNDdXJyZW50LnggPCBpbWFnZS50b3VjaGVzU3RhcnQueClcXG4gICAgICAgICAgfHwgKE1hdGguZmxvb3IoaW1hZ2UubWF4WCkgPT09IE1hdGguZmxvb3IoaW1hZ2Uuc3RhcnRYKSAmJiBpbWFnZS50b3VjaGVzQ3VycmVudC54ID4gaW1hZ2UudG91Y2hlc1N0YXJ0LngpXFxuICAgICAgICApXFxuICAgICAgKSB7XFxuICAgICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IGlmIChcXG4gICAgICAgICFzd2lwZXIuaXNIb3Jpem9udGFsKClcXG4gICAgICAgICYmIChcXG4gICAgICAgICAgKE1hdGguZmxvb3IoaW1hZ2UubWluWSkgPT09IE1hdGguZmxvb3IoaW1hZ2Uuc3RhcnRZKSAmJiBpbWFnZS50b3VjaGVzQ3VycmVudC55IDwgaW1hZ2UudG91Y2hlc1N0YXJ0LnkpXFxuICAgICAgICAgIHx8IChNYXRoLmZsb29yKGltYWdlLm1heFkpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WSkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA+IGltYWdlLnRvdWNoZXNTdGFydC55KVxcbiAgICAgICAgKVxcbiAgICAgICkge1xcbiAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlLmNhbmNlbGFibGUpIHtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgaW1hZ2UuaXNNb3ZlZCA9IHRydWU7XFxuICAgIGltYWdlLmN1cnJlbnRYID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSBpbWFnZS50b3VjaGVzU3RhcnQueCkgKyBpbWFnZS5zdGFydFg7XFxuICAgIGltYWdlLmN1cnJlbnRZID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSBpbWFnZS50b3VjaGVzU3RhcnQueSkgKyBpbWFnZS5zdGFydFk7XFxuXFxuICAgIGlmIChpbWFnZS5jdXJyZW50WCA8IGltYWdlLm1pblgpIHtcXG4gICAgICBpbWFnZS5jdXJyZW50WCA9IChpbWFnZS5taW5YICsgMSkgLSAoKChpbWFnZS5taW5YIC0gaW1hZ2UuY3VycmVudFgpICsgMSkgKiogMC44KTtcXG4gICAgfVxcbiAgICBpZiAoaW1hZ2UuY3VycmVudFggPiBpbWFnZS5tYXhYKSB7XFxuICAgICAgaW1hZ2UuY3VycmVudFggPSAoaW1hZ2UubWF4WCAtIDEpICsgKCgoaW1hZ2UuY3VycmVudFggLSBpbWFnZS5tYXhYKSArIDEpICoqIDAuOCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGltYWdlLmN1cnJlbnRZIDwgaW1hZ2UubWluWSkge1xcbiAgICAgIGltYWdlLmN1cnJlbnRZID0gKGltYWdlLm1pblkgKyAxKSAtICgoKGltYWdlLm1pblkgLSBpbWFnZS5jdXJyZW50WSkgKyAxKSAqKiAwLjgpO1xcbiAgICB9XFxuICAgIGlmIChpbWFnZS5jdXJyZW50WSA+IGltYWdlLm1heFkpIHtcXG4gICAgICBpbWFnZS5jdXJyZW50WSA9IChpbWFnZS5tYXhZIC0gMSkgKyAoKChpbWFnZS5jdXJyZW50WSAtIGltYWdlLm1heFkpICsgMSkgKiogMC44KTtcXG4gICAgfVxcblxcbiAgICAvLyBWZWxvY2l0eVxcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblgpIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblkpIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZUaW1lKSB2ZWxvY2l0eS5wcmV2VGltZSA9IERhdGUubm93KCk7XFxuICAgIHZlbG9jaXR5LnggPSAoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblgpIC8gKERhdGUubm93KCkgLSB2ZWxvY2l0eS5wcmV2VGltZSkgLyAyO1xcbiAgICB2ZWxvY2l0eS55ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcXG4gICAgaWYgKE1hdGguYWJzKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSA8IDIpIHZlbG9jaXR5LnggPSAwO1xcbiAgICBpZiAoTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblkpIDwgMikgdmVsb2NpdHkueSA9IDA7XFxuICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xcbiAgICB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueTtcXG4gICAgdmVsb2NpdHkucHJldlRpbWUgPSBEYXRlLm5vdygpO1xcblxcbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aW1hZ2UuY3VycmVudFh9cHgsICR7aW1hZ2UuY3VycmVudFl9cHgsMClgKTtcXG4gIH0sXFxuICBvblRvdWNoRW5kKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XFxuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UsIHZlbG9jaXR5IH0gPSB6b29tO1xcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcXG4gICAgaWYgKCFpbWFnZS5pc1RvdWNoZWQgfHwgIWltYWdlLmlzTW92ZWQpIHtcXG4gICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcXG4gICAgICBpbWFnZS5pc01vdmVkID0gZmFsc2U7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGltYWdlLmlzVG91Y2hlZCA9IGZhbHNlO1xcbiAgICBpbWFnZS5pc01vdmVkID0gZmFsc2U7XFxuICAgIGxldCBtb21lbnR1bUR1cmF0aW9uWCA9IDMwMDtcXG4gICAgbGV0IG1vbWVudHVtRHVyYXRpb25ZID0gMzAwO1xcbiAgICBjb25zdCBtb21lbnR1bURpc3RhbmNlWCA9IHZlbG9jaXR5LnggKiBtb21lbnR1bUR1cmF0aW9uWDtcXG4gICAgY29uc3QgbmV3UG9zaXRpb25YID0gaW1hZ2UuY3VycmVudFggKyBtb21lbnR1bURpc3RhbmNlWDtcXG4gICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZVkgPSB2ZWxvY2l0eS55ICogbW9tZW50dW1EdXJhdGlvblk7XFxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uWSA9IGltYWdlLmN1cnJlbnRZICsgbW9tZW50dW1EaXN0YW5jZVk7XFxuXFxuICAgIC8vIEZpeCBkdXJhdGlvblxcbiAgICBpZiAodmVsb2NpdHkueCAhPT0gMCkgbW9tZW50dW1EdXJhdGlvblggPSBNYXRoLmFicygobmV3UG9zaXRpb25YIC0gaW1hZ2UuY3VycmVudFgpIC8gdmVsb2NpdHkueCk7XFxuICAgIGlmICh2ZWxvY2l0eS55ICE9PSAwKSBtb21lbnR1bUR1cmF0aW9uWSA9IE1hdGguYWJzKChuZXdQb3NpdGlvblkgLSBpbWFnZS5jdXJyZW50WSkgLyB2ZWxvY2l0eS55KTtcXG4gICAgY29uc3QgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGgubWF4KG1vbWVudHVtRHVyYXRpb25YLCBtb21lbnR1bUR1cmF0aW9uWSk7XFxuXFxuICAgIGltYWdlLmN1cnJlbnRYID0gbmV3UG9zaXRpb25YO1xcbiAgICBpbWFnZS5jdXJyZW50WSA9IG5ld1Bvc2l0aW9uWTtcXG5cXG4gICAgLy8gRGVmaW5lIGlmIHdlIG5lZWQgaW1hZ2UgZHJhZ1xcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGltYWdlLndpZHRoICogem9vbS5zY2FsZTtcXG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogem9vbS5zY2FsZTtcXG4gICAgaW1hZ2UubWluWCA9IE1hdGgubWluKCgoZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMikgLSAoc2NhbGVkV2lkdGggLyAyKSksIDApO1xcbiAgICBpbWFnZS5tYXhYID0gLWltYWdlLm1pblg7XFxuICAgIGltYWdlLm1pblkgPSBNYXRoLm1pbigoKGdlc3R1cmUuc2xpZGVIZWlnaHQgLyAyKSAtIChzY2FsZWRIZWlnaHQgLyAyKSksIDApO1xcbiAgICBpbWFnZS5tYXhZID0gLWltYWdlLm1pblk7XFxuICAgIGltYWdlLmN1cnJlbnRYID0gTWF0aC5tYXgoTWF0aC5taW4oaW1hZ2UuY3VycmVudFgsIGltYWdlLm1heFgpLCBpbWFnZS5taW5YKTtcXG4gICAgaW1hZ2UuY3VycmVudFkgPSBNYXRoLm1heChNYXRoLm1pbihpbWFnZS5jdXJyZW50WSwgaW1hZ2UubWF4WSksIGltYWdlLm1pblkpO1xcblxcbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpbWFnZS5jdXJyZW50WH1weCwgJHtpbWFnZS5jdXJyZW50WX1weCwwKWApO1xcbiAgfSxcXG4gIG9uVHJhbnNpdGlvbkVuZCgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XFxuICAgIGlmIChnZXN0dXJlLiRzbGlkZUVsICYmIHN3aXBlci5wcmV2aW91c0luZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcXG4gICAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VFbCkge1xcbiAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKScpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VXcmFwRWwpIHtcXG4gICAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHpvb20uc2NhbGUgPSAxO1xcbiAgICAgIHpvb20uY3VycmVudFNjYWxlID0gMTtcXG5cXG4gICAgICBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSB1bmRlZmluZWQ7XFxuICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gIH0sXFxuICAvLyBUb2dnbGUgWm9vbVxcbiAgdG9nZ2xlKGUpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xcblxcbiAgICBpZiAoem9vbS5zY2FsZSAmJiB6b29tLnNjYWxlICE9PSAxKSB7XFxuICAgICAgLy8gWm9vbSBPdXRcXG4gICAgICB6b29tLm91dCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFpvb20gSW5cXG4gICAgICB6b29tLmluKGUpO1xcbiAgICB9XFxuICB9LFxcbiAgaW4oZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XFxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcXG4gICAgY29uc3QgeyBnZXN0dXJlLCBpbWFnZSB9ID0gem9vbTtcXG5cXG4gICAgaWYgKCFnZXN0dXJlLiRzbGlkZUVsKSB7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBzd2lwZXIudmlydHVhbCkge1xcbiAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XFxuICAgICAgfVxcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMsIHBpY3R1cmUsIC5zd2lwZXItem9vbS10YXJnZXQnKTtcXG4gICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbCA9IGdlc3R1cmUuJGltYWdlRWwucGFyZW50KGAuJHtwYXJhbXMuY29udGFpbmVyQ2xhc3N9YCk7XFxuICAgIH1cXG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XFxuXFxuICAgIGdlc3R1cmUuJHNsaWRlRWwuYWRkQ2xhc3MoYCR7cGFyYW1zLnpvb21lZFNsaWRlQ2xhc3N9YCk7XFxuXFxuICAgIGxldCB0b3VjaFg7XFxuICAgIGxldCB0b3VjaFk7XFxuICAgIGxldCBvZmZzZXRYO1xcbiAgICBsZXQgb2Zmc2V0WTtcXG4gICAgbGV0IGRpZmZYO1xcbiAgICBsZXQgZGlmZlk7XFxuICAgIGxldCB0cmFuc2xhdGVYO1xcbiAgICBsZXQgdHJhbnNsYXRlWTtcXG4gICAgbGV0IGltYWdlV2lkdGg7XFxuICAgIGxldCBpbWFnZUhlaWdodDtcXG4gICAgbGV0IHNjYWxlZFdpZHRoO1xcbiAgICBsZXQgc2NhbGVkSGVpZ2h0O1xcbiAgICBsZXQgdHJhbnNsYXRlTWluWDtcXG4gICAgbGV0IHRyYW5zbGF0ZU1pblk7XFxuICAgIGxldCB0cmFuc2xhdGVNYXhYO1xcbiAgICBsZXQgdHJhbnNsYXRlTWF4WTtcXG4gICAgbGV0IHNsaWRlV2lkdGg7XFxuICAgIGxldCBzbGlkZUhlaWdodDtcXG5cXG4gICAgaWYgKHR5cGVvZiBpbWFnZS50b3VjaGVzU3RhcnQueCA9PT0gJ3VuZGVmaW5lZCcgJiYgZSkge1xcbiAgICAgIHRvdWNoWCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xcbiAgICAgIHRvdWNoWSA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRvdWNoWCA9IGltYWdlLnRvdWNoZXNTdGFydC54O1xcbiAgICAgIHRvdWNoWSA9IGltYWdlLnRvdWNoZXNTdGFydC55O1xcbiAgICB9XFxuXFxuICAgIHpvb20uc2NhbGUgPSBnZXN0dXJlLiRpbWFnZVdyYXBFbC5hdHRyKCdkYXRhLXN3aXBlci16b29tJykgfHwgcGFyYW1zLm1heFJhdGlvO1xcbiAgICB6b29tLmN1cnJlbnRTY2FsZSA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XFxuICAgIGlmIChlKSB7XFxuICAgICAgc2xpZGVXaWR0aCA9IGdlc3R1cmUuJHNsaWRlRWxbMF0ub2Zmc2V0V2lkdGg7XFxuICAgICAgc2xpZGVIZWlnaHQgPSBnZXN0dXJlLiRzbGlkZUVsWzBdLm9mZnNldEhlaWdodDtcXG4gICAgICBvZmZzZXRYID0gZ2VzdHVyZS4kc2xpZGVFbC5vZmZzZXQoKS5sZWZ0O1xcbiAgICAgIG9mZnNldFkgPSBnZXN0dXJlLiRzbGlkZUVsLm9mZnNldCgpLnRvcDtcXG4gICAgICBkaWZmWCA9IChvZmZzZXRYICsgKHNsaWRlV2lkdGggLyAyKSkgLSB0b3VjaFg7XFxuICAgICAgZGlmZlkgPSAob2Zmc2V0WSArIChzbGlkZUhlaWdodCAvIDIpKSAtIHRvdWNoWTtcXG5cXG4gICAgICBpbWFnZVdpZHRoID0gZ2VzdHVyZS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aDtcXG4gICAgICBpbWFnZUhlaWdodCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xcbiAgICAgIHNjYWxlZFdpZHRoID0gaW1hZ2VXaWR0aCAqIHpvb20uc2NhbGU7XFxuICAgICAgc2NhbGVkSGVpZ2h0ID0gaW1hZ2VIZWlnaHQgKiB6b29tLnNjYWxlO1xcblxcbiAgICAgIHRyYW5zbGF0ZU1pblggPSBNYXRoLm1pbigoKHNsaWRlV2lkdGggLyAyKSAtIChzY2FsZWRXaWR0aCAvIDIpKSwgMCk7XFxuICAgICAgdHJhbnNsYXRlTWluWSA9IE1hdGgubWluKCgoc2xpZGVIZWlnaHQgLyAyKSAtIChzY2FsZWRIZWlnaHQgLyAyKSksIDApO1xcbiAgICAgIHRyYW5zbGF0ZU1heFggPSAtdHJhbnNsYXRlTWluWDtcXG4gICAgICB0cmFuc2xhdGVNYXhZID0gLXRyYW5zbGF0ZU1pblk7XFxuXFxuICAgICAgdHJhbnNsYXRlWCA9IGRpZmZYICogem9vbS5zY2FsZTtcXG4gICAgICB0cmFuc2xhdGVZID0gZGlmZlkgKiB6b29tLnNjYWxlO1xcblxcbiAgICAgIGlmICh0cmFuc2xhdGVYIDwgdHJhbnNsYXRlTWluWCkge1xcbiAgICAgICAgdHJhbnNsYXRlWCA9IHRyYW5zbGF0ZU1pblg7XFxuICAgICAgfVxcbiAgICAgIGlmICh0cmFuc2xhdGVYID4gdHJhbnNsYXRlTWF4WCkge1xcbiAgICAgICAgdHJhbnNsYXRlWCA9IHRyYW5zbGF0ZU1heFg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0cmFuc2xhdGVZIDwgdHJhbnNsYXRlTWluWSkge1xcbiAgICAgICAgdHJhbnNsYXRlWSA9IHRyYW5zbGF0ZU1pblk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0cmFuc2xhdGVZID4gdHJhbnNsYXRlTWF4WSkge1xcbiAgICAgICAgdHJhbnNsYXRlWSA9IHRyYW5zbGF0ZU1heFk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRyYW5zbGF0ZVggPSAwO1xcbiAgICAgIHRyYW5zbGF0ZVkgPSAwO1xcbiAgICB9XFxuICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlWH1weCwgJHt0cmFuc2xhdGVZfXB4LDApYCk7XFxuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYCk7XFxuICB9LFxcbiAgb3V0KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcblxcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XFxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcXG4gICAgY29uc3QgeyBnZXN0dXJlIH0gPSB6b29tO1xcblxcbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsKSB7XFxuICAgICAgICBnZXN0dXJlLiRzbGlkZUVsID0gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcXG4gICAgICB9XFxuICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IGdlc3R1cmUuJHNsaWRlRWwuZmluZCgnaW1nLCBzdmcsIGNhbnZhcywgcGljdHVyZSwgLnN3aXBlci16b29tLXRhcmdldCcpO1xcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcXG4gICAgfVxcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcXG5cXG4gICAgem9vbS5zY2FsZSA9IDE7XFxuICAgIHpvb20uY3VycmVudFNjYWxlID0gMTtcXG4gICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApJyk7XFxuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpJyk7XFxuICAgIGdlc3R1cmUuJHNsaWRlRWwucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLnpvb21lZFNsaWRlQ2xhc3N9YCk7XFxuICAgIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XFxuICB9LFxcbiAgLy8gQXR0YWNoL0RldGFjaCBFdmVudHNcXG4gIGVuYWJsZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xcbiAgICBpZiAoem9vbS5lbmFibGVkKSByZXR1cm47XFxuICAgIHpvb20uZW5hYmxlZCA9IHRydWU7XFxuXFxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xcbiAgICBjb25zdCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiB0cnVlIH0gOiB0cnVlO1xcblxcbiAgICBjb25zdCBzbGlkZVNlbGVjdG9yID0gYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gO1xcblxcbiAgICAvLyBTY2FsZSBpbWFnZVxcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlc3RhcnQnLCBzbGlkZVNlbGVjdG9yLCB6b29tLm9uR2VzdHVyZVN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlY2hhbmdlJywgc2xpZGVTZWxlY3Rvciwgem9vbS5vbkdlc3R1cmVDaGFuZ2UsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oJ2dlc3R1cmVlbmQnLCBzbGlkZVNlbGVjdG9yLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgfSBlbHNlIGlmIChzd2lwZXIudG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0Jykge1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCwgc2xpZGVTZWxlY3Rvciwgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMubW92ZSwgc2xpZGVTZWxlY3Rvciwgem9vbS5vbkdlc3R1cmVDaGFuZ2UsIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmUpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5lbmQsIHNsaWRlU2VsZWN0b3IsIHpvb20ub25HZXN0dXJlRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIGlmIChzd2lwZXIudG91Y2hFdmVudHMuY2FuY2VsKSB7XFxuICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMuY2FuY2VsLCBzbGlkZVNlbGVjdG9yLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gTW92ZSBpbWFnZVxcbiAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMubW92ZSwgYC4ke3N3aXBlci5wYXJhbXMuem9vbS5jb250YWluZXJDbGFzc31gLCB6b29tLm9uVG91Y2hNb3ZlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcXG4gIH0sXFxuICBkaXNhYmxlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XFxuICAgIGlmICghem9vbS5lbmFibGVkKSByZXR1cm47XFxuXFxuICAgIHN3aXBlci56b29tLmVuYWJsZWQgPSBmYWxzZTtcXG5cXG4gICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gc3dpcGVyLnRvdWNoRXZlbnRzLnN0YXJ0ID09PSAndG91Y2hzdGFydCcgJiYgU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgc3dpcGVyLnBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmUgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfSA6IHRydWU7XFxuXFxuICAgIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSBgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWA7XFxuXFxuICAgIC8vIFNjYWxlIGltYWdlXFxuICAgIGlmIChTdXBwb3J0Lmdlc3R1cmVzKSB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKCdnZXN0dXJlc3RhcnQnLCBzbGlkZVNlbGVjdG9yLCB6b29tLm9uR2VzdHVyZVN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9mZignZ2VzdHVyZWNoYW5nZScsIHNsaWRlU2VsZWN0b3IsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9mZignZ2VzdHVyZWVuZCcsIHNsaWRlU2VsZWN0b3IsIHpvb20ub25HZXN0dXJlRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xcbiAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCwgc2xpZGVTZWxlY3Rvciwgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIHNsaWRlU2VsZWN0b3IsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcXG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgc2xpZGVTZWxlY3Rvciwgem9vbS5vbkdlc3R1cmVFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XFxuICAgICAgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5jYW5jZWwpIHtcXG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9mZihzd2lwZXIudG91Y2hFdmVudHMuY2FuY2VsLCBzbGlkZVNlbGVjdG9yLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gTW92ZSBpbWFnZVxcbiAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIGAuJHtzd2lwZXIucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3N9YCwgem9vbS5vblRvdWNoTW92ZSwgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZSk7XFxuICB9LFxcbn07XFxuXFxudmFyIFpvb20kMSA9IHtcXG4gIG5hbWU6ICd6b29tJyxcXG4gIHBhcmFtczoge1xcbiAgICB6b29tOiB7XFxuICAgICAgZW5hYmxlZDogZmFsc2UsXFxuICAgICAgbWF4UmF0aW86IDMsXFxuICAgICAgbWluUmF0aW86IDEsXFxuICAgICAgdG9nZ2xlOiB0cnVlLFxcbiAgICAgIGNvbnRhaW5lckNsYXNzOiAnc3dpcGVyLXpvb20tY29udGFpbmVyJyxcXG4gICAgICB6b29tZWRTbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXpvb21lZCcsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB6b29tID0ge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIHNjYWxlOiAxLFxcbiAgICAgIGN1cnJlbnRTY2FsZTogMSxcXG4gICAgICBpc1NjYWxpbmc6IGZhbHNlLFxcbiAgICAgIGdlc3R1cmU6IHtcXG4gICAgICAgICRzbGlkZUVsOiB1bmRlZmluZWQsXFxuICAgICAgICBzbGlkZVdpZHRoOiB1bmRlZmluZWQsXFxuICAgICAgICBzbGlkZUhlaWdodDogdW5kZWZpbmVkLFxcbiAgICAgICAgJGltYWdlRWw6IHVuZGVmaW5lZCxcXG4gICAgICAgICRpbWFnZVdyYXBFbDogdW5kZWZpbmVkLFxcbiAgICAgICAgbWF4UmF0aW86IDMsXFxuICAgICAgfSxcXG4gICAgICBpbWFnZToge1xcbiAgICAgICAgaXNUb3VjaGVkOiB1bmRlZmluZWQsXFxuICAgICAgICBpc01vdmVkOiB1bmRlZmluZWQsXFxuICAgICAgICBjdXJyZW50WDogdW5kZWZpbmVkLFxcbiAgICAgICAgY3VycmVudFk6IHVuZGVmaW5lZCxcXG4gICAgICAgIG1pblg6IHVuZGVmaW5lZCxcXG4gICAgICAgIG1pblk6IHVuZGVmaW5lZCxcXG4gICAgICAgIG1heFg6IHVuZGVmaW5lZCxcXG4gICAgICAgIG1heFk6IHVuZGVmaW5lZCxcXG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXFxuICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcXG4gICAgICAgIHN0YXJ0WDogdW5kZWZpbmVkLFxcbiAgICAgICAgc3RhcnRZOiB1bmRlZmluZWQsXFxuICAgICAgICB0b3VjaGVzU3RhcnQ6IHt9LFxcbiAgICAgICAgdG91Y2hlc0N1cnJlbnQ6IHt9LFxcbiAgICAgIH0sXFxuICAgICAgdmVsb2NpdHk6IHtcXG4gICAgICAgIHg6IHVuZGVmaW5lZCxcXG4gICAgICAgIHk6IHVuZGVmaW5lZCxcXG4gICAgICAgIHByZXZQb3NpdGlvblg6IHVuZGVmaW5lZCxcXG4gICAgICAgIHByZXZQb3NpdGlvblk6IHVuZGVmaW5lZCxcXG4gICAgICAgIHByZXZUaW1lOiB1bmRlZmluZWQsXFxuICAgICAgfSxcXG4gICAgfTtcXG5cXG4gICAgKCdvbkdlc3R1cmVTdGFydCBvbkdlc3R1cmVDaGFuZ2Ugb25HZXN0dXJlRW5kIG9uVG91Y2hTdGFydCBvblRvdWNoTW92ZSBvblRvdWNoRW5kIG9uVHJhbnNpdGlvbkVuZCB0b2dnbGUgZW5hYmxlIGRpc2FibGUgaW4gb3V0Jykuc3BsaXQoJyAnKS5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XFxuICAgICAgem9vbVttZXRob2ROYW1lXSA9IFpvb21bbWV0aG9kTmFtZV0uYmluZChzd2lwZXIpO1xcbiAgICB9KTtcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIHpvb20sXFxuICAgIH0pO1xcblxcbiAgICBsZXQgc2NhbGUgPSAxO1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3dpcGVyLnpvb20sICdzY2FsZScsIHtcXG4gICAgICBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gc2NhbGU7XFxuICAgICAgfSxcXG4gICAgICBzZXQodmFsdWUpIHtcXG4gICAgICAgIGlmIChzY2FsZSAhPT0gdmFsdWUpIHtcXG4gICAgICAgICAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci56b29tLmdlc3R1cmUuJGltYWdlRWwgPyBzd2lwZXIuem9vbS5nZXN0dXJlLiRpbWFnZUVsWzBdIDogdW5kZWZpbmVkO1xcbiAgICAgICAgICBjb25zdCBzbGlkZUVsID0gc3dpcGVyLnpvb20uZ2VzdHVyZS4kc2xpZGVFbCA/IHN3aXBlci56b29tLmdlc3R1cmUuJHNsaWRlRWxbMF0gOiB1bmRlZmluZWQ7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCd6b29tQ2hhbmdlJywgdmFsdWUsIGltYWdlRWwsIHNsaWRlRWwpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2NhbGUgPSB2YWx1ZTtcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuem9vbS5lbmFibGVkKSB7XFxuICAgICAgICBzd2lwZXIuem9vbS5lbmFibGUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGRlc3Ryb3koKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBzd2lwZXIuem9vbS5kaXNhYmxlKCk7XFxuICAgIH0sXFxuICAgIHRvdWNoU3RhcnQoZSkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XFxuICAgICAgc3dpcGVyLnpvb20ub25Ub3VjaFN0YXJ0KGUpO1xcbiAgICB9LFxcbiAgICB0b3VjaEVuZChlKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci56b29tLmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIuem9vbS5vblRvdWNoRW5kKGUpO1xcbiAgICB9LFxcbiAgICBkb3VibGVUYXAoZSkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuem9vbS5lbmFibGVkICYmIHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLnRvZ2dsZSkge1xcbiAgICAgICAgc3dpcGVyLnpvb20udG9nZ2xlKGUpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdHJhbnNpdGlvbkVuZCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIuem9vbS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMuem9vbS5lbmFibGVkKSB7XFxuICAgICAgICBzd2lwZXIuem9vbS5vblRyYW5zaXRpb25FbmQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNsaWRlQ2hhbmdlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgICAgICBzd2lwZXIuem9vbS5vblRyYW5zaXRpb25FbmQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuY29uc3QgTGF6eSA9IHtcXG4gIGxvYWRJblNsaWRlKGluZGV4LCBsb2FkSW5EdXBsaWNhdGUgPSB0cnVlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMubGF6eTtcXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcXG4gICAgaWYgKHN3aXBlci5zbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xcblxcbiAgICBjb25zdCAkc2xpZGVFbCA9IGlzVmlydHVhbFxcbiAgICAgID8gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7aW5kZXh9XFxcIl1gKVxcbiAgICAgIDogc3dpcGVyLnNsaWRlcy5lcShpbmRleCk7XFxuXFxuICAgIGxldCAkaW1hZ2VzID0gJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLmVsZW1lbnRDbGFzc306bm90KC4ke3BhcmFtcy5sb2FkZWRDbGFzc30pOm5vdCguJHtwYXJhbXMubG9hZGluZ0NsYXNzfSlgKTtcXG4gICAgaWYgKCRzbGlkZUVsLmhhc0NsYXNzKHBhcmFtcy5lbGVtZW50Q2xhc3MpICYmICEkc2xpZGVFbC5oYXNDbGFzcyhwYXJhbXMubG9hZGVkQ2xhc3MpICYmICEkc2xpZGVFbC5oYXNDbGFzcyhwYXJhbXMubG9hZGluZ0NsYXNzKSkge1xcbiAgICAgICRpbWFnZXMgPSAkaW1hZ2VzLmFkZCgkc2xpZGVFbFswXSk7XFxuICAgIH1cXG4gICAgaWYgKCRpbWFnZXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuXFxuICAgICRpbWFnZXMuZWFjaCgoaW1hZ2VJbmRleCwgaW1hZ2VFbCkgPT4ge1xcbiAgICAgIGNvbnN0ICRpbWFnZUVsID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShpbWFnZUVsKTtcXG4gICAgICAkaW1hZ2VFbC5hZGRDbGFzcyhwYXJhbXMubG9hZGluZ0NsYXNzKTtcXG5cXG4gICAgICBjb25zdCBiYWNrZ3JvdW5kID0gJGltYWdlRWwuYXR0cignZGF0YS1iYWNrZ3JvdW5kJyk7XFxuICAgICAgY29uc3Qgc3JjID0gJGltYWdlRWwuYXR0cignZGF0YS1zcmMnKTtcXG4gICAgICBjb25zdCBzcmNzZXQgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLXNyY3NldCcpO1xcbiAgICAgIGNvbnN0IHNpemVzID0gJGltYWdlRWwuYXR0cignZGF0YS1zaXplcycpO1xcbiAgICAgIGNvbnN0ICRwaWN0dXJlRWwgPSAkaW1hZ2VFbC5wYXJlbnQoJ3BpY3R1cmUnKTtcXG5cXG4gICAgICBzd2lwZXIubG9hZEltYWdlKCRpbWFnZUVsWzBdLCAoc3JjIHx8IGJhY2tncm91bmQpLCBzcmNzZXQsIHNpemVzLCBmYWxzZSwgKCkgPT4ge1xcbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IChzd2lwZXIgJiYgIXN3aXBlci5wYXJhbXMpIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XFxuICAgICAgICAgICRpbWFnZUVsLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIGB1cmwoXFxcIiR7YmFja2dyb3VuZH1cXFwiKWApO1xcbiAgICAgICAgICAkaW1hZ2VFbC5yZW1vdmVBdHRyKCdkYXRhLWJhY2tncm91bmQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChzcmNzZXQpIHtcXG4gICAgICAgICAgICAkaW1hZ2VFbC5hdHRyKCdzcmNzZXQnLCBzcmNzZXQpO1xcbiAgICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtc3Jjc2V0Jyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHNpemVzKSB7XFxuICAgICAgICAgICAgJGltYWdlRWwuYXR0cignc2l6ZXMnLCBzaXplcyk7XFxuICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zaXplcycpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICgkcGljdHVyZUVsLmxlbmd0aCkge1xcbiAgICAgICAgICAgICRwaWN0dXJlRWwuY2hpbGRyZW4oJ3NvdXJjZScpLmVhY2goKHNvdXJjZUluZGV4LCBzb3VyY2VFbCkgPT4ge1xcbiAgICAgICAgICAgICAgY29uc3QgJHNvdXJjZSA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoc291cmNlRWwpO1xcblxcbiAgICAgICAgICAgICAgaWYgKCRzb3VyY2UuYXR0cignZGF0YS1zcmNzZXQnKSkge1xcbiAgICAgICAgICAgICAgICAkc291cmNlLmF0dHIoJ3NyY3NldCcsICRzb3VyY2UuYXR0cignZGF0YS1zcmNzZXQnKSk7XFxuICAgICAgICAgICAgICAgICRzb3VyY2UucmVtb3ZlQXR0cignZGF0YS1zcmNzZXQnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoc3JjKSB7XFxuICAgICAgICAgICAgJGltYWdlRWwuYXR0cignc3JjJywgc3JjKTtcXG4gICAgICAgICAgICAkaW1hZ2VFbC5yZW1vdmVBdHRyKCdkYXRhLXNyYycpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkaW1hZ2VFbC5hZGRDbGFzcyhwYXJhbXMubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpO1xcbiAgICAgICAgJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLnByZWxvYWRlckNsYXNzfWApLnJlbW92ZSgpO1xcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCAmJiBsb2FkSW5EdXBsaWNhdGUpIHtcXG4gICAgICAgICAgY29uc3Qgc2xpZGVPcmlnaW5hbEluZGV4ID0gJHNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcXG4gICAgICAgICAgaWYgKCRzbGlkZUVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNsaWRlID0gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFwiJHtzbGlkZU9yaWdpbmFsSW5kZXh9XFxcIl06bm90KC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCk7XFxuICAgICAgICAgICAgc3dpcGVyLmxhenkubG9hZEluU2xpZGUob3JpZ2luYWxTbGlkZS5pbmRleCgpLCBmYWxzZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlZFNsaWRlID0gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7c2xpZGVPcmlnaW5hbEluZGV4fVxcXCJdYCk7XFxuICAgICAgICAgICAgc3dpcGVyLmxhenkubG9hZEluU2xpZGUoZHVwbGljYXRlZFNsaWRlLmluZGV4KCksIGZhbHNlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2xhenlJbWFnZVJlYWR5JywgJHNsaWRlRWxbMF0sICRpbWFnZUVsWzBdKTtcXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBzd2lwZXIuZW1pdCgnbGF6eUltYWdlTG9hZCcsICRzbGlkZUVsWzBdLCAkaW1hZ2VFbFswXSk7XFxuICAgIH0pO1xcbiAgfSxcXG4gIGxvYWQoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHtcXG4gICAgICAkd3JhcHBlckVsLCBwYXJhbXM6IHN3aXBlclBhcmFtcywgc2xpZGVzLCBhY3RpdmVJbmRleCxcXG4gICAgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyUGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyUGFyYW1zLmxhenk7XFxuXFxuICAgIGxldCBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyUGFyYW1zLnNsaWRlc1BlclZpZXc7XFxuICAgIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcXG4gICAgICBzbGlkZXNQZXJWaWV3ID0gMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzbGlkZUV4aXN0KGluZGV4KSB7XFxuICAgICAgaWYgKGlzVmlydHVhbCkge1xcbiAgICAgICAgaWYgKCR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlclBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFwiJHtpbmRleH1cXFwiXWApLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHNsaWRlc1tpbmRleF0pIHJldHVybiB0cnVlO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzbGlkZUluZGV4KHNsaWRlRWwpIHtcXG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzbGlkZUVsKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzbGlkZUVsKS5pbmRleCgpO1xcbiAgICB9XFxuXFxuICAgIGlmICghc3dpcGVyLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkKSBzd2lwZXIubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQgPSB0cnVlO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcXG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3N9YCkuZWFjaCgoZWxJbmRleCwgc2xpZGVFbCkgPT4ge1xcbiAgICAgICAgY29uc3QgaW5kZXggPSBpc1ZpcnR1YWwgPyBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHNsaWRlRWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgOiBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHNsaWRlRWwpLmluZGV4KCk7XFxuICAgICAgICBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShpbmRleCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSBpZiAoc2xpZGVzUGVyVmlldyA+IDEpIHtcXG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXg7IGkgPCBhY3RpdmVJbmRleCArIHNsaWRlc1BlclZpZXc7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKHNsaWRlRXhpc3QoaSkpIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGkpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShhY3RpdmVJbmRleCk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtcy5sb2FkUHJldk5leHQpIHtcXG4gICAgICBpZiAoc2xpZGVzUGVyVmlldyA+IDEgfHwgKHBhcmFtcy5sb2FkUHJldk5leHRBbW91bnQgJiYgcGFyYW1zLmxvYWRQcmV2TmV4dEFtb3VudCA+IDEpKSB7XFxuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMubG9hZFByZXZOZXh0QW1vdW50O1xcbiAgICAgICAgY29uc3Qgc3B2ID0gc2xpZGVzUGVyVmlldztcXG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gTWF0aC5taW4oYWN0aXZlSW5kZXggKyBzcHYgKyBNYXRoLm1heChhbW91bnQsIHNwdiksIHNsaWRlcy5sZW5ndGgpO1xcbiAgICAgICAgY29uc3QgbWluSW5kZXggPSBNYXRoLm1heChhY3RpdmVJbmRleCAtIE1hdGgubWF4KHNwdiwgYW1vdW50KSwgMCk7XFxuICAgICAgICAvLyBOZXh0IFNsaWRlc1xcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzUGVyVmlldzsgaSA8IG1heEluZGV4OyBpICs9IDEpIHtcXG4gICAgICAgICAgaWYgKHNsaWRlRXhpc3QoaSkpIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gUHJldiBTbGlkZXNcXG4gICAgICAgIGZvciAobGV0IGkgPSBtaW5JbmRleDsgaSA8IGFjdGl2ZUluZGV4OyBpICs9IDEpIHtcXG4gICAgICAgICAgaWYgKHNsaWRlRXhpc3QoaSkpIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zdCBuZXh0U2xpZGUgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVOZXh0Q2xhc3N9YCk7XFxuICAgICAgICBpZiAobmV4dFNsaWRlLmxlbmd0aCA+IDApIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKHNsaWRlSW5kZXgobmV4dFNsaWRlKSk7XFxuXFxuICAgICAgICBjb25zdCBwcmV2U2xpZGUgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVQcmV2Q2xhc3N9YCk7XFxuICAgICAgICBpZiAocHJldlNsaWRlLmxlbmd0aCA+IDApIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKHNsaWRlSW5kZXgocHJldlNsaWRlKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcbn07XFxuXFxudmFyIExhenkkMSA9IHtcXG4gIG5hbWU6ICdsYXp5JyxcXG4gIHBhcmFtczoge1xcbiAgICBsYXp5OiB7XFxuICAgICAgZW5hYmxlZDogZmFsc2UsXFxuICAgICAgbG9hZFByZXZOZXh0OiBmYWxzZSxcXG4gICAgICBsb2FkUHJldk5leHRBbW91bnQ6IDEsXFxuICAgICAgbG9hZE9uVHJhbnNpdGlvblN0YXJ0OiBmYWxzZSxcXG5cXG4gICAgICBlbGVtZW50Q2xhc3M6ICdzd2lwZXItbGF6eScsXFxuICAgICAgbG9hZGluZ0NsYXNzOiAnc3dpcGVyLWxhenktbG9hZGluZycsXFxuICAgICAgbG9hZGVkQ2xhc3M6ICdzd2lwZXItbGF6eS1sb2FkZWQnLFxcbiAgICAgIHByZWxvYWRlckNsYXNzOiAnc3dpcGVyLWxhenktcHJlbG9hZGVyJyxcXG4gICAgfSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBsYXp5OiB7XFxuICAgICAgICBpbml0aWFsSW1hZ2VMb2FkZWQ6IGZhbHNlLFxcbiAgICAgICAgbG9hZDogTGF6eS5sb2FkLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGxvYWRJblNsaWRlOiBMYXp5LmxvYWRJblNsaWRlLmJpbmQoc3dpcGVyKSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBiZWZvcmVJbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcykge1xcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5wcmVsb2FkSW1hZ2VzID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgPT09IDApIHtcXG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNjcm9sbCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XFxuICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICByZXNpemUoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcXG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNjcm9sbGJhckRyYWdNb3ZlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkKSB7XFxuICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB0cmFuc2l0aW9uU3RhcnQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0IHx8ICghc3dpcGVyLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCAmJiAhc3dpcGVyLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkKSkge1xcbiAgICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB0cmFuc2l0aW9uRW5kKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmICFzd2lwZXIucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0KSB7XFxuICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzbGlkZUNoYW5nZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxhenkuZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcXG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuLyogZXNsaW50IG5vLWJpdHdpc2U6IFtcXFwiZXJyb3JcXFwiLCB7IFxcXCJhbGxvd1xcXCI6IFtcXFwiPj5cXFwiXSB9XSAqL1xcblxcbmNvbnN0IENvbnRyb2xsZXIgPSB7XFxuICBMaW5lYXJTcGxpbmU6IGZ1bmN0aW9uIExpbmVhclNwbGluZSh4LCB5KSB7XFxuICAgIGNvbnN0IGJpbmFyeVNlYXJjaCA9IChmdW5jdGlvbiBzZWFyY2goKSB7XFxuICAgICAgbGV0IG1heEluZGV4O1xcbiAgICAgIGxldCBtaW5JbmRleDtcXG4gICAgICBsZXQgZ3Vlc3M7XFxuICAgICAgcmV0dXJuIChhcnJheSwgdmFsKSA9PiB7XFxuICAgICAgICBtaW5JbmRleCA9IC0xO1xcbiAgICAgICAgbWF4SW5kZXggPSBhcnJheS5sZW5ndGg7XFxuICAgICAgICB3aGlsZSAobWF4SW5kZXggLSBtaW5JbmRleCA+IDEpIHtcXG4gICAgICAgICAgZ3Vlc3MgPSBtYXhJbmRleCArIG1pbkluZGV4ID4+IDE7XFxuICAgICAgICAgIGlmIChhcnJheVtndWVzc10gPD0gdmFsKSB7XFxuICAgICAgICAgICAgbWluSW5kZXggPSBndWVzcztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBtYXhJbmRleCA9IGd1ZXNzO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XFxuICAgICAgfTtcXG4gICAgfSgpKTtcXG4gICAgdGhpcy54ID0geDtcXG4gICAgdGhpcy55ID0geTtcXG4gICAgdGhpcy5sYXN0SW5kZXggPSB4Lmxlbmd0aCAtIDE7XFxuICAgIC8vIEdpdmVuIGFuIHggdmFsdWUgKHgyKSwgcmV0dXJuIHRoZSBleHBlY3RlZCB5MiB2YWx1ZTpcXG4gICAgLy8gKHgxLHkxKSBpcyB0aGUga25vd24gcG9pbnQgYmVmb3JlIGdpdmVuIHZhbHVlLFxcbiAgICAvLyAoeDMseTMpIGlzIHRoZSBrbm93biBwb2ludCBhZnRlciBnaXZlbiB2YWx1ZS5cXG4gICAgbGV0IGkxO1xcbiAgICBsZXQgaTM7XFxuXFxuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh4Mikge1xcbiAgICAgIGlmICgheDIpIHJldHVybiAwO1xcblxcbiAgICAgIC8vIEdldCB0aGUgaW5kZXhlcyBvZiB4MSBhbmQgeDMgKHRoZSBhcnJheSBpbmRleGVzIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4geDIpOlxcbiAgICAgIGkzID0gYmluYXJ5U2VhcmNoKHRoaXMueCwgeDIpO1xcbiAgICAgIGkxID0gaTMgLSAxO1xcblxcbiAgICAgIC8vIFdlIGhhdmUgb3VyIGluZGV4ZXMgaTEgJiBpMywgc28gd2UgY2FuIGNhbGN1bGF0ZSBhbHJlYWR5OlxcbiAgICAgIC8vIHkyIDo9ICgoeDLiiJJ4MSkgw5cgKHkz4oiSeTEpKSDDtyAoeDPiiJJ4MSkgKyB5MVxcbiAgICAgIHJldHVybiAoKCh4MiAtIHRoaXMueFtpMV0pICogKHRoaXMueVtpM10gLSB0aGlzLnlbaTFdKSkgLyAodGhpcy54W2kzXSAtIHRoaXMueFtpMV0pKSArIHRoaXMueVtpMV07XFxuICAgIH07XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSxcXG4gIC8vIHh4eDogZm9yIG5vdyBpIHdpbGwganVzdCBzYXZlIG9uZSBzcGxpbmUgZnVuY3Rpb24gdG8gdG9cXG4gIGdldEludGVycG9sYXRlRnVuY3Rpb24oYykge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLnNwbGluZSA9IHN3aXBlci5wYXJhbXMubG9vcFxcbiAgICAgICAgPyBuZXcgQ29udHJvbGxlci5MaW5lYXJTcGxpbmUoc3dpcGVyLnNsaWRlc0dyaWQsIGMuc2xpZGVzR3JpZClcXG4gICAgICAgIDogbmV3IENvbnRyb2xsZXIuTGluZWFyU3BsaW5lKHN3aXBlci5zbmFwR3JpZCwgYy5zbmFwR3JpZCk7XFxuICAgIH1cXG4gIH0sXFxuICBzZXRUcmFuc2xhdGUoc2V0VHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgY29udHJvbGxlZCA9IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2w7XFxuICAgIGxldCBtdWx0aXBsaWVyO1xcbiAgICBsZXQgY29udHJvbGxlZFRyYW5zbGF0ZTtcXG4gICAgZnVuY3Rpb24gc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjKSB7XFxuICAgICAgLy8gdGhpcyB3aWxsIGNyZWF0ZSBhbiBJbnRlcnBvbGF0ZSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgc25hcEdyaWRzXFxuICAgICAgLy8geCBpcyB0aGUgR3JpZCBvZiB0aGUgc2Nyb2xsZWQgc2Nyb2xsZXIgYW5kIHkgd2lsbCBiZSB0aGUgY29udHJvbGxlZCBzY3JvbGxlclxcbiAgICAgIC8vIGl0IG1ha2VzIHNlbnNlIHRvIGNyZWF0ZSB0aGlzIG9ubHkgb25jZSBhbmQgcmVjYWxsIGl0IGZvciB0aGUgaW50ZXJwb2xhdGlvblxcbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBkb2VzIGEgbG90IG9mIHZhbHVlIGNhY2hpbmcgZm9yIHBlcmZvcm1hbmNlXFxuICAgICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZTtcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnc2xpZGUnKSB7XFxuICAgICAgICBzd2lwZXIuY29udHJvbGxlci5nZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGMpO1xcbiAgICAgICAgLy8gaSBhbSBub3Qgc3VyZSB3aHkgdGhlIHZhbHVlcyBoYXZlIHRvIGJlIG11bHRpcGxpY2F0ZWQgdGhpcyB3YXksIHRyaWVkIHRvIGludmVydCB0aGUgc25hcEdyaWRcXG4gICAgICAgIC8vIGJ1dCBpdCBkaWQgbm90IHdvcmsgb3V0XFxuICAgICAgICBjb250cm9sbGVkVHJhbnNsYXRlID0gLXN3aXBlci5jb250cm9sbGVyLnNwbGluZS5pbnRlcnBvbGF0ZSgtdHJhbnNsYXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFjb250cm9sbGVkVHJhbnNsYXRlIHx8IHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ2NvbnRhaW5lcicpIHtcXG4gICAgICAgIG11bHRpcGxpZXIgPSAoYy5tYXhUcmFuc2xhdGUoKSAtIGMubWluVHJhbnNsYXRlKCkpIC8gKHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XFxuICAgICAgICBjb250cm9sbGVkVHJhbnNsYXRlID0gKCh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogbXVsdGlwbGllcikgKyBjLm1pblRyYW5zbGF0ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmludmVyc2UpIHtcXG4gICAgICAgIGNvbnRyb2xsZWRUcmFuc2xhdGUgPSBjLm1heFRyYW5zbGF0ZSgpIC0gY29udHJvbGxlZFRyYW5zbGF0ZTtcXG4gICAgICB9XFxuICAgICAgYy51cGRhdGVQcm9ncmVzcyhjb250cm9sbGVkVHJhbnNsYXRlKTtcXG4gICAgICBjLnNldFRyYW5zbGF0ZShjb250cm9sbGVkVHJhbnNsYXRlLCBzd2lwZXIpO1xcbiAgICAgIGMudXBkYXRlQWN0aXZlSW5kZXgoKTtcXG4gICAgICBjLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcXG4gICAgfVxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sbGVkKSkge1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKGNvbnRyb2xsZWRbaV0gIT09IGJ5Q29udHJvbGxlciAmJiBjb250cm9sbGVkW2ldIGluc3RhbmNlb2YgU3dpcGVyKSB7XFxuICAgICAgICAgIHNldENvbnRyb2xsZWRUcmFuc2xhdGUoY29udHJvbGxlZFtpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZWQgaW5zdGFuY2VvZiBTd2lwZXIgJiYgYnlDb250cm9sbGVyICE9PSBjb250cm9sbGVkKSB7XFxuICAgICAgc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjb250cm9sbGVkKTtcXG4gICAgfVxcbiAgfSxcXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBjb250cm9sbGVkID0gc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbDtcXG4gICAgbGV0IGk7XFxuICAgIGZ1bmN0aW9uIHNldENvbnRyb2xsZWRUcmFuc2l0aW9uKGMpIHtcXG4gICAgICBjLnNldFRyYW5zaXRpb24oZHVyYXRpb24sIHN3aXBlcik7XFxuICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XFxuICAgICAgICBjLnRyYW5zaXRpb25TdGFydCgpO1xcbiAgICAgICAgaWYgKGMucGFyYW1zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xcbiAgICAgICAgICAgIGMudXBkYXRlQXV0b0hlaWdodCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGMuJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcXG4gICAgICAgICAgaWYgKCFjb250cm9sbGVkKSByZXR1cm47XFxuICAgICAgICAgIGlmIChjLnBhcmFtcy5sb29wICYmIHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ3NsaWRlJykge1xcbiAgICAgICAgICAgIGMubG9vcEZpeCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGMudHJhbnNpdGlvbkVuZCgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xsZWQpKSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRyb2xsZWQubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGlmIChjb250cm9sbGVkW2ldICE9PSBieUNvbnRyb2xsZXIgJiYgY29udHJvbGxlZFtpXSBpbnN0YW5jZW9mIFN3aXBlcikge1xcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNpdGlvbihjb250cm9sbGVkW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlZCBpbnN0YW5jZW9mIFN3aXBlciAmJiBieUNvbnRyb2xsZXIgIT09IGNvbnRyb2xsZWQpIHtcXG4gICAgICBzZXRDb250cm9sbGVkVHJhbnNpdGlvbihjb250cm9sbGVkKTtcXG4gICAgfVxcbiAgfSxcXG59O1xcbnZhciBDb250cm9sbGVyJDEgPSB7XFxuICBuYW1lOiAnY29udHJvbGxlcicsXFxuICBwYXJhbXM6IHtcXG4gICAgY29udHJvbGxlcjoge1xcbiAgICAgIGNvbnRyb2w6IHVuZGVmaW5lZCxcXG4gICAgICBpbnZlcnNlOiBmYWxzZSxcXG4gICAgICBieTogJ3NsaWRlJywgLy8gb3IgJ2NvbnRhaW5lcidcXG4gICAgfSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBjb250cm9sbGVyOiB7XFxuICAgICAgICBjb250cm9sOiBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCxcXG4gICAgICAgIGdldEludGVycG9sYXRlRnVuY3Rpb246IENvbnRyb2xsZXIuZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbi5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2xhdGU6IENvbnRyb2xsZXIuc2V0VHJhbnNsYXRlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHNldFRyYW5zaXRpb246IENvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXFxuICAgICAgfSxcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgdXBkYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XFxuICAgICAgaWYgKHN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xcbiAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gdW5kZWZpbmVkO1xcbiAgICAgICAgZGVsZXRlIHN3aXBlci5jb250cm9sbGVyLnNwbGluZTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHJlc2l6ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xcbiAgICAgIGlmIChzd2lwZXIuY29udHJvbGxlci5zcGxpbmUpIHtcXG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLnNwbGluZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBvYnNlcnZlclVwZGF0ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xcbiAgICAgIGlmIChzd2lwZXIuY29udHJvbGxlci5zcGxpbmUpIHtcXG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLnNwbGluZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXRUcmFuc2xhdGUodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XFxuICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbihkdXJhdGlvbiwgYnlDb250cm9sbGVyKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBhMTF5ID0ge1xcbiAgbWFrZUVsRm9jdXNhYmxlKCRlbCkge1xcbiAgICAkZWwuYXR0cigndGFiSW5kZXgnLCAnMCcpO1xcbiAgICByZXR1cm4gJGVsO1xcbiAgfSxcXG4gIG1ha2VFbE5vdEZvY3VzYWJsZSgkZWwpIHtcXG4gICAgJGVsLmF0dHIoJ3RhYkluZGV4JywgJy0xJyk7XFxuICAgIHJldHVybiAkZWw7XFxuICB9LFxcbiAgYWRkRWxSb2xlKCRlbCwgcm9sZSkge1xcbiAgICAkZWwuYXR0cigncm9sZScsIHJvbGUpO1xcbiAgICByZXR1cm4gJGVsO1xcbiAgfSxcXG4gIGFkZEVsTGFiZWwoJGVsLCBsYWJlbCkge1xcbiAgICAkZWwuYXR0cignYXJpYS1sYWJlbCcsIGxhYmVsKTtcXG4gICAgcmV0dXJuICRlbDtcXG4gIH0sXFxuICBkaXNhYmxlRWwoJGVsKSB7XFxuICAgICRlbC5hdHRyKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxuICAgIHJldHVybiAkZWw7XFxuICB9LFxcbiAgZW5hYmxlRWwoJGVsKSB7XFxuICAgICRlbC5hdHRyKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xcbiAgICByZXR1cm4gJGVsO1xcbiAgfSxcXG4gIG9uRW50ZXJLZXkoZSkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XFxuICAgIGlmIChlLmtleUNvZGUgIT09IDEzKSByZXR1cm47XFxuICAgIGNvbnN0ICR0YXJnZXRFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoZS50YXJnZXQpO1xcbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJG5leHRFbCAmJiAkdGFyZ2V0RWwuaXMoc3dpcGVyLm5hdmlnYXRpb24uJG5leHRFbCkpIHtcXG4gICAgICBpZiAoIShzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkpIHtcXG4gICAgICAgIHN3aXBlci5zbGlkZU5leHQoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgc3dpcGVyLmExMXkubm90aWZ5KHBhcmFtcy5sYXN0U2xpZGVNZXNzYWdlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3dpcGVyLmExMXkubm90aWZ5KHBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwgJiYgJHRhcmdldEVsLmlzKHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwpKSB7XFxuICAgICAgaWYgKCEoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3ApKSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcXG4gICAgICAgIHN3aXBlci5hMTF5Lm5vdGlmeShwYXJhbXMuZmlyc3RTbGlkZU1lc3NhZ2UpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2lwZXIuYTExeS5ub3RpZnkocGFyYW1zLnByZXZTbGlkZU1lc3NhZ2UpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgJHRhcmdldEVsLmlzKGAuJHtzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3N9YCkpIHtcXG4gICAgICAkdGFyZ2V0RWxbMF0uY2xpY2soKTtcXG4gICAgfVxcbiAgfSxcXG4gIG5vdGlmeShtZXNzYWdlKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHN3aXBlci5hMTF5LmxpdmVSZWdpb247XFxuICAgIGlmIChub3RpZmljYXRpb24ubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIG5vdGlmaWNhdGlvbi5odG1sKCcnKTtcXG4gICAgbm90aWZpY2F0aW9uLmh0bWwobWVzc2FnZSk7XFxuICB9LFxcbiAgdXBkYXRlTmF2aWdhdGlvbigpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG5cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCB8fCAhc3dpcGVyLm5hdmlnYXRpb24pIHJldHVybjtcXG4gICAgY29uc3QgeyAkbmV4dEVsLCAkcHJldkVsIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcXG5cXG4gICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZykge1xcbiAgICAgICAgc3dpcGVyLmExMXkuZGlzYWJsZUVsKCRwcmV2RWwpO1xcbiAgICAgICAgc3dpcGVyLmExMXkubWFrZUVsTm90Rm9jdXNhYmxlKCRwcmV2RWwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2lwZXIuYTExeS5lbmFibGVFbCgkcHJldkVsKTtcXG4gICAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkcHJldkVsKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgc3dpcGVyLmExMXkuZGlzYWJsZUVsKCRuZXh0RWwpO1xcbiAgICAgICAgc3dpcGVyLmExMXkubWFrZUVsTm90Rm9jdXNhYmxlKCRuZXh0RWwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2lwZXIuYTExeS5lbmFibGVFbCgkbmV4dEVsKTtcXG4gICAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkbmV4dEVsKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICB1cGRhdGVQYWdpbmF0aW9uKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XFxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgpIHtcXG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmVhY2goKGJ1bGxldEluZGV4LCBidWxsZXRFbCkgPT4ge1xcbiAgICAgICAgY29uc3QgJGJ1bGxldEVsID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShidWxsZXRFbCk7XFxuICAgICAgICBzd2lwZXIuYTExeS5tYWtlRWxGb2N1c2FibGUoJGJ1bGxldEVsKTtcXG4gICAgICAgIHN3aXBlci5hMTF5LmFkZEVsUm9sZSgkYnVsbGV0RWwsICdidXR0b24nKTtcXG4gICAgICAgIHN3aXBlci5hMTF5LmFkZEVsTGFiZWwoJGJ1bGxldEVsLCBwYXJhbXMucGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2UucmVwbGFjZSgvXFxcXHtcXFxce2luZGV4XFxcXH1cXFxcfS8sICRidWxsZXRFbC5pbmRleCgpICsgMSkpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9LFxcbiAgaW5pdCgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG5cXG4gICAgc3dpcGVyLiRlbC5hcHBlbmQoc3dpcGVyLmExMXkubGl2ZVJlZ2lvbik7XFxuXFxuICAgIC8vIE5hdmlnYXRpb25cXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5hMTF5O1xcbiAgICBsZXQgJG5leHRFbDtcXG4gICAgbGV0ICRwcmV2RWw7XFxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSB7XFxuICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwpIHtcXG4gICAgICAkcHJldkVsID0gc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbDtcXG4gICAgfVxcbiAgICBpZiAoJG5leHRFbCkge1xcbiAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkbmV4dEVsKTtcXG4gICAgICBzd2lwZXIuYTExeS5hZGRFbFJvbGUoJG5leHRFbCwgJ2J1dHRvbicpO1xcbiAgICAgIHN3aXBlci5hMTF5LmFkZEVsTGFiZWwoJG5leHRFbCwgcGFyYW1zLm5leHRTbGlkZU1lc3NhZ2UpO1xcbiAgICAgICRuZXh0RWwub24oJ2tleWRvd24nLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcXG4gICAgfVxcbiAgICBpZiAoJHByZXZFbCkge1xcbiAgICAgIHN3aXBlci5hMTF5Lm1ha2VFbEZvY3VzYWJsZSgkcHJldkVsKTtcXG4gICAgICBzd2lwZXIuYTExeS5hZGRFbFJvbGUoJHByZXZFbCwgJ2J1dHRvbicpO1xcbiAgICAgIHN3aXBlci5hMTF5LmFkZEVsTGFiZWwoJHByZXZFbCwgcGFyYW1zLnByZXZTbGlkZU1lc3NhZ2UpO1xcbiAgICAgICRwcmV2RWwub24oJ2tleWRvd24nLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcXG4gICAgfVxcblxcbiAgICAvLyBQYWdpbmF0aW9uXFxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgpIHtcXG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi4kZWwub24oJ2tleWRvd24nLCBgLiR7c3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzfWAsIHN3aXBlci5hMTF5Lm9uRW50ZXJLZXkpO1xcbiAgICB9XFxuICB9LFxcbiAgZGVzdHJveSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHN3aXBlci5hMTF5LmxpdmVSZWdpb24gJiYgc3dpcGVyLmExMXkubGl2ZVJlZ2lvbi5sZW5ndGggPiAwKSBzd2lwZXIuYTExeS5saXZlUmVnaW9uLnJlbW92ZSgpO1xcblxcbiAgICBsZXQgJG5leHRFbDtcXG4gICAgbGV0ICRwcmV2RWw7XFxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSB7XFxuICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwpIHtcXG4gICAgICAkcHJldkVsID0gc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbDtcXG4gICAgfVxcbiAgICBpZiAoJG5leHRFbCkge1xcbiAgICAgICRuZXh0RWwub2ZmKCdrZXlkb3duJywgc3dpcGVyLmExMXkub25FbnRlcktleSk7XFxuICAgIH1cXG4gICAgaWYgKCRwcmV2RWwpIHtcXG4gICAgICAkcHJldkVsLm9mZigna2V5ZG93bicsIHN3aXBlci5hMTF5Lm9uRW50ZXJLZXkpO1xcbiAgICB9XFxuXFxuICAgIC8vIFBhZ2luYXRpb25cXG4gICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCkge1xcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5vZmYoJ2tleWRvd24nLCBgLiR7c3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzfWAsIHN3aXBlci5hMTF5Lm9uRW50ZXJLZXkpO1xcbiAgICB9XFxuICB9LFxcbn07XFxudmFyIEExMXkgPSB7XFxuICBuYW1lOiAnYTExeScsXFxuICBwYXJhbXM6IHtcXG4gICAgYTExeToge1xcbiAgICAgIGVuYWJsZWQ6IHRydWUsXFxuICAgICAgbm90aWZpY2F0aW9uQ2xhc3M6ICdzd2lwZXItbm90aWZpY2F0aW9uJyxcXG4gICAgICBwcmV2U2xpZGVNZXNzYWdlOiAnUHJldmlvdXMgc2xpZGUnLFxcbiAgICAgIG5leHRTbGlkZU1lc3NhZ2U6ICdOZXh0IHNsaWRlJyxcXG4gICAgICBmaXJzdFNsaWRlTWVzc2FnZTogJ1RoaXMgaXMgdGhlIGZpcnN0IHNsaWRlJyxcXG4gICAgICBsYXN0U2xpZGVNZXNzYWdlOiAnVGhpcyBpcyB0aGUgbGFzdCBzbGlkZScsXFxuICAgICAgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6ICdHbyB0byBzbGlkZSB7e2luZGV4fX0nLFxcbiAgICB9LFxcbiAgfSxcXG4gIGNyZWF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xcbiAgICAgIGExMXk6IHtcXG4gICAgICAgIGxpdmVSZWdpb246IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYDxzcGFuIGNsYXNzPVxcXCIke3N3aXBlci5wYXJhbXMuYTExeS5ub3RpZmljYXRpb25DbGFzc31cXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCI+PC9zcGFuPmApLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgICBPYmplY3Qua2V5cyhhMTF5KS5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XFxuICAgICAgc3dpcGVyLmExMXlbbWV0aG9kTmFtZV0gPSBhMTF5W21ldGhvZE5hbWVdLmJpbmQoc3dpcGVyKTtcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgaW5pdCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIuYTExeS5pbml0KCk7XFxuICAgICAgc3dpcGVyLmExMXkudXBkYXRlTmF2aWdhdGlvbigpO1xcbiAgICB9LFxcbiAgICB0b0VkZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XFxuICAgICAgc3dpcGVyLmExMXkudXBkYXRlTmF2aWdhdGlvbigpO1xcbiAgICB9LFxcbiAgICBmcm9tRWRnZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcXG4gICAgICBzd2lwZXIuYTExeS51cGRhdGVOYXZpZ2F0aW9uKCk7XFxuICAgIH0sXFxuICAgIHBhZ2luYXRpb25VcGRhdGUoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XFxuICAgICAgc3dpcGVyLmExMXkudXBkYXRlUGFnaW5hdGlvbigpO1xcbiAgICB9LFxcbiAgICBkZXN0cm95KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5hMTF5LmRlc3Ryb3koKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBIaXN0b3J5ID0ge1xcbiAgaW5pdCgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmhpc3RvcnkpIHJldHVybjtcXG4gICAgaWYgKCFzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmhpc3RvcnkgfHwgIXNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uaGlzdG9yeS5wdXNoU3RhdGUpIHtcXG4gICAgICBzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCA9IGZhbHNlO1xcbiAgICAgIHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCA9IHRydWU7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnN0IGhpc3RvcnkgPSBzd2lwZXIuaGlzdG9yeTtcXG4gICAgaGlzdG9yeS5pbml0aWFsaXplZCA9IHRydWU7XFxuICAgIGhpc3RvcnkucGF0aHMgPSBIaXN0b3J5LmdldFBhdGhWYWx1ZXMoKTtcXG4gICAgaWYgKCFoaXN0b3J5LnBhdGhzLmtleSAmJiAhaGlzdG9yeS5wYXRocy52YWx1ZSkgcmV0dXJuO1xcbiAgICBoaXN0b3J5LnNjcm9sbFRvU2xpZGUoMCwgaGlzdG9yeS5wYXRocy52YWx1ZSwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcXG4gICAgICBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgc3dpcGVyLmhpc3Rvcnkuc2V0SGlzdG9yeVBvcFN0YXRlKTtcXG4gICAgfVxcbiAgfSxcXG4gIGRlc3Ryb3koKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBzd2lwZXIuaGlzdG9yeS5zZXRIaXN0b3J5UG9wU3RhdGUpO1xcbiAgICB9XFxuICB9LFxcbiAgc2V0SGlzdG9yeVBvcFN0YXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBzd2lwZXIuaGlzdG9yeS5wYXRocyA9IEhpc3RvcnkuZ2V0UGF0aFZhbHVlcygpO1xcbiAgICBzd2lwZXIuaGlzdG9yeS5zY3JvbGxUb1NsaWRlKHN3aXBlci5wYXJhbXMuc3BlZWQsIHN3aXBlci5oaXN0b3J5LnBhdGhzLnZhbHVlLCBmYWxzZSk7XFxuICB9LFxcbiAgZ2V0UGF0aFZhbHVlcygpIHtcXG4gICAgY29uc3QgcGF0aEFycmF5ID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5sb2NhdGlvbi5wYXRobmFtZS5zbGljZSgxKS5zcGxpdCgnLycpLmZpbHRlcigocGFydCkgPT4gcGFydCAhPT0gJycpO1xcbiAgICBjb25zdCB0b3RhbCA9IHBhdGhBcnJheS5sZW5ndGg7XFxuICAgIGNvbnN0IGtleSA9IHBhdGhBcnJheVt0b3RhbCAtIDJdO1xcbiAgICBjb25zdCB2YWx1ZSA9IHBhdGhBcnJheVt0b3RhbCAtIDFdO1xcbiAgICByZXR1cm4geyBrZXksIHZhbHVlIH07XFxuICB9LFxcbiAgc2V0SGlzdG9yeShrZXksIGluZGV4KSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLmhpc3RvcnkuaW5pdGlhbGl6ZWQgfHwgIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSByZXR1cm47XFxuICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5lcShpbmRleCk7XFxuICAgIGxldCB2YWx1ZSA9IEhpc3Rvcnkuc2x1Z2lmeShzbGlkZS5hdHRyKCdkYXRhLWhpc3RvcnknKSk7XFxuICAgIGlmICghc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5sb2NhdGlvbi5wYXRobmFtZS5pbmNsdWRlcyhrZXkpKSB7XFxuICAgICAgdmFsdWUgPSBgJHtrZXl9LyR7dmFsdWV9YDtcXG4gICAgfVxcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmhpc3Rvcnkuc3RhdGU7XFxuICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLnZhbHVlID09PSB2YWx1ZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xcbiAgICAgIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyB2YWx1ZSB9LCBudWxsLCB2YWx1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5oaXN0b3J5LnB1c2hTdGF0ZSh7IHZhbHVlIH0sIG51bGwsIHZhbHVlKTtcXG4gICAgfVxcbiAgfSxcXG4gIHNsdWdpZnkodGV4dCkge1xcbiAgICByZXR1cm4gdGV4dC50b1N0cmluZygpXFxuICAgICAgLnJlcGxhY2UoL1xcXFxzKy9nLCAnLScpXFxuICAgICAgLnJlcGxhY2UoL1teXFxcXHctXSsvZywgJycpXFxuICAgICAgLnJlcGxhY2UoLy0tKy9nLCAnLScpXFxuICAgICAgLnJlcGxhY2UoL14tKy8sICcnKVxcbiAgICAgIC5yZXBsYWNlKC8tKyQvLCAnJyk7XFxuICB9LFxcbiAgc2Nyb2xsVG9TbGlkZShzcGVlZCwgdmFsdWUsIHJ1bkNhbGxiYWNrcykge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAodmFsdWUpIHtcXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xcbiAgICAgICAgY29uc3Qgc2xpZGVIaXN0b3J5ID0gSGlzdG9yeS5zbHVnaWZ5KHNsaWRlLmF0dHIoJ2RhdGEtaGlzdG9yeScpKTtcXG4gICAgICAgIGlmIChzbGlkZUhpc3RvcnkgPT09IHZhbHVlICYmICFzbGlkZS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGUuaW5kZXgoKTtcXG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzKTtcXG4gICAgfVxcbiAgfSxcXG59O1xcblxcbnZhciBIaXN0b3J5JDEgPSB7XFxuICBuYW1lOiAnaGlzdG9yeScsXFxuICBwYXJhbXM6IHtcXG4gICAgaGlzdG9yeToge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIHJlcGxhY2VTdGF0ZTogZmFsc2UsXFxuICAgICAga2V5OiAnc2xpZGVzJyxcXG4gICAgfSxcXG4gIH0sXFxuICBjcmVhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcXG4gICAgICBoaXN0b3J5OiB7XFxuICAgICAgICBpbml0OiBIaXN0b3J5LmluaXQuYmluZChzd2lwZXIpLFxcbiAgICAgICAgc2V0SGlzdG9yeTogSGlzdG9yeS5zZXRIaXN0b3J5LmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHNldEhpc3RvcnlQb3BTdGF0ZTogSGlzdG9yeS5zZXRIaXN0b3J5UG9wU3RhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgc2Nyb2xsVG9TbGlkZTogSGlzdG9yeS5zY3JvbGxUb1NsaWRlLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIGRlc3Ryb3k6IEhpc3RvcnkuZGVzdHJveS5iaW5kKHN3aXBlciksXFxuICAgICAgfSxcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgaW5pdCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmhpc3RvcnkuaW5pdCgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmhpc3RvcnkuZGVzdHJveSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdHJhbnNpdGlvbkVuZCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIuaGlzdG9yeS5pbml0aWFsaXplZCkge1xcbiAgICAgICAgc3dpcGVyLmhpc3Rvcnkuc2V0SGlzdG9yeShzd2lwZXIucGFyYW1zLmhpc3Rvcnkua2V5LCBzd2lwZXIuYWN0aXZlSW5kZXgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc2xpZGVDaGFuZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLmhpc3RvcnkuaW5pdGlhbGl6ZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XFxuICAgICAgICBzd2lwZXIuaGlzdG9yeS5zZXRIaXN0b3J5KHN3aXBlci5wYXJhbXMuaGlzdG9yeS5rZXksIHN3aXBlci5hY3RpdmVJbmRleCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgfSxcXG59O1xcblxcbmNvbnN0IEhhc2hOYXZpZ2F0aW9uID0ge1xcbiAgb25IYXNoQ2FuZ2UoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5lbWl0KCdoYXNoQ2hhbmdlJyk7XFxuICAgIGNvbnN0IG5ld0hhc2ggPSBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRvY3VtZW50XFxcIl0ubG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpO1xcbiAgICBjb25zdCBhY3RpdmVTbGlkZUhhc2ggPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCkuYXR0cignZGF0YS1oYXNoJyk7XFxuICAgIGlmIChuZXdIYXNoICE9PSBhY3RpdmVTbGlkZUhhc2gpIHtcXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtaGFzaD1cXFwiJHtuZXdIYXNofVxcXCJdYCkuaW5kZXgoKTtcXG4gICAgICBpZiAodHlwZW9mIG5ld0luZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5zbGlkZVRvKG5ld0luZGV4KTtcXG4gICAgfVxcbiAgfSxcXG4gIHNldEhhc2goKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGlmICghc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkIHx8ICFzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHJldHVybjtcXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24ucmVwbGFjZVN0YXRlICYmIHNzcl93aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwid2luZG93XFxcIl0uaGlzdG9yeSAmJiBzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdLmhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ3aW5kb3dcXFwiXS5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCAoYCMke3N3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KS5hdHRyKCdkYXRhLWhhc2gnKX1gIHx8ICcnKSk7XFxuICAgICAgc3dpcGVyLmVtaXQoJ2hhc2hTZXQnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25zdCBzbGlkZSA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcXG4gICAgICBjb25zdCBoYXNoID0gc2xpZGUuYXR0cignZGF0YS1oYXNoJykgfHwgc2xpZGUuYXR0cignZGF0YS1oaXN0b3J5Jyk7XFxuICAgICAgc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmxvY2F0aW9uLmhhc2ggPSBoYXNoIHx8ICcnO1xcbiAgICAgIHN3aXBlci5lbWl0KCdoYXNoU2V0Jyk7XFxuICAgIH1cXG4gIH0sXFxuICBpbml0KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCB8fCAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5ICYmIHN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSkgcmV0dXJuO1xcbiAgICBzd2lwZXIuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICBjb25zdCBoYXNoID0gc3NyX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkb2N1bWVudFxcXCJdLmxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKTtcXG4gICAgaWYgKGhhc2gpIHtcXG4gICAgICBjb25zdCBzcGVlZCA9IDA7XFxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5lcShpKTtcXG4gICAgICAgIGNvbnN0IHNsaWRlSGFzaCA9IHNsaWRlLmF0dHIoJ2RhdGEtaGFzaCcpIHx8IHNsaWRlLmF0dHIoJ2RhdGEtaGlzdG9yeScpO1xcbiAgICAgICAgaWYgKHNsaWRlSGFzaCA9PT0gaGFzaCAmJiAhc2xpZGUuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHNsaWRlLmluZGV4KCk7XFxuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4LCBzcGVlZCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsIHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlKSB7XFxuICAgICAgT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdKS5vbignaGFzaGNoYW5nZScsIHN3aXBlci5oYXNoTmF2aWdhdGlvbi5vbkhhc2hDYW5nZSk7XFxuICAgIH1cXG4gIH0sXFxuICBkZXN0cm95KCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlKSB7XFxuICAgICAgT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShzc3Jfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIndpbmRvd1xcXCJdKS5vZmYoJ2hhc2hjaGFuZ2UnLCBzd2lwZXIuaGFzaE5hdmlnYXRpb24ub25IYXNoQ2FuZ2UpO1xcbiAgICB9XFxuICB9LFxcbn07XFxudmFyIEhhc2hOYXZpZ2F0aW9uJDEgPSB7XFxuICBuYW1lOiAnaGFzaC1uYXZpZ2F0aW9uJyxcXG4gIHBhcmFtczoge1xcbiAgICBoYXNoTmF2aWdhdGlvbjoge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIHJlcGxhY2VTdGF0ZTogZmFsc2UsXFxuICAgICAgd2F0Y2hTdGF0ZTogZmFsc2UsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgaGFzaE5hdmlnYXRpb246IHtcXG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcXG4gICAgICAgIGluaXQ6IEhhc2hOYXZpZ2F0aW9uLmluaXQuYmluZChzd2lwZXIpLFxcbiAgICAgICAgZGVzdHJveTogSGFzaE5hdmlnYXRpb24uZGVzdHJveS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRIYXNoOiBIYXNoTmF2aWdhdGlvbi5zZXRIYXNoLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIG9uSGFzaENhbmdlOiBIYXNoTmF2aWdhdGlvbi5vbkhhc2hDYW5nZS5iaW5kKHN3aXBlciksXFxuICAgICAgfSxcXG4gICAgfSk7XFxuICB9LFxcbiAgb246IHtcXG4gICAgaW5pdCgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHtcXG4gICAgICAgIHN3aXBlci5oYXNoTmF2aWdhdGlvbi5pbml0KCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBkZXN0cm95KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmRlc3Ryb3koKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHRyYW5zaXRpb25FbmQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkKSB7XFxuICAgICAgICBzd2lwZXIuaGFzaE5hdmlnYXRpb24uc2V0SGFzaCgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc2xpZGVDaGFuZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xcbiAgICAgICAgc3dpcGVyLmhhc2hOYXZpZ2F0aW9uLnNldEhhc2goKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBcXFwib2ZmXFxcIiAqL1xcblxcbmNvbnN0IEF1dG9wbGF5ID0ge1xcbiAgcnVuKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCAkYWN0aXZlU2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcXG4gICAgbGV0IGRlbGF5ID0gc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcXG4gICAgaWYgKCRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLWF1dG9wbGF5JykpIHtcXG4gICAgICBkZWxheSA9ICRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLWF1dG9wbGF5JykgfHwgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcXG4gICAgfVxcbiAgICBjbGVhclRpbWVvdXQoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpO1xcbiAgICBzd2lwZXIuYXV0b3BsYXkudGltZW91dCA9IFV0aWxzLm5leHRUaWNrKCgpID0+IHtcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uKSB7XFxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XFxuICAgICAgICAgIHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzQmVnaW5uaW5nKSB7XFxuICAgICAgICAgIHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUpIHtcXG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XFxuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0VuZCkge1xcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XFxuICAgICAgICBzd2lwZXIuc2xpZGVUbygwLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcXG4gICAgICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheScpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XFxuICAgIH0sIGRlbGF5KTtcXG4gIH0sXFxuICBzdGFydCgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgaWYgKHR5cGVvZiBzd2lwZXIuYXV0b3BsYXkudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm4gZmFsc2U7XFxuICAgIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nID0gdHJ1ZTtcXG4gICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5U3RhcnQnKTtcXG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0sXFxuICBzdG9wKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm4gZmFsc2U7XFxuICAgIGlmICh0eXBlb2Ygc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XFxuXFxuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkudGltZW91dCkge1xcbiAgICAgIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkudGltZW91dCk7XFxuICAgICAgc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSBmYWxzZTtcXG4gICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5U3RvcCcpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0sXFxuICBwYXVzZShzcGVlZCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XFxuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSByZXR1cm47XFxuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkudGltZW91dCkgY2xlYXJUaW1lb3V0KHN3aXBlci5hdXRvcGxheS50aW1lb3V0KTtcXG4gICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IHRydWU7XFxuICAgIGlmIChzcGVlZCA9PT0gMCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbikge1xcbiAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcXG4gICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5hdXRvcGxheS5vblRyYW5zaXRpb25FbmQpO1xcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcXG4gICAgfVxcbiAgfSxcXG59O1xcblxcbnZhciBBdXRvcGxheSQxID0ge1xcbiAgbmFtZTogJ2F1dG9wbGF5JyxcXG4gIHBhcmFtczoge1xcbiAgICBhdXRvcGxheToge1xcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxcbiAgICAgIGRlbGF5OiAzMDAwLFxcbiAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiB0cnVlLFxcbiAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiB0cnVlLFxcbiAgICAgIHN0b3BPbkxhc3RTbGlkZTogZmFsc2UsXFxuICAgICAgcmV2ZXJzZURpcmVjdGlvbjogZmFsc2UsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgYXV0b3BsYXk6IHtcXG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcXG4gICAgICAgIHJ1bjogQXV0b3BsYXkucnVuLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHN0YXJ0OiBBdXRvcGxheS5zdGFydC5iaW5kKHN3aXBlciksXFxuICAgICAgICBzdG9wOiBBdXRvcGxheS5zdG9wLmJpbmQoc3dpcGVyKSxcXG4gICAgICAgIHBhdXNlOiBBdXRvcGxheS5wYXVzZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XFxuICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XFxuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcXG4gICAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XFxuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kKGUpIHtcXG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLiR3cmFwcGVyRWwpIHJldHVybjtcXG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XFxuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5hdXRvcGxheS5vblRyYW5zaXRpb25FbmQpO1xcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XFxuICAgICAgICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcXG4gICAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBpbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0YXJ0KCk7XFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgc3dpcGVyLmF1dG9wbGF5Lm9uVmlzaWJpbGl0eUNoYW5nZSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBiZWZvcmVUcmFuc2l0aW9uU3RhcnQoc3BlZWQsIGludGVybmFsKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcXG4gICAgICAgIGlmIChpbnRlcm5hbCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2Uoc3BlZWQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNsaWRlckZpcnN0TW92ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcXG4gICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdG91Y2hFbmQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgJiYgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcXG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5ydW4oKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGRlc3Ryb3koKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcXG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XFxuICAgICAgfVxcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBzd2lwZXIuYXV0b3BsYXkub25WaXNpYmlsaXR5Q2hhbmdlKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBGYWRlID0ge1xcbiAgc2V0VHJhbnNsYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB7IHNsaWRlcyB9ID0gc3dpcGVyO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGNvbnN0ICRzbGlkZUVsID0gc3dpcGVyLnNsaWRlcy5lcShpKTtcXG4gICAgICBjb25zdCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcXG4gICAgICBsZXQgdHggPSAtb2Zmc2V0O1xcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB0eCAtPSBzd2lwZXIudHJhbnNsYXRlO1xcbiAgICAgIGxldCB0eSA9IDA7XFxuICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgICAgIHR5ID0gdHg7XFxuICAgICAgICB0eCA9IDA7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHNsaWRlT3BhY2l0eSA9IHN3aXBlci5wYXJhbXMuZmFkZUVmZmVjdC5jcm9zc0ZhZGVcXG4gICAgICAgID8gTWF0aC5tYXgoMSAtIE1hdGguYWJzKCRzbGlkZUVsWzBdLnByb2dyZXNzKSwgMClcXG4gICAgICAgIDogMSArIE1hdGgubWluKE1hdGgubWF4KCRzbGlkZUVsWzBdLnByb2dyZXNzLCAtMSksIDApO1xcbiAgICAgICRzbGlkZUVsXFxuICAgICAgICAuY3NzKHtcXG4gICAgICAgICAgb3BhY2l0eTogc2xpZGVPcGFjaXR5LFxcbiAgICAgICAgfSlcXG4gICAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsIDBweClgKTtcXG4gICAgfVxcbiAgfSxcXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyBzbGlkZXMsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gICAgc2xpZGVzLnRyYW5zaXRpb24oZHVyYXRpb24pO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIGR1cmF0aW9uICE9PSAwKSB7XFxuICAgICAgbGV0IGV2ZW50VHJpZ2dlcmVkID0gZmFsc2U7XFxuICAgICAgc2xpZGVzLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xcbiAgICAgICAgaWYgKGV2ZW50VHJpZ2dlcmVkKSByZXR1cm47XFxuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XFxuICAgICAgICBldmVudFRyaWdnZXJlZCA9IHRydWU7XFxuICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XFxuICAgICAgICBjb25zdCB0cmlnZ2VyRXZlbnRzID0gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAkd3JhcHBlckVsLnRyaWdnZXIodHJpZ2dlckV2ZW50c1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sXFxufTtcXG5cXG52YXIgRWZmZWN0RmFkZSA9IHtcXG4gIG5hbWU6ICdlZmZlY3QtZmFkZScsXFxuICBwYXJhbXM6IHtcXG4gICAgZmFkZUVmZmVjdDoge1xcbiAgICAgIGNyb3NzRmFkZTogZmFsc2UsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgZmFkZUVmZmVjdDoge1xcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBGYWRlLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBGYWRlLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGJlZm9yZUluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmYWRlJykgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWZhZGVgKTtcXG4gICAgICBjb25zdCBvdmVyd3JpdGVQYXJhbXMgPSB7XFxuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxcbiAgICAgICAgc2xpZGVzUGVyQ29sdW1uOiAxLFxcbiAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxcbiAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxcbiAgICAgICAgdmlydHVhbFRyYW5zbGF0ZTogdHJ1ZSxcXG4gICAgICB9O1xcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIub3JpZ2luYWxQYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2ZhZGUnKSByZXR1cm47XFxuICAgICAgc3dpcGVyLmZhZGVFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2ZhZGUnKSByZXR1cm47XFxuICAgICAgc3dpcGVyLmZhZGVFZmZlY3Quc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICAgIH0sXFxuICB9LFxcbn07XFxuXFxuY29uc3QgQ3ViZSA9IHtcXG4gIHNldFRyYW5zbGF0ZSgpIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3Qge1xcbiAgICAgICRlbCwgJHdyYXBwZXJFbCwgc2xpZGVzLCB3aWR0aDogc3dpcGVyV2lkdGgsIGhlaWdodDogc3dpcGVySGVpZ2h0LCBydGxUcmFuc2xhdGU6IHJ0bCwgc2l6ZTogc3dpcGVyU2l6ZSxcXG4gICAgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jdWJlRWZmZWN0O1xcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XFxuICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xcbiAgICBsZXQgd3JhcHBlclJvdGF0ZSA9IDA7XFxuICAgIGxldCAkY3ViZVNoYWRvd0VsO1xcbiAgICBpZiAocGFyYW1zLnNoYWRvdykge1xcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcXG4gICAgICAgICRjdWJlU2hhZG93RWwgPSAkd3JhcHBlckVsLmZpbmQoJy5zd2lwZXItY3ViZS1zaGFkb3cnKTtcXG4gICAgICAgIGlmICgkY3ViZVNoYWRvd0VsLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAkY3ViZVNoYWRvd0VsID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKSgnPGRpdiBjbGFzcz1cXFwic3dpcGVyLWN1YmUtc2hhZG93XFxcIj48L2Rpdj4nKTtcXG4gICAgICAgICAgJHdyYXBwZXJFbC5hcHBlbmQoJGN1YmVTaGFkb3dFbCk7XFxuICAgICAgICB9XFxuICAgICAgICAkY3ViZVNoYWRvd0VsLmNzcyh7IGhlaWdodDogYCR7c3dpcGVyV2lkdGh9cHhgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAkY3ViZVNoYWRvd0VsID0gJGVsLmZpbmQoJy5zd2lwZXItY3ViZS1zaGFkb3cnKTtcXG4gICAgICAgIGlmICgkY3ViZVNoYWRvd0VsLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAkY3ViZVNoYWRvd0VsID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKSgnPGRpdiBjbGFzcz1cXFwic3dpcGVyLWN1YmUtc2hhZG93XFxcIj48L2Rpdj4nKTtcXG4gICAgICAgICAgJGVsLmFwcGVuZCgkY3ViZVNoYWRvd0VsKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcXG4gICAgICBsZXQgc2xpZGVJbmRleCA9IGk7XFxuICAgICAgaWYgKGlzVmlydHVhbCkge1xcbiAgICAgICAgc2xpZGVJbmRleCA9IHBhcnNlSW50KCRzbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcXG4gICAgICB9XFxuICAgICAgbGV0IHNsaWRlQW5nbGUgPSBzbGlkZUluZGV4ICogOTA7XFxuICAgICAgbGV0IHJvdW5kID0gTWF0aC5mbG9vcihzbGlkZUFuZ2xlIC8gMzYwKTtcXG4gICAgICBpZiAocnRsKSB7XFxuICAgICAgICBzbGlkZUFuZ2xlID0gLXNsaWRlQW5nbGU7XFxuICAgICAgICByb3VuZCA9IE1hdGguZmxvb3IoLXNsaWRlQW5nbGUgLyAzNjApO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCRzbGlkZUVsWzBdLnByb2dyZXNzLCAxKSwgLTEpO1xcbiAgICAgIGxldCB0eCA9IDA7XFxuICAgICAgbGV0IHR5ID0gMDtcXG4gICAgICBsZXQgdHogPSAwO1xcbiAgICAgIGlmIChzbGlkZUluZGV4ICUgNCA9PT0gMCkge1xcbiAgICAgICAgdHggPSAtcm91bmQgKiA0ICogc3dpcGVyU2l6ZTtcXG4gICAgICAgIHR6ID0gMDtcXG4gICAgICB9IGVsc2UgaWYgKChzbGlkZUluZGV4IC0gMSkgJSA0ID09PSAwKSB7XFxuICAgICAgICB0eCA9IDA7XFxuICAgICAgICB0eiA9IC1yb3VuZCAqIDQgKiBzd2lwZXJTaXplO1xcbiAgICAgIH0gZWxzZSBpZiAoKHNsaWRlSW5kZXggLSAyKSAlIDQgPT09IDApIHtcXG4gICAgICAgIHR4ID0gc3dpcGVyU2l6ZSArIChyb3VuZCAqIDQgKiBzd2lwZXJTaXplKTtcXG4gICAgICAgIHR6ID0gc3dpcGVyU2l6ZTtcXG4gICAgICB9IGVsc2UgaWYgKChzbGlkZUluZGV4IC0gMykgJSA0ID09PSAwKSB7XFxuICAgICAgICB0eCA9IC1zd2lwZXJTaXplO1xcbiAgICAgICAgdHogPSAoMyAqIHN3aXBlclNpemUpICsgKHN3aXBlclNpemUgKiA0ICogcm91bmQpO1xcbiAgICAgIH1cXG4gICAgICBpZiAocnRsKSB7XFxuICAgICAgICB0eCA9IC10eDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpc0hvcml6b250YWwpIHtcXG4gICAgICAgIHR5ID0gdHg7XFxuICAgICAgICB0eCA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGByb3RhdGVYKCR7aXNIb3Jpem9udGFsID8gMCA6IC1zbGlkZUFuZ2xlfWRlZykgcm90YXRlWSgke2lzSG9yaXpvbnRhbCA/IHNsaWRlQW5nbGUgOiAwfWRlZykgdHJhbnNsYXRlM2QoJHt0eH1weCwgJHt0eX1weCwgJHt0en1weClgO1xcbiAgICAgIGlmIChwcm9ncmVzcyA8PSAxICYmIHByb2dyZXNzID4gLTEpIHtcXG4gICAgICAgIHdyYXBwZXJSb3RhdGUgPSAoc2xpZGVJbmRleCAqIDkwKSArIChwcm9ncmVzcyAqIDkwKTtcXG4gICAgICAgIGlmIChydGwpIHdyYXBwZXJSb3RhdGUgPSAoLXNsaWRlSW5kZXggKiA5MCkgLSAocHJvZ3Jlc3MgKiA5MCk7XFxuICAgICAgfVxcbiAgICAgICRzbGlkZUVsLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xcbiAgICAgIGlmIChwYXJhbXMuc2xpZGVTaGFkb3dzKSB7XFxuICAgICAgICAvLyBTZXQgc2hhZG93c1xcbiAgICAgICAgbGV0IHNoYWRvd0JlZm9yZSA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCcpO1xcbiAgICAgICAgbGV0IHNoYWRvd0FmdGVyID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbScpO1xcbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgc2hhZG93QmVmb3JlID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShgPGRpdiBjbGFzcz1cXFwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke2lzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnfVxcXCI+PC9kaXY+YCk7XFxuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZChzaGFkb3dCZWZvcmUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICBzaGFkb3dBZnRlciA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYDxkaXYgY2xhc3M9XFxcInN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAncmlnaHQnIDogJ2JvdHRvbSd9XFxcIj48L2Rpdj5gKTtcXG4gICAgICAgICAgJHNsaWRlRWwuYXBwZW5kKHNoYWRvd0FmdGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzaGFkb3dCZWZvcmUubGVuZ3RoKSBzaGFkb3dCZWZvcmVbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1wcm9ncmVzcywgMCk7XFxuICAgICAgICBpZiAoc2hhZG93QWZ0ZXIubGVuZ3RoKSBzaGFkb3dBZnRlclswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgocHJvZ3Jlc3MsIDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAkd3JhcHBlckVsLmNzcyh7XFxuICAgICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcXG4gICAgICAnLW1vei10cmFuc2Zvcm0tb3JpZ2luJzogYDUwJSA1MCUgLSR7c3dpcGVyU2l6ZSAvIDJ9cHhgLFxcbiAgICAgICctbXMtdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcXG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcXG4gICAgfSk7XFxuXFxuICAgIGlmIChwYXJhbXMuc2hhZG93KSB7XFxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xcbiAgICAgICAgJGN1YmVTaGFkb3dFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHsoc3dpcGVyV2lkdGggLyAyKSArIHBhcmFtcy5zaGFkb3dPZmZzZXR9cHgsICR7LXN3aXBlcldpZHRoIC8gMn1weCkgcm90YXRlWCg5MGRlZykgcm90YXRlWigwZGVnKSBzY2FsZSgke3BhcmFtcy5zaGFkb3dTY2FsZX0pYCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnN0IHNoYWRvd0FuZ2xlID0gTWF0aC5hYnMod3JhcHBlclJvdGF0ZSkgLSAoTWF0aC5mbG9vcihNYXRoLmFicyh3cmFwcGVyUm90YXRlKSAvIDkwKSAqIDkwKTtcXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAxLjUgLSAoXFxuICAgICAgICAgIChNYXRoLnNpbigoc2hhZG93QW5nbGUgKiAyICogTWF0aC5QSSkgLyAzNjApIC8gMilcXG4gICAgICAgICAgKyAoTWF0aC5jb3MoKHNoYWRvd0FuZ2xlICogMiAqIE1hdGguUEkpIC8gMzYwKSAvIDIpXFxuICAgICAgICApO1xcbiAgICAgICAgY29uc3Qgc2NhbGUxID0gcGFyYW1zLnNoYWRvd1NjYWxlO1xcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gcGFyYW1zLnNoYWRvd1NjYWxlIC8gbXVsdGlwbGllcjtcXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcmFtcy5zaGFkb3dPZmZzZXQ7XFxuICAgICAgICAkY3ViZVNoYWRvd0VsLnRyYW5zZm9ybShgc2NhbGUzZCgke3NjYWxlMX0sIDEsICR7c2NhbGUyfSkgdHJhbnNsYXRlM2QoMHB4LCAkeyhzd2lwZXJIZWlnaHQgLyAyKSArIG9mZnNldH1weCwgJHstc3dpcGVySGVpZ2h0IC8gMiAvIHNjYWxlMn1weCkgcm90YXRlWCgtOTBkZWcpYCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNvbnN0IHpGYWN0b3IgPSAoQnJvd3Nlci5pc1NhZmFyaSB8fCBCcm93c2VyLmlzV2ViVmlldykgPyAoLXN3aXBlclNpemUgLyAyKSA6IDA7XFxuICAgICR3cmFwcGVyRWxcXG4gICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsMCwke3pGYWN0b3J9cHgpIHJvdGF0ZVgoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAwIDogd3JhcHBlclJvdGF0ZX1kZWcpIHJvdGF0ZVkoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAtd3JhcHBlclJvdGF0ZSA6IDB9ZGVnKWApO1xcbiAgfSxcXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgY29uc3QgeyAkZWwsIHNsaWRlcyB9ID0gc3dpcGVyO1xcbiAgICBzbGlkZXNcXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbilcXG4gICAgICAuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JylcXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmICFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcXG4gICAgICAkZWwuZmluZCgnLnN3aXBlci1jdWJlLXNoYWRvdycpLnRyYW5zaXRpb24oZHVyYXRpb24pO1xcbiAgICB9XFxuICB9LFxcbn07XFxuXFxudmFyIEVmZmVjdEN1YmUgPSB7XFxuICBuYW1lOiAnZWZmZWN0LWN1YmUnLFxcbiAgcGFyYW1zOiB7XFxuICAgIGN1YmVFZmZlY3Q6IHtcXG4gICAgICBzbGlkZVNoYWRvd3M6IHRydWUsXFxuICAgICAgc2hhZG93OiB0cnVlLFxcbiAgICAgIHNoYWRvd09mZnNldDogMjAsXFxuICAgICAgc2hhZG93U2NhbGU6IDAuOTQsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgY3ViZUVmZmVjdDoge1xcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBDdWJlLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBDdWJlLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGJlZm9yZUluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjdWJlJykgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWN1YmVgKTtcXG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApO1xcbiAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtcyA9IHtcXG4gICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXFxuICAgICAgICBzbGlkZXNQZXJDb2x1bW46IDEsXFxuICAgICAgICBzbGlkZXNQZXJHcm91cDogMSxcXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXFxuICAgICAgICByZXNpc3RhbmNlUmF0aW86IDAsXFxuICAgICAgICBzcGFjZUJldHdlZW46IDAsXFxuICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXFxuICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlLFxcbiAgICAgIH07XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNsYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY3ViZScpIHJldHVybjtcXG4gICAgICBzd2lwZXIuY3ViZUVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY3ViZScpIHJldHVybjtcXG4gICAgICBzd2lwZXIuY3ViZUVmZmVjdC5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBGbGlwID0ge1xcbiAgc2V0VHJhbnNsYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB7IHNsaWRlcywgcnRsVHJhbnNsYXRlOiBydGwgfSA9IHN3aXBlcjtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcXG4gICAgICBsZXQgcHJvZ3Jlc3MgPSAkc2xpZGVFbFswXS5wcm9ncmVzcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24pIHtcXG4gICAgICAgIHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oJHNsaWRlRWxbMF0ucHJvZ3Jlc3MsIDEpLCAtMSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IG9mZnNldCA9ICRzbGlkZUVsWzBdLnN3aXBlclNsaWRlT2Zmc2V0O1xcbiAgICAgIGNvbnN0IHJvdGF0ZSA9IC0xODAgKiBwcm9ncmVzcztcXG4gICAgICBsZXQgcm90YXRlWSA9IHJvdGF0ZTtcXG4gICAgICBsZXQgcm90YXRlWCA9IDA7XFxuICAgICAgbGV0IHR4ID0gLW9mZnNldDtcXG4gICAgICBsZXQgdHkgPSAwO1xcbiAgICAgIGlmICghc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XFxuICAgICAgICB0eSA9IHR4O1xcbiAgICAgICAgdHggPSAwO1xcbiAgICAgICAgcm90YXRlWCA9IC1yb3RhdGVZO1xcbiAgICAgICAgcm90YXRlWSA9IDA7XFxuICAgICAgfSBlbHNlIGlmIChydGwpIHtcXG4gICAgICAgIHJvdGF0ZVkgPSAtcm90YXRlWTtcXG4gICAgICB9XFxuXFxuICAgICAgJHNsaWRlRWxbMF0uc3R5bGUuekluZGV4ID0gLU1hdGguYWJzKE1hdGgucm91bmQocHJvZ3Jlc3MpKSArIHNsaWRlcy5sZW5ndGg7XFxuXFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZmxpcEVmZmVjdC5zbGlkZVNoYWRvd3MpIHtcXG4gICAgICAgIC8vIFNldCBzaGFkb3dzXFxuICAgICAgICBsZXQgc2hhZG93QmVmb3JlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XFxuICAgICAgICBsZXQgc2hhZG93QWZ0ZXIgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XFxuICAgICAgICBpZiAoc2hhZG93QmVmb3JlLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICBzaGFkb3dCZWZvcmUgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGA8ZGl2IGNsYXNzPVxcXCJzd2lwZXItc2xpZGUtc2hhZG93LSR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCd9XFxcIj48L2Rpdj5gKTtcXG4gICAgICAgICAgJHNsaWRlRWwuYXBwZW5kKHNoYWRvd0JlZm9yZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoc2hhZG93QWZ0ZXIubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgIHNoYWRvd0FmdGVyID0gT2JqZWN0KGRvbTdfZGlzdF9kb203X21vZHVsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiJFxcXCJdKShgPGRpdiBjbGFzcz1cXFwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdyaWdodCcgOiAnYm90dG9tJ31cXFwiPjwvZGl2PmApO1xcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoc2hhZG93QWZ0ZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGgpIHNoYWRvd0JlZm9yZVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXByb2dyZXNzLCAwKTtcXG4gICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGgpIHNoYWRvd0FmdGVyWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChwcm9ncmVzcywgMCk7XFxuICAgICAgfVxcbiAgICAgICRzbGlkZUVsXFxuICAgICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAwcHgpIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKWApO1xcbiAgICB9XFxuICB9LFxcbiAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB7IHNsaWRlcywgYWN0aXZlSW5kZXgsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcXG4gICAgc2xpZGVzXFxuICAgICAgLnRyYW5zaXRpb24oZHVyYXRpb24pXFxuICAgICAgLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpXFxuICAgICAgLnRyYW5zaXRpb24oZHVyYXRpb24pO1xcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIGR1cmF0aW9uICE9PSAwKSB7XFxuICAgICAgbGV0IGV2ZW50VHJpZ2dlcmVkID0gZmFsc2U7XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgc2xpZGVzLmVxKGFjdGl2ZUluZGV4KS50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpIHtcXG4gICAgICAgIGlmIChldmVudFRyaWdnZXJlZCkgcmV0dXJuO1xcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xcbiAgICAgICAgLy8gaWYgKCEkKHRoaXMpLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzcykpIHJldHVybjtcXG4gICAgICAgIGV2ZW50VHJpZ2dlcmVkID0gdHJ1ZTtcXG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcXG4gICAgICAgIGNvbnN0IHRyaWdnZXJFdmVudHMgPSBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlnZ2VyRXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgICR3cmFwcGVyRWwudHJpZ2dlcih0cmlnZ2VyRXZlbnRzW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSxcXG59O1xcblxcbnZhciBFZmZlY3RGbGlwID0ge1xcbiAgbmFtZTogJ2VmZmVjdC1mbGlwJyxcXG4gIHBhcmFtczoge1xcbiAgICBmbGlwRWZmZWN0OiB7XFxuICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxcbiAgICAgIGxpbWl0Um90YXRpb246IHRydWUsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgZmxpcEVmZmVjdDoge1xcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBGbGlwLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBGbGlwLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGJlZm9yZUluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmbGlwJykgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWZsaXBgKTtcXG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApO1xcbiAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtcyA9IHtcXG4gICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXFxuICAgICAgICBzbGlkZXNQZXJDb2x1bW46IDEsXFxuICAgICAgICBzbGlkZXNQZXJHcm91cDogMSxcXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXFxuICAgICAgICBzcGFjZUJldHdlZW46IDAsXFxuICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlLFxcbiAgICAgIH07XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XFxuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5vcmlnaW5hbFBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNsYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnZmxpcCcpIHJldHVybjtcXG4gICAgICBzd2lwZXIuZmxpcEVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnZmxpcCcpIHJldHVybjtcXG4gICAgICBzd2lwZXIuZmxpcEVmZmVjdC5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcXG4gICAgfSxcXG4gIH0sXFxufTtcXG5cXG5jb25zdCBDb3ZlcmZsb3cgPSB7XFxuICBzZXRUcmFuc2xhdGUoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHtcXG4gICAgICB3aWR0aDogc3dpcGVyV2lkdGgsIGhlaWdodDogc3dpcGVySGVpZ2h0LCBzbGlkZXMsICR3cmFwcGVyRWwsIHNsaWRlc1NpemVzR3JpZCxcXG4gICAgfSA9IHN3aXBlcjtcXG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3Q7XFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcXG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3dpcGVyLnRyYW5zbGF0ZTtcXG4gICAgY29uc3QgY2VudGVyID0gaXNIb3Jpem9udGFsID8gLXRyYW5zZm9ybSArIChzd2lwZXJXaWR0aCAvIDIpIDogLXRyYW5zZm9ybSArIChzd2lwZXJIZWlnaHQgLyAyKTtcXG4gICAgY29uc3Qgcm90YXRlID0gaXNIb3Jpem9udGFsID8gcGFyYW1zLnJvdGF0ZSA6IC1wYXJhbXMucm90YXRlO1xcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBwYXJhbXMuZGVwdGg7XFxuICAgIC8vIEVhY2ggc2xpZGUgb2Zmc2V0IGZyb20gY2VudGVyXFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzbGlkZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcXG4gICAgICBjb25zdCBzbGlkZVNpemUgPSBzbGlkZXNTaXplc0dyaWRbaV07XFxuICAgICAgY29uc3Qgc2xpZGVPZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcXG4gICAgICBjb25zdCBvZmZzZXRNdWx0aXBsaWVyID0gKChjZW50ZXIgLSBzbGlkZU9mZnNldCAtIChzbGlkZVNpemUgLyAyKSkgLyBzbGlkZVNpemUpICogcGFyYW1zLm1vZGlmaWVyO1xcblxcbiAgICAgIGxldCByb3RhdGVZID0gaXNIb3Jpem9udGFsID8gcm90YXRlICogb2Zmc2V0TXVsdGlwbGllciA6IDA7XFxuICAgICAgbGV0IHJvdGF0ZVggPSBpc0hvcml6b250YWwgPyAwIDogcm90YXRlICogb2Zmc2V0TXVsdGlwbGllcjtcXG4gICAgICAvLyB2YXIgcm90YXRlWiA9IDBcXG4gICAgICBsZXQgdHJhbnNsYXRlWiA9IC10cmFuc2xhdGUgKiBNYXRoLmFicyhvZmZzZXRNdWx0aXBsaWVyKTtcXG5cXG4gICAgICBsZXQgc3RyZXRjaCA9IHBhcmFtcy5zdHJldGNoO1xcbiAgICAgIC8vIEFsbG93IHBlcmNlbnRhZ2UgdG8gbWFrZSBhIHJlbGF0aXZlIHN0cmV0Y2ggZm9yIHJlc3BvbnNpdmUgc2xpZGVyc1xcbiAgICAgIGlmICh0eXBlb2Ygc3RyZXRjaCA9PT0gJ3N0cmluZycgJiYgc3RyZXRjaC5pbmRleE9mKCclJykgIT09IC0xKSB7XFxuICAgICAgICBzdHJldGNoID0gKChwYXJzZUZsb2F0KHBhcmFtcy5zdHJldGNoKSAvIDEwMCkgKiBzbGlkZVNpemUpO1xcbiAgICAgIH1cXG4gICAgICBsZXQgdHJhbnNsYXRlWSA9IGlzSG9yaXpvbnRhbCA/IDAgOiBzdHJldGNoICogKG9mZnNldE11bHRpcGxpZXIpO1xcbiAgICAgIGxldCB0cmFuc2xhdGVYID0gaXNIb3Jpem9udGFsID8gc3RyZXRjaCAqIChvZmZzZXRNdWx0aXBsaWVyKSA6IDA7XFxuXFxuICAgICAgbGV0IHNjYWxlID0gMSAtICgxIC0gcGFyYW1zLnNjYWxlKSAqIE1hdGguYWJzKG9mZnNldE11bHRpcGxpZXIpO1xcblxcbiAgICAgIC8vIEZpeCBmb3IgdWx0cmEgc21hbGwgdmFsdWVzXFxuICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZVgpIDwgMC4wMDEpIHRyYW5zbGF0ZVggPSAwO1xcbiAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGVZKSA8IDAuMDAxKSB0cmFuc2xhdGVZID0gMDtcXG4gICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlWikgPCAwLjAwMSkgdHJhbnNsYXRlWiA9IDA7XFxuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0ZVkpIDwgMC4wMDEpIHJvdGF0ZVkgPSAwO1xcbiAgICAgIGlmIChNYXRoLmFicyhyb3RhdGVYKSA8IDAuMDAxKSByb3RhdGVYID0gMDtcXG4gICAgICBpZiAoTWF0aC5hYnMoc2NhbGUpIDwgMC4wMDEpIHNjYWxlID0gMDtcXG5cXG4gICAgICBjb25zdCBzbGlkZVRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVh9cHgsJHt0cmFuc2xhdGVZfXB4LCR7dHJhbnNsYXRlWn1weCkgIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKSBzY2FsZSgke3NjYWxlfSlgO1xcblxcbiAgICAgICRzbGlkZUVsLnRyYW5zZm9ybShzbGlkZVRyYW5zZm9ybSk7XFxuICAgICAgJHNsaWRlRWxbMF0uc3R5bGUuekluZGV4ID0gLU1hdGguYWJzKE1hdGgucm91bmQob2Zmc2V0TXVsdGlwbGllcikpICsgMTtcXG4gICAgICBpZiAocGFyYW1zLnNsaWRlU2hhZG93cykge1xcbiAgICAgICAgLy8gU2V0IHNoYWRvd3NcXG4gICAgICAgIGxldCAkc2hhZG93QmVmb3JlRWwgPSBpc0hvcml6b250YWwgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AnKTtcXG4gICAgICAgIGxldCAkc2hhZG93QWZ0ZXJFbCA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20nKTtcXG4gICAgICAgIGlmICgkc2hhZG93QmVmb3JlRWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICRzaGFkb3dCZWZvcmVFbCA9IE9iamVjdChkb203X2Rpc3RfZG9tN19tb2R1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIiRcXFwiXSkoYDxkaXYgY2xhc3M9XFxcInN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ31cXFwiPjwvZGl2PmApO1xcbiAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoJHNoYWRvd0JlZm9yZUVsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgkc2hhZG93QWZ0ZXJFbC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgJHNoYWRvd0FmdGVyRWwgPSBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGA8ZGl2IGNsYXNzPVxcXCJzd2lwZXItc2xpZGUtc2hhZG93LSR7aXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nfVxcXCI+PC9kaXY+YCk7XFxuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZCgkc2hhZG93QWZ0ZXJFbCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoJHNoYWRvd0JlZm9yZUVsLmxlbmd0aCkgJHNoYWRvd0JlZm9yZUVsWzBdLnN0eWxlLm9wYWNpdHkgPSBvZmZzZXRNdWx0aXBsaWVyID4gMCA/IG9mZnNldE11bHRpcGxpZXIgOiAwO1xcbiAgICAgICAgaWYgKCRzaGFkb3dBZnRlckVsLmxlbmd0aCkgJHNoYWRvd0FmdGVyRWxbMF0uc3R5bGUub3BhY2l0eSA9ICgtb2Zmc2V0TXVsdGlwbGllcikgPiAwID8gLW9mZnNldE11bHRpcGxpZXIgOiAwO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBTZXQgY29ycmVjdCBwZXJzcGVjdGl2ZSBmb3IgSUUxMFxcbiAgICBpZiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzIHx8IFN1cHBvcnQucHJlZml4ZWRQb2ludGVyRXZlbnRzKSB7XFxuICAgICAgY29uc3Qgd3MgPSAkd3JhcHBlckVsWzBdLnN0eWxlO1xcbiAgICAgIHdzLnBlcnNwZWN0aXZlT3JpZ2luID0gYCR7Y2VudGVyfXB4IDUwJWA7XFxuICAgIH1cXG4gIH0sXFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIHN3aXBlci5zbGlkZXNcXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbilcXG4gICAgICAuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JylcXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbik7XFxuICB9LFxcbn07XFxuXFxudmFyIEVmZmVjdENvdmVyZmxvdyA9IHtcXG4gIG5hbWU6ICdlZmZlY3QtY292ZXJmbG93JyxcXG4gIHBhcmFtczoge1xcbiAgICBjb3ZlcmZsb3dFZmZlY3Q6IHtcXG4gICAgICByb3RhdGU6IDUwLFxcbiAgICAgIHN0cmV0Y2g6IDAsXFxuICAgICAgZGVwdGg6IDEwMCxcXG4gICAgICBzY2FsZTogMSxcXG4gICAgICBtb2RpZmllcjogMSxcXG4gICAgICBzbGlkZVNoYWRvd3M6IHRydWUsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgY292ZXJmbG93RWZmZWN0OiB7XFxuICAgICAgICBzZXRUcmFuc2xhdGU6IENvdmVyZmxvdy5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgc2V0VHJhbnNpdGlvbjogQ292ZXJmbG93LnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxcbiAgICAgIH0sXFxuICAgIH0pO1xcbiAgfSxcXG4gIG9uOiB7XFxuICAgIGJlZm9yZUluaXQoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjb3ZlcmZsb3cnKSByZXR1cm47XFxuXFxuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Y292ZXJmbG93YCk7XFxuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcXG5cXG4gICAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xcbiAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcXG4gICAgfSxcXG4gICAgc2V0VHJhbnNsYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY292ZXJmbG93JykgcmV0dXJuO1xcbiAgICAgIHN3aXBlci5jb3ZlcmZsb3dFZmZlY3Quc2V0VHJhbnNsYXRlKCk7XFxuICAgIH0sXFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2NvdmVyZmxvdycpIHJldHVybjtcXG4gICAgICBzd2lwZXIuY292ZXJmbG93RWZmZWN0LnNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xcbiAgICB9LFxcbiAgfSxcXG59O1xcblxcbmNvbnN0IFRodW1icyA9IHtcXG4gIGluaXQoKSB7XFxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgIGNvbnN0IHsgdGh1bWJzOiB0aHVtYnNQYXJhbXMgfSA9IHN3aXBlci5wYXJhbXM7XFxuICAgIGNvbnN0IFN3aXBlckNsYXNzID0gc3dpcGVyLmNvbnN0cnVjdG9yO1xcbiAgICBpZiAodGh1bWJzUGFyYW1zLnN3aXBlciBpbnN0YW5jZW9mIFN3aXBlckNsYXNzKSB7XFxuICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXIgPSB0aHVtYnNQYXJhbXMuc3dpcGVyO1xcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIudGh1bWJzLnN3aXBlci5vcmlnaW5hbFBhcmFtcywge1xcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcXG4gICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxcbiAgICAgIH0pO1xcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIudGh1bWJzLnN3aXBlci5wYXJhbXMsIHtcXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXFxuICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh0aHVtYnNQYXJhbXMuc3dpcGVyKSkge1xcbiAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyID0gbmV3IFN3aXBlckNsYXNzKFV0aWxzLmV4dGVuZCh7fSwgdGh1bWJzUGFyYW1zLnN3aXBlciwge1xcbiAgICAgICAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiB0cnVlLFxcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcXG4gICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxcbiAgICAgIH0pKTtcXG4gICAgICBzd2lwZXIudGh1bWJzLnN3aXBlckNyZWF0ZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLnRodW1icy50aHVtYnNDb250YWluZXJDbGFzcyk7XFxuICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLm9uKCd0YXAnLCBzd2lwZXIudGh1bWJzLm9uVGh1bWJDbGljayk7XFxuICB9LFxcbiAgb25UaHVtYkNsaWNrKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcXG4gICAgaWYgKCF0aHVtYnNTd2lwZXIpIHJldHVybjtcXG4gICAgY29uc3QgY2xpY2tlZEluZGV4ID0gdGh1bWJzU3dpcGVyLmNsaWNrZWRJbmRleDtcXG4gICAgY29uc3QgY2xpY2tlZFNsaWRlID0gdGh1bWJzU3dpcGVyLmNsaWNrZWRTbGlkZTtcXG4gICAgaWYgKGNsaWNrZWRTbGlkZSAmJiBPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKGNsaWNrZWRTbGlkZSkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy50aHVtYnMuc2xpZGVUaHVtYkFjdGl2ZUNsYXNzKSkgcmV0dXJuO1xcbiAgICBpZiAodHlwZW9mIGNsaWNrZWRJbmRleCA9PT0gJ3VuZGVmaW5lZCcgfHwgY2xpY2tlZEluZGV4ID09PSBudWxsKSByZXR1cm47XFxuICAgIGxldCBzbGlkZVRvSW5kZXg7XFxuICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICBzbGlkZVRvSW5kZXggPSBwYXJzZUludChPYmplY3QoZG9tN19kaXN0X2RvbTdfbW9kdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCIkXFxcIl0pKHRodW1ic1N3aXBlci5jbGlja2VkU2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzbGlkZVRvSW5kZXggPSBjbGlja2VkSW5kZXg7XFxuICAgIH1cXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xcbiAgICAgIGxldCBjdXJyZW50SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XFxuICAgICAgaWYgKHN3aXBlci5zbGlkZXMuZXEoY3VycmVudEluZGV4KS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XFxuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgICAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0O1xcbiAgICAgICAgY3VycmVudEluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwcmV2SW5kZXggPSBzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkucHJldkFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke3NsaWRlVG9JbmRleH1cXFwiXWApLmVxKDApLmluZGV4KCk7XFxuICAgICAgY29uc3QgbmV4dEluZGV4ID0gc3dpcGVyLnNsaWRlcy5lcShjdXJyZW50SW5kZXgpLm5leHRBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFwiJHtzbGlkZVRvSW5kZXh9XFxcIl1gKS5lcSgwKS5pbmRleCgpO1xcbiAgICAgIGlmICh0eXBlb2YgcHJldkluZGV4ID09PSAndW5kZWZpbmVkJykgc2xpZGVUb0luZGV4ID0gbmV4dEluZGV4O1xcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZXh0SW5kZXggPT09ICd1bmRlZmluZWQnKSBzbGlkZVRvSW5kZXggPSBwcmV2SW5kZXg7XFxuICAgICAgZWxzZSBpZiAobmV4dEluZGV4IC0gY3VycmVudEluZGV4IDwgY3VycmVudEluZGV4IC0gcHJldkluZGV4KSBzbGlkZVRvSW5kZXggPSBuZXh0SW5kZXg7XFxuICAgICAgZWxzZSBzbGlkZVRvSW5kZXggPSBwcmV2SW5kZXg7XFxuICAgIH1cXG4gICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcXG4gIH0sXFxuICB1cGRhdGUoaW5pdGlhbCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcXG4gICAgaWYgKCF0aHVtYnNTd2lwZXIpIHJldHVybjtcXG5cXG4gICAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nXFxuICAgICAgPyB0aHVtYnNTd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKVxcbiAgICAgIDogdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xcblxcbiAgICBjb25zdCBhdXRvU2Nyb2xsT2Zmc2V0ID0gc3dpcGVyLnBhcmFtcy50aHVtYnMuYXV0b1Njcm9sbE9mZnNldDtcXG4gICAgY29uc3QgdXNlT2Zmc2V0ID0gYXV0b1Njcm9sbE9mZnNldCAmJiAhdGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wO1xcbiAgICBpZiAoc3dpcGVyLnJlYWxJbmRleCAhPT0gdGh1bWJzU3dpcGVyLnJlYWxJbmRleCB8fCB1c2VPZmZzZXQpIHtcXG4gICAgICBsZXQgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICAgIGxldCBuZXdUaHVtYnNJbmRleDtcXG4gICAgICBsZXQgZGlyZWN0aW9uO1xcbiAgICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3ApIHtcXG4gICAgICAgIGlmICh0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkuaGFzQ2xhc3ModGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xcbiAgICAgICAgICB0aHVtYnNTd2lwZXIubG9vcEZpeCgpO1xcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG4gICAgICAgICAgdGh1bWJzU3dpcGVyLl9jbGllbnRMZWZ0ID0gdGh1bWJzU3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcXG4gICAgICAgICAgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRmluZCBhY3R1YWwgdGh1bWJzIGluZGV4IHRvIHNsaWRlIHRvXFxuICAgICAgICBjb25zdCBwcmV2VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzXFxuICAgICAgICAgIC5lcShjdXJyZW50VGh1bWJzSW5kZXgpXFxuICAgICAgICAgIC5wcmV2QWxsKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XFxcIiR7c3dpcGVyLnJlYWxJbmRleH1cXFwiXWApLmVxKDApXFxuICAgICAgICAgIC5pbmRleCgpO1xcbiAgICAgICAgY29uc3QgbmV4dFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLnNsaWRlc1xcbiAgICAgICAgICAuZXEoY3VycmVudFRodW1ic0luZGV4KVxcbiAgICAgICAgICAubmV4dEFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVxcXCIke3N3aXBlci5yZWFsSW5kZXh9XFxcIl1gKS5lcSgwKVxcbiAgICAgICAgICAuaW5kZXgoKTtcXG4gICAgICAgIGlmICh0eXBlb2YgcHJldlRodW1ic0luZGV4ID09PSAndW5kZWZpbmVkJykgbmV3VGh1bWJzSW5kZXggPSBuZXh0VGh1bWJzSW5kZXg7XFxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmV4dFRodW1ic0luZGV4ID09PSAndW5kZWZpbmVkJykgbmV3VGh1bWJzSW5kZXggPSBwcmV2VGh1bWJzSW5kZXg7XFxuICAgICAgICBlbHNlIGlmIChuZXh0VGh1bWJzSW5kZXggLSBjdXJyZW50VGh1bWJzSW5kZXggPT09IGN1cnJlbnRUaHVtYnNJbmRleCAtIHByZXZUaHVtYnNJbmRleCkgbmV3VGh1bWJzSW5kZXggPSBjdXJyZW50VGh1bWJzSW5kZXg7XFxuICAgICAgICBlbHNlIGlmIChuZXh0VGh1bWJzSW5kZXggLSBjdXJyZW50VGh1bWJzSW5kZXggPCBjdXJyZW50VGh1bWJzSW5kZXggLSBwcmV2VGh1bWJzSW5kZXgpIG5ld1RodW1ic0luZGV4ID0gbmV4dFRodW1ic0luZGV4O1xcbiAgICAgICAgZWxzZSBuZXdUaHVtYnNJbmRleCA9IHByZXZUaHVtYnNJbmRleDtcXG4gICAgICAgIGRpcmVjdGlvbiA9IHN3aXBlci5hY3RpdmVJbmRleCA+IHN3aXBlci5wcmV2aW91c0luZGV4ID8gJ25leHQnIDogJ3ByZXYnO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuZXdUaHVtYnNJbmRleCA9IHN3aXBlci5yZWFsSW5kZXg7XFxuICAgICAgICBkaXJlY3Rpb24gPSBuZXdUaHVtYnNJbmRleCA+IHN3aXBlci5wcmV2aW91c0luZGV4ID8gJ25leHQnIDogJ3ByZXYnO1xcbiAgICAgIH1cXG4gICAgICBpZiAodXNlT2Zmc2V0KSB7XFxuICAgICAgICBuZXdUaHVtYnNJbmRleCArPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/IGF1dG9TY3JvbGxPZmZzZXQgOiAtMSAqIGF1dG9TY3JvbGxPZmZzZXQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aHVtYnNTd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMgJiYgdGh1bWJzU3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLmluZGV4T2YobmV3VGh1bWJzSW5kZXgpIDwgMCkge1xcbiAgICAgICAgaWYgKHRodW1ic1N3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcXG4gICAgICAgICAgaWYgKG5ld1RodW1ic0luZGV4ID4gY3VycmVudFRodW1ic0luZGV4KSB7XFxuICAgICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBuZXdUaHVtYnNJbmRleCAtIE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpICsgMTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5ld1RodW1ic0luZGV4ICsgTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgLSAxO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKG5ld1RodW1ic0luZGV4ID4gY3VycmVudFRodW1ic0luZGV4KSB7XFxuICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggLSBzbGlkZXNQZXJWaWV3ICsgMTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRodW1ic1N3aXBlci5zbGlkZVRvKG5ld1RodW1ic0luZGV4LCBpbml0aWFsID8gMCA6IHVuZGVmaW5lZCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIEFjdGl2YXRlIHRodW1ic1xcbiAgICBsZXQgdGh1bWJzVG9BY3RpdmF0ZSA9IDE7XFxuICAgIGNvbnN0IHRodW1iQWN0aXZlQ2xhc3MgPSBzd2lwZXIucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3M7XFxuXFxuICAgIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XFxuICAgICAgdGh1bWJzVG9BY3RpdmF0ZSA9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldztcXG4gICAgfVxcblxcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMudGh1bWJzLm11bHRpcGxlQWN0aXZlVGh1bWJzKSB7XFxuICAgICAgdGh1bWJzVG9BY3RpdmF0ZSA9IDE7XFxuICAgIH1cXG5cXG4gICAgdGh1bWJzVG9BY3RpdmF0ZSA9IE1hdGguZmxvb3IodGh1bWJzVG9BY3RpdmF0ZSk7XFxuXFxuICAgIHRodW1ic1N3aXBlci5zbGlkZXMucmVtb3ZlQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XFxuICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3AgfHwgKHRodW1ic1N3aXBlci5wYXJhbXMudmlydHVhbCAmJiB0aHVtYnNTd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkpIHtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRodW1ic1RvQWN0aXZhdGU7IGkgKz0gMSkge1xcbiAgICAgICAgdGh1bWJzU3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cXFwiJHtzd2lwZXIucmVhbEluZGV4ICsgaX1cXFwiXWApLmFkZENsYXNzKHRodW1iQWN0aXZlQ2xhc3MpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRodW1ic1RvQWN0aXZhdGU7IGkgKz0gMSkge1xcbiAgICAgICAgdGh1bWJzU3dpcGVyLnNsaWRlcy5lcShzd2lwZXIucmVhbEluZGV4ICsgaSkuYWRkQ2xhc3ModGh1bWJBY3RpdmVDbGFzcyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcbn07XFxudmFyIFRodW1icyQxID0ge1xcbiAgbmFtZTogJ3RodW1icycsXFxuICBwYXJhbXM6IHtcXG4gICAgdGh1bWJzOiB7XFxuICAgICAgc3dpcGVyOiBudWxsLFxcbiAgICAgIG11bHRpcGxlQWN0aXZlVGh1bWJzOiB0cnVlLFxcbiAgICAgIGF1dG9TY3JvbGxPZmZzZXQ6IDAsXFxuICAgICAgc2xpZGVUaHVtYkFjdGl2ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXRodW1iLWFjdGl2ZScsXFxuICAgICAgdGh1bWJzQ29udGFpbmVyQ2xhc3M6ICdzd2lwZXItY29udGFpbmVyLXRodW1icycsXFxuICAgIH0sXFxuICB9LFxcbiAgY3JlYXRlKCkge1xcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XFxuICAgICAgdGh1bWJzOiB7XFxuICAgICAgICBzd2lwZXI6IG51bGwsXFxuICAgICAgICBpbml0OiBUaHVtYnMuaW5pdC5iaW5kKHN3aXBlciksXFxuICAgICAgICB1cGRhdGU6IFRodW1icy51cGRhdGUuYmluZChzd2lwZXIpLFxcbiAgICAgICAgb25UaHVtYkNsaWNrOiBUaHVtYnMub25UaHVtYkNsaWNrLmJpbmQoc3dpcGVyKSxcXG4gICAgICB9LFxcbiAgICB9KTtcXG4gIH0sXFxuICBvbjoge1xcbiAgICBiZWZvcmVJbml0KCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgY29uc3QgeyB0aHVtYnMgfSA9IHN3aXBlci5wYXJhbXM7XFxuICAgICAgaWYgKCF0aHVtYnMgfHwgIXRodW1icy5zd2lwZXIpIHJldHVybjtcXG4gICAgICBzd2lwZXIudGh1bWJzLmluaXQoKTtcXG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSh0cnVlKTtcXG4gICAgfSxcXG4gICAgc2xpZGVDaGFuZ2UoKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBpZiAoIXN3aXBlci50aHVtYnMuc3dpcGVyKSByZXR1cm47XFxuICAgICAgc3dpcGVyLnRodW1icy51cGRhdGUoKTtcXG4gICAgfSxcXG4gICAgdXBkYXRlKCkge1xcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XFxuICAgICAgaWYgKCFzd2lwZXIudGh1bWJzLnN3aXBlcikgcmV0dXJuO1xcbiAgICAgIHN3aXBlci50aHVtYnMudXBkYXRlKCk7XFxuICAgIH0sXFxuICAgIHJlc2l6ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnRodW1icy5zd2lwZXIpIHJldHVybjtcXG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICBvYnNlcnZlclVwZGF0ZSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGlmICghc3dpcGVyLnRodW1icy5zd2lwZXIpIHJldHVybjtcXG4gICAgICBzd2lwZXIudGh1bWJzLnVwZGF0ZSgpO1xcbiAgICB9LFxcbiAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XFxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcXG4gICAgICBjb25zdCB0aHVtYnNTd2lwZXIgPSBzd2lwZXIudGh1bWJzLnN3aXBlcjtcXG4gICAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xcbiAgICAgIHRodW1ic1N3aXBlci5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcXG4gICAgfSxcXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xcbiAgICAgIGNvbnN0IHRodW1ic1N3aXBlciA9IHN3aXBlci50aHVtYnMuc3dpcGVyO1xcbiAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XFxuICAgICAgaWYgKHN3aXBlci50aHVtYnMuc3dpcGVyQ3JlYXRlZCAmJiB0aHVtYnNTd2lwZXIpIHtcXG4gICAgICAgIHRodW1ic1N3aXBlci5kZXN0cm95KCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgfSxcXG59O1xcblxcbi8vIFN3aXBlciBDbGFzc1xcblxcbmNvbnN0IGNvbXBvbmVudHMgPSBbXFxuICBEZXZpY2UkMSxcXG4gIFN1cHBvcnQkMSxcXG4gIEJyb3dzZXIkMSxcXG4gIFJlc2l6ZSxcXG4gIE9ic2VydmVyJDEsXFxuICBWaXJ0dWFsJDEsXFxuICBLZXlib2FyZCQxLFxcbiAgTW91c2V3aGVlbCQxLFxcbiAgTmF2aWdhdGlvbiQxLFxcbiAgUGFnaW5hdGlvbiQxLFxcbiAgU2Nyb2xsYmFyJDEsXFxuICBQYXJhbGxheCQxLFxcbiAgWm9vbSQxLFxcbiAgTGF6eSQxLFxcbiAgQ29udHJvbGxlciQxLFxcbiAgQTExeSxcXG4gIEhpc3RvcnkkMSxcXG4gIEhhc2hOYXZpZ2F0aW9uJDEsXFxuICBBdXRvcGxheSQxLFxcbiAgRWZmZWN0RmFkZSxcXG4gIEVmZmVjdEN1YmUsXFxuICBFZmZlY3RGbGlwLFxcbiAgRWZmZWN0Q292ZXJmbG93LFxcbiAgVGh1bWJzJDFcXG5dO1xcblxcbmlmICh0eXBlb2YgU3dpcGVyLnVzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gIFN3aXBlci51c2UgPSBTd2lwZXIuQ2xhc3MudXNlO1xcbiAgU3dpcGVyLmluc3RhbGxNb2R1bGUgPSBTd2lwZXIuQ2xhc3MuaW5zdGFsbE1vZHVsZTtcXG59XFxuXFxuU3dpcGVyLnVzZShjb21wb25lbnRzKTtcXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChTd2lwZXIpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXBlci5lc20uYnVuZGxlLmpzLm1hcFxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvanMvc3dpcGVyLmVzbS5idW5kbGUuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgMDpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiBtdWx0aSAuL2Rldi9qcy9hcHAuanMgLi9kZXYvanMvQ29tbW9uL21vYmlsZS1tZW51LmpzIC4vZGV2L2pzL0NvbW1vbi9zd2lwZXIuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gXyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgRDpcXFxcUmVwb3NpdG9yaWVzXFxcXHBvcnRmb2xpb1xcXFxkZXZcXFxcanNcXFxcYXBwLmpzICovXFxcIi4vZGV2L2pzL2FwcC5qc1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oLyohIEQ6XFxcXFJlcG9zaXRvcmllc1xcXFxwb3J0Zm9saW9cXFxcZGV2XFxcXGpzXFxcXENvbW1vblxcXFxtb2JpbGUtbWVudS5qcyAqL1xcXCIuL2Rldi9qcy9Db21tb24vbW9iaWxlLW1lbnUuanNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEQ6XFxcXFJlcG9zaXRvcmllc1xcXFxwb3J0Zm9saW9cXFxcZGV2XFxcXGpzXFxcXENvbW1vblxcXFxzd2lwZXIuanMgKi9cXFwiLi9kZXYvanMvQ29tbW9uL3N3aXBlci5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy9tdWx0aV8uL2Rldi9qcy9hcHAuanNfLi9kZXYvanMvQ29tbW9uL21vYmlsZS1tZW51LmpzXy4vZGV2L2pzL0NvbW1vbi9zd2lwZXIuanM/XCIpO1xuICAgIC8qKiovXG4gIH1cbiAgLyoqKioqKi9cblxufSk7Il0sImZpbGUiOiJhcHAubWluLmpzIn0=
